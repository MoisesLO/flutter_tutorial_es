[
  {
    "title": "1.1 Instalación en Windows",
    "subtitle": "Introduccion",
    "content": "<h1>Windows install</h1>    \n      Contenidos    \n    <ul class=\"section-nav\">\n      <li>Requerimientos del Sistema</li>\n      <li>Obtener el SDK de Flutter\n        <ul>\n          <li>Actualizando tu “path”</li>\n          <li>Ejecuta flutter doctor</li>\n        </ul>\n      </li>\n      <li>Configuración de Android\n        <ul>\n          <li>Instalar Android Studio</li>\n          <li>Configurar tu dispositivo Android</li>\n          <li>Configurar el emulador de Android</li>\n        </ul>\n      </li>\n      <li>Siguiente paso</li>\n    </ul>\n  \n  <h2>\n    Requerimientos del Sistema</h2>\n\n  <p>Para instalar y ejecutar Flutter, el ambiente de trabajo debe de cumplir al menos con los siguientes requerimientos:</p>\n\n  <ul>\n    <li>\n      <strong>Sistema Operativo</strong>: Windows 7 SP1 o superior (64-bit)</li>\n    <li>\n      <strong>Espacio en Disco</strong>: 400 MB (no incluye espacio en disco para IDE/herramientas).</li>\n    <li>\n      <strong>Herramientas</strong>: Flutter depende de que estas herramientas estén disponibles en tu entorno.\n      <ul>\n        <li>\n          Windows PowerShell 5.0 o superior (este es pre-instalado con Windows 10)</li>\n        <li>\n          <p>Git para Windows 2.x, con la opción <strong>Use Git from the Windows Command Prompt</strong></p>\n\n          <p>Si Git para Windows está ya instalado, asegúrate de poder correr comandos con <code>git</code> desde el\n            Command Prompt o PowerShell.</p>\n        </li>\n      </ul>\n    </li>\n  </ul>\n\n  <h2>\n    Obtener el SDK de Flutter</h2>\n\n  <ol>\n    <li>\n      <p>Descarga el siguiente paquete de instalación para obtener la versión más reciente stable release del\n        SDK Flutter:</p>\n\n      <p>flutter_windows_1.20.3-stable.zip</p>\n\n      <p>Para otros release channels, y compilaciones más viejas, mira la página SDK\n        archive.</p>\n    </li>\n    <li>Extraiga el archivo zip y coloque el contenido de <code>flutter</code> en la ubicación\n      deseada de instalación para el Flutter SDK (ej. <code>C:\\src\\flutter</code>; no instale\n      flutter en un directorio como <code>C:\\Program Files\\</code> que requiere permisos\n      de administrador).</li>\n    <li>Localice el archivo <code>flutter_console.bat</code> dentro del directorio de <code>flutter</code>. Inícialo\n      con doble clic.</li>\n  </ol>\n\n  <p>¡Ahora está todo listo para ejecutar los comandos de Flutter en la consola de Flutter!</p>\n\n  <p>Para actualizar una versión existente de Flutter, vea Actualizando Flutter.</p>\n\n  <h3>\n    Actualizando tu “path”</h3>\n\n  <p>Si deseas ejecutar los comandos de Flutter en un ventana de comandos regular de Windows, siga\n    estos pasos y agregue Flutter a las variables de entorno en el <code>PATH</code>:</p>\n\n  <ul>\n    <li>Desde la barra de busqueda en Inicio, escribe ‘env’ y selecciona <strong>Editar variables de\n      entorno para tu cuenta</strong>\n    </li>\n    <li>Debajo de <strong>Variables de usuario</strong> verifica si existe una entrada llamada <strong>Path</strong>:\n      <ul>\n        <li>Si la entrada existe, agrega la ruta completa a <code>flutter\\bin</code> usando <code>;</code>\n          como separador de los valores existentes.</li>\n        <li>Si la entrada no existe, crea una nueva variable de usuario llamada <code>Path</code>\n          con la ruta completa <code>flutter\\bin</code> como su valor.</li>\n      </ul>\n    </li>\n  </ul>\n\n  <p>Ten en cuenta que tendrás que cerrar y reabrir cualquier ventana de consola\n    existente para que estos cambios surtan efecto.</p>\n\n  <h3>\n    Ejecuta <code>flutter doctor</code>\n  </h3>\n\n  <p>Desde una ventana de consola que tenga el directorio Flutter en su path (ver arriba),\n    ejecuta el siguiente comando para ver si hay algunas dependencias de la plataforma que\n    necesites para completar la configuración:</p>\n\n    <pre class=\"highlight\"><code>C:\\src\\flutter&gt;flutter doctor\n</code></pre>\n\n  <p>Este comando verifica tu entorno y muestra un reporte del estado de tu\n    instalación de Flutter. Verifica la salida con cuidado para otros programas que\n    pudieras necesitar o tareas a realizar (mostradas en texto en <strong>negrita</strong>).</p>\n\n  <p>Por Ejemplo:</p>\n\n    <pre>[-] Android toolchain - develop for Android devices\n    • Android SDK at D:\\Android\\sdk\n    <strong>✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</strong>\n    • Try re-installing or updating your Android SDK,\n      visit https://flutter.io/setup/#android-setup for detailed instructions.\n</pre>\n\n  <p>La siguiente sección describe como desempeñar estas tareas y finalizar el proceso de\n    configuración. Una vez que tenga instalado cualquiera de las dependencias faltantes,\n    puedes ejecutar el comando <code>flutter doctor</code> de nuevo para verificar que todo se ha configurado correctamente.</p>  \n    <p>Las herramienta <code>flutter</code> usa Google Analytics para, anónimamente, reportar estadísticas de\n      características de uso y reportes básicos de errores. Estos datos son utilizados para ayudar a mejorar las herramientas de Flutter con el tiempo.\n      Analytics no envía cada ejecución o cualquier ejecución dentro del <code>flutter config</code>,\n      por lo que puede optar por no participar en los análisis antes de enviar los datos. Para deshabilitar los reportes,\n      teclee <code>flutter config --no-analytics</code> y para mostrar la\n      configuración actual, teclee <code>flutter config</code>. Vea la Privacy Policy de Google</p>\n\n  \n\n  <h2>\n    Configuración de Android</h2>\n\n    <p> <strong>Nota:</strong>\n      Flutter requiere de una completa instalación de Android Studio para proveer\n      las dependencias de la plataforma de Android. De cualquier manera, puede desarrollar sus\n      apps de Flutter en diferentes editores; hablaremos de ello en un paso siguiente.</p>\n  \n\n  <h3>\n    Instalar Android Studio</h3>\n\n  <ol>\n    <li>Descarga e instala Android Studio.</li>\n    <li>Inicia Android Studio, y sigue todo el ‘Android Studio Setup Wizard’. Este\n      Instalará la versión más reciente de Android SDK, Android SDK Platform-Tools y\n      Android SDK Build-Tools, Las cuales son requeridas por Flutter cuando se desarrolla para Android.</li>\n  </ol>\n\n  <h3>\n    Configurar tu dispositivo Android</h3>\n\n  <p>Prepara la ejecución y pruebas de app de Flutter en un dispositivo de Android, necesitará\n    un dispositivo Android ejecutando Android 4.1 (API nivel 16) o superior.</p>\n\n  <ol>\n    <li>Habilita <strong>Opciones de desarrollador</strong> y <strong>Depurador por USB</strong> en tu dispositivo. Instrucciones detalladas\n      están disponibles en la Documentación de Android.</li>\n    <li>Solo en Windows: Instala Google USB Driver\n    </li>\n    <li>Utilizando el cable USB, conecta tu móvil de la computadora, de requerirse en tu\n      dispositivo, autoriza el acceso de la computadora a tu dispositivo.</li>\n    <li>En terminal, ejecuta el comando <code>flutter devices</code>  para verificar que Flutter ha reconocido\n      tu dispositivo Android conectado.</li>\n  </ol>\n\n  <p>Por defecto, Flutter utiliza la versión SDK de Android donde se encuentren las herramientas <code>adb</code>. Si\n    quieres que Flutter utilice alguna instalación diferente del SDK de Android, deberás configurar\n    la variable de entorno <code>ANDROID_HOME</code> en el directorio de instalación.</p>\n\n  <h3>\n    Configurar el emulador de Android</h3>\n\n  <p>Prepare la ejecución y pruebas de app de Flutter en el emulador de Android, siguiendo estos pasos:</p>\n\n  <ol>\n    <li>Habilita VM acceleration en tu equipo.</li>\n    <li>Abra <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> y selecciona\n      <strong>Create Virtual Device</strong>. (El submenú <strong>Android</strong> está presente solo\n      cuando se encuentra dentro de un proyecto de Android.)</li>\n    <li>Elija un dispositivo y seleccione <strong>Next</strong>.</li>\n    <li>Selecciona una o más imágenes del sistema que quieres emular,\n      y selecciona <strong>Next</strong>. Una imagen <em>x86</em> o <em>x86_64</em> es recomendada.</li>\n    <li>Dentro de Emulated Performance, selecciona <strong>Hardware - GLES 2.0</strong> para habilitarlo\n      aceleración de hardware.</li>\n    <li>\n      <p>Verifica que la configuración de AVD es correcta, y selecciona <strong>Finish</strong>.</p>\n\n      <p>Para mayor detalle de los pasos de arriba, vea Administrando AVDs.</p>\n    </li>\n    <li>En el Administrador de Dispositivos Virtuales de Android (AVD), da clic en la barra de herramienta <strong>Run</strong>.\n      El emulador iniciará el arranque y mostrara el lienzo (canvas) por defecto para la versión del SO y dispositivo seleccionado.</li>\n  </ol>"
  },
  {
    "title": "1.2 Instalación en Linux",
    "subtitle": "Introduccion",
    "content": "<div>\n    <h1>Instalación en macOS</h1>\n    <div>\n        <header>\n            Contenidos\n        </header>\n        <ul>\n            <li>Requerimiento del sistema</li>\n            <li>Obtener el SDK de Flutter\n                <ul>\n                    <li>Ejecuta flutter doctor</li>\n                    <li>Actualiza tu path</li>\n                </ul>\n            </li>\n            <li>Configurar plataforma</li>\n            <li>Configuración de iOS\n                <ul>\n                    <li>Instalar Xcode</li>\n                    <li>Configurar el simulador iOS</li>\n                    <li>Crea y ejecuta una app simple en Flutter</li>\n                    <li>Desplegar en dispositivos iOS</li>\n                </ul>\n            </li>\n            <li>Configuración de Android\n                <ul>\n                    <li>Instalar Android Studio</li>\n                    <li>Configurar tu dispositivo Android</li>\n                    <li>Configurar el emulador de Android</li>\n                </ul>\n            </li>\n            <li>Siguiente paso</li>\n        </ul>\n    </div>\n    <h2>Requerimiento del sistema</h2>\n    <p>Para instalar y ejecutar Flutter, tu entorno de trabajo debe cumplir los siguientes\n        requisitos mínimos:</p>\n    <ul>\n        <li>\n            <strong>Sistema Operativo</strong>: macOS (64-bit)\n        </li>\n        <li>\n            <strong>Espacio en disco</strong>: 700 MB (Esto no incluye el espacio en disco para\n            IDE/tools).\n        </li>\n        <li>\n            <strong>Herramientas</strong>: Flutter necesita que estas herramientas de línea de\n            comando estén disponibles en tu entorno.\n            <ul>\n                <li><code>bash</code></li>\n                <li><code>mkdir</code></li>\n                <li><code>rm</code></li>\n                <li><code>git</code></li>\n                <li><code>curl</code></li>\n                <li><code>unzip</code></li>\n                <li><code>which</code></li>\n            </ul>\n        </li>\n    </ul>\n    <h2>\n        Obtener el SDK de Flutter</h2>\n    <ol>\n        <li>\n            <p>Descarga el siguiente paquete de instalación para obtener la versión más reciente\n                stable release del\n                SDK Flutter:</p>\n            <p>flutter_macos_1.20.3-stable.zip</p>\n            <p>Para otros release channels, y compilaciones más viejas, mira la página SDK\n                archive.</p>\n        </li>\n        <li>\n            <p>Extraiga el archivo en la ubicación deseada, por ejemplo:</p>\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code> $ cd ~/development\n$ unzip ~/Downloads/flutter_macos_1.20.3-stable.zip\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Agrega la herramienta <code>flutter</code> a tu path:</p>\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div>\n                            <pre><code> $ export PATH=\"$PATH:`pwd`/flutter/bin\"</code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <p>Este comando configura tu variable <code>PATH</code> sólo\n                para la ventana <em>actual</em> de terminal.\n                Para agregar Flutter permanentemente a tu path, mira Actualiza<br>\n                el path.</p>\n        </li>\n        <li>\n            <p>Opcionalmente, pre-descarga binarios de desarrollo:</p>\n            <p>La herramienta <code>flutter</code> descarga binarios de\n                desarrollo específicos de plataforma según\n                los necesita. Para escenarios en los que pre-descargar estos artefactos es\n                preferible\n                (ej., entornos de compilación herméticos, disponibilidad de red intermitente), los\n                binarios iOS\n                y Android pueden ser descargados por anticipado ejecutando:</p>\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div>\n                            <pre><code> $ flutter precache</code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <p>Para opciones adicionales de descarga, mira <code>flutter\n                help precache</code>.</p>\n        </li>\n    </ol>\n    <p>¡Ahora estas preparado para ejecutar comandos de Flutter!</p>\n    <p><strong>Nota:</strong>\n        Para actualizar una versión existente de Flutter, mira\n        Actualizando Flutter.</p>\n    </aside>\n    <h3>Ejecuta flutter doctor</h3>\n    <p>Ejecuta el siguiente comando para verificar si existe alguna dependencia que se necesite para\n        completar la configuración (para una salida detallada, añade la etiqueta <code>-v</code>):\n    </p>\n    <div>\n        <div>\n            <div>\n                <button>content_copy</button>\n                <div><pre><code>$ flutter doctor\n    </code></pre>\n                </div>\n            </div>\n        </div>\n    </div>\n    <p>Este comando verifica tu entorno y muestra un reporte en la ventana del terminal.\n        El SDK de Dart esta empaquetado con Flutter, no es necesario instalar Dart por separado.\n        Verifica la salida con cuidado para otros programas que\n        pudieras necesitar o tareas a realizar (mostradas en texto en <strong>negrita</strong>).</p>\n    <p>Por ejemplo:</p>\n    <div>\n        <button>content_copy</button>\n        <div>\n            <pre>[-] Android toolchain - develop for Android devices\n• Android SDK at /Users/obiwan/Library/Android/sdk\n<strong>✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</strong>\n• Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions.\n    </pre>\n        </div>\n    </div>\n\n    <p>La siguiente sección describe cómo desempeñar estas tareas y finalizar el proceso de\n        configuración.</p>\n\n    <p>Una vez que tengaS instalado cualquiera de las dependencias faltantes, ejecuta el comando\n        <code>flutter doctor</code>\n        de nuevo para verificar que todo se ha configurado correctamente.</p>\n\n\n    <p>Las herramienta <code>flutter</code> usa Google Analytics para,\n        anónimamente, reportar estadísticas de\n        características de uso y reportes básicos de errores. Estos datos son utilizados para ayudar\n        a mejorar las herramientas de Flutter con el tiempo.\n        Analytics no envía cada ejecución o cualquier ejecución dentro del <code>flutter\n            config</code>,\n        por lo que puede optar por no participar en los análisis antes de enviar los datos. Para\n        deshabilitar los reportes,\n        teclee <code>flutter config --no-analytics</code> y para mostrar\n        la\n        configuración actual, teclee <code>flutter config</code>. Vea la\n        Privacy Policy de Google</p>\n\n    </aside>\n\n    <h3>\n        Actualiza tu path</h3>\n\n    <p>Se puede actualizar tu variable PATH para sólo para la sesión actual en la línea de comandos,\n        como se muestra en Obtener Flutter SDK. Probablemente necesitarás\n        actualizar esta variable permanentemente, de esta manera podrás ejecutar el comando <code>flutter</code>\n        en cualquier sesión de terminal.</p>\n\n    <p>Los pasos para modificar esta variable permanentemente para todas las sesiones de terminal\n        son específicas del equipo.\n        Típicamente se agrega una línea al archivo que se ejecuta cada que abres\n        una nueva ventana. Por ejemplo:</p>\n\n    <ol>\n        <li>Determine el directorio donde se encuentra el SDK de Flutter.\n            Necesitaras esto en el paso 3.\n        </li>\n        <li>Abre (o crea) <code>$HOME/.bash_profile</code>. La dirección\n            del archivo\n            puede estar en un lugar diferente en tu equipo.\n        </li>\n        <li>Agrega la siguiente línea y cambia <code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code>\n            para ser\n            la ruta donde has clonado el repositorio de Flutter:\n        </li>\n    </ol>\n\n    <p><code>terminal\n        $ export PATH=\"$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin\"\n    </code></p>\n\n    <ol>\n        <li>Ejecuta <code>source $HOME/.bash_profile</code> para refrescar\n            la ventana actual.\n        </li>\n        <li>\n            <p>Verifica que el directorio de <code>flutter/bin</code> esta\n                en tu PATH ejecutando el siguiente comando:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ echo $PATH\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n    </ol>\n\n    <p>Para más detalles, ver Estas preguntas en StackExchange.</p>\n\n    <h2>\n        Configurar plataforma</h2>\n\n    <p>macOS permite desarrollar apps con Fluter para ambos iOS y Android. Termina al menos\n        una de las configuraciones para las plataformas ahora, para poder ser capaz de crear y\n        ejecutar\n        su primera app en Flutter.</p>\n\n    <h2>\n        Configuración de iOS</h2>\n\n    <h3>\n        Instalar Xcode</h3>\n\n    <p>Para desarrollar apps con Flutter en iOS, necesitaras una Mac con Xcode 9.0 o más\n        reciente:</p>\n\n    <ol>\n        <li>Instalar Xcode 9.0 o más reciente (vía descarga web o\n            Mac App Store).\n        </li>\n        <li>\n            <p>Configurar la línea de comandos de Xcode para usar el recién versión recién instalada\n                de Xcode\n                ejecutando lo siguiente desde la línea de comandos:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n    </ol>\n\n    <p>Esta es el directorio correcto la mayoría de casos, cuando quiera hacer uso de la versión más\n        reciente de Xcode.\n        Si necesita usar una versión diferente, especifique esa dirección en su lugar.</p>\n    <ol>\n        <li>Asegúrese de firmar el acuerdo de licencia de Xcode abriendo por primera vez y\n            confirmando o\n            ejecutando <code>sudo xcodebuild -license</code> desde la\n            línea de comando.\n        </li>\n    </ol>\n\n    <p>Con Xcode, serás capaz de ejecutar apps de Flutter en un dispositivo o un simulador.</p>\n\n    <h3>\n        Configurar el simulador iOS</h3>\n\n    <p>Para preparar la ejecución y probar tu app de Flutter en el simulador de iOS, siga estos\n        pasos:</p>\n\n    <ol>\n        <li>\n            <p>En su Mac, encuentre el simulador vía Spotlight o utilizando el siguiente\n                comando:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ open -a Simulator</code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>Asegura que el simulador utilizado este utilizando un dispositivo de 64 bits (iPhone 5s\n            o superior) verificando la configuración\n            en el menú del simulador <strong>Hardware &gt; Device</strong>.\n        </li>\n        <li>Dependiendo del tamaño de la pantalla de la máquina de desarrollo, se simulará la\n            calidad en la pantalla de tu dispositivo iOS el cual\n            podría desbordar la pantalla, configura la escala del dispositivo en el menú <strong>Window\n                &gt; Scale</strong> en el simulador.\n        </li>\n    </ol>\n\n    <h3>\n        Crea y ejecuta una app simple en Flutter</h3>\n\n    <p>Para crear tu primera app Flutter y probar tu configuración, sigue los siguientes pasos:</p>\n\n    <ol>\n        <li>\n            <p>Crea una nueva app Flutter ejecutando lo siguiente en la línea de comandos:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ flutter create my_app\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Un directorio <code>my_app</code> se ha creado, conentiendo\n                la app de inicio de Flutter. Entra en este directorio:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ cd my_app\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Para lanzar la app en el Simulador, asegurate que el Simulador esta ejecutándose e\n                introduce:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ flutter run\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n    </ol>\n\n    <h3>\n        Desplegar en dispositivos iOS</h3>\n\n    <p>Para desplegar tu app de Flutter en un dispositivo físico de iOS, necesitarás algunas\n        herramientas extras y una cuenta de Apple. También necesitarás configurar el dispositivo\n        físico para despegarlo en Xcode.</p>\n\n    <ol>\n        <li>Instalar homebrew.</li>\n        <li>\n            <p>Asegúrate que homebrew esta actualizado:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ brew update\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Instala las herramientas para desplegar las apps de Flutter en dispositivos iOS\n                ejecutando los siguientes comandos:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ brew install --HEAD usbmuxd\n    $ brew link usbmuxd\n    $ brew install --HEAD libimobiledevice\n    $ brew install ideviceinstaller ios-deploy cocoapods\n    $ pod setup\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n\n            <p><strong>Nota:</strong>\n                Los primeros dos comandos arriba son necesarios como un\n                arreglo temporal hasta que el nuevo lanzamiento de libusbmuxd, como se explica en\n                libusbmuxd issue #46 y\n                Flutter issue #22595.</p>\n\n            </aside>\n\n            <p>Si cualquiera de estos comandos falla con error, ejecuta <code>brew doctor</code> y\n                sigue las instrucciones\n                para resolver el problema.</p>\n        </li>\n        <li>\n            <p>Continua con el flujo de registro en Xcode para provisionar tu proyecto:</p>\n\n            <ol>\n                <li>Abre el espacio de trabajo por defecto en tu proyecto ejecutando <code>open\n                    ios/Runner.xcworkspace</code> en una ventana de terminal del directorio donde\n                    está el proyecto\n                    de Flutter.\n                </li>\n                <li>En Xcode, selecciona el proyecto <code>Runner</code>\n                    en el panel de navegación del lado izquierdo.\n                </li>\n                <li>\n                    <p>En la página de configuración de <code>Runner</code>, asegúrate que tu equipo\n                        de\n                        desarrollo esta seleccionado debajo de <strong>General &gt; Signing &gt;\n                            Team</strong>.\n                        Cuando seleccionas un equipo, Xcode crea y descarga un Certificado de\n                        Desarrollo, registra tu dispositivo a tu cuenta, y crea y descarga\n                        un perfil provisional (de necesitarse).</p>\n\n                    <ul>\n                        <li>\n                            <p>Para empezar tu primer proyecto de desarrollo en iOS, necesitarás\n                                registrarte en\n                                Xcode con tu ID de Apple.<img src=\"/images/setup/xcode-account.png\"\n                                                              alt=\"Xcode account add\"\n                                                              class=\"mw-100\">\n                                Hay soporte en desarrollo y pruebas para cualquier ID de Apple.\n                                Enrolarte en el\n                                programa de desarrolladores de Apple es necesario para distribuir tu\n                                app en el App\n                                Store. Ver la eligiendo un Membership.</p>\n                        </li>\n                        <li>\n                            <p>La primera ocasiones que utilices un dispositivo físico\n                                para desarrollo iOS, necesitarás autorizar ambas tu Mac y tu\n                                Certificado de\n                                Desarrollo en el dispositivo. Selecciona <code>Trust</code> en la\n                                ventana que te\n                                muestra la\n                                primera vez que es conectado tu dispositivo iOs a tu Mac.</p>\n\n                            <p><img src=\"/images/setup/trust-computer.png\" alt=\"Trust Mac\"\n                                    class=\"mw-100\"></p>\n\n                            <p>Ahora, ve a la configuración de la app en el dispositivo iOS,\n                                selecciona <strong>General &gt; Device Management</strong> y\n                                autoriza el Certificado.</p>\n                        </li>\n                        <li>\n                            <p>Si tu registro automático falla en Xcode, verifica que el valor del\n                                proyecto sea único\n                                <strong>General &gt; Identity &gt; Bundle Identifier</strong>.\n                                <br>\n                                <img src=\"/images/setup/xcode-unique-bundle-id.png\"\n                                     alt=\"Check the app's Bundle ID\" class=\"mw-100\"></p>\n                        </li>\n                    </ul>\n                </li>\n            </ol>\n        </li>\n        <li>Iniciatu app ejecutando el comando <code>flutter run</code>.\n        </li>\n    </ol>\n\n    <h2>\n        Configuración de Android</h2>\n\n\n    <p><strong>Nota:</strong>\n        Flutter requiere de una completa instalación de Android Studio para proveer\n        las dependencias de la plataforma de Android. De cualquier manera, puede desarrollar sus\n        apps de Flutter en diferentes editores; hablaremos de ello en un paso siguiente.</p>\n    </aside>\n\n    <h3>\n        Instalar Android Studio</h3>\n\n    <ol>\n        <li>Descarga e instala Android Studio.</li>\n        <li>Inicia Android Studio, y sigue todo el ‘Android Studio Setup Wizard’. Este\n            Instalará la versión más reciente de Android SDK, Android SDK Platform-Tools y\n            Android SDK Build-Tools, Las cuales son requeridas por Flutter cuando se desarrolla para\n            Android.\n        </li>\n    </ol>\n\n    <h3>\n        Configurar tu dispositivo Android</h3>\n\n    <p>Prepara la ejecución y pruebas de app de Flutter en un dispositivo de Android, necesitará\n        un dispositivo Android ejecutando Android 4.1 (API nivel 16) o superior.</p>\n\n    <ol>\n        <li>Habilita <strong>Opciones de desarrollador</strong> y <strong>Depurador por USB</strong>\n            en tu dispositivo. Instrucciones detalladas\n            están disponibles en la Documentación de Android.\n        </li>\n        <li>Solo en Windows: Instala Google USB Driver\n        </li>\n        <li>Utilizando el cable USB, conecta tu móvil de la computadora, de requerirse en tu\n            dispositivo, autoriza el acceso de la computadora a tu dispositivo.\n        </li>\n        <li>En terminal, ejecuta el comando <code>flutter devices</code>\n            para verificar que Flutter ha reconocido\n            tu dispositivo Android conectado.\n        </li>\n    </ol>\n\n    <p>Por defecto, Flutter utiliza la versión SDK de Android donde se encuentren las herramientas\n        <code>adb</code>. Si\n        quieres que Flutter utilice alguna instalación diferente del SDK de Android, deberás\n        configurar\n        la variable de entorno <code>ANDROID_HOME</code> en el directorio\n        de instalación.</p>\n\n    <h3>\n        Configurar el emulador de Android</h3>\n\n    <p>Prepare la ejecución y pruebas de app de Flutter en el emulador de Android, siguiendo estos\n        pasos:</p>\n\n    <ol>\n        <li>Habilita VM acceleration en tu equipo.</li>\n        <li>Abra <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> y selecciona\n            <strong>Create Virtual Device</strong>. (El submenú <strong>Android</strong> está\n            presente solo\n            cuando se encuentra dentro de un proyecto de Android.)\n        </li>\n        <li>Elija un dispositivo y seleccione <strong>Next</strong>.</li>\n        <li>Selecciona una o más imágenes del sistema que quieres emular,\n            y selecciona <strong>Next</strong>. Una imagen <em>x86</em> o <em>x86_64</em> es\n            recomendada.\n        </li>\n        <li>Dentro de Emulated Performance, selecciona <strong>Hardware - GLES 2.0</strong> para\n            habilitarlo\n            aceleración de hardware.\n        </li>\n        <li>\n            <p>Verifica que la configuración de AVD es correcta, y selecciona\n                <strong>Finish</strong>.</p>\n\n            <p>Para mayor detalle de los pasos de arriba, vea Administrando AVDs.</p>\n        </li>\n        <li>En el Administrador de Dispositivos Virtuales de Android (AVD), da clic en la barra de\n            herramienta <strong>Run</strong>.\n            El emulador iniciará el arranque y mostrara el lienzo (canvas) por defecto para la\n            versión del SO y dispositivo seleccionado.\n        </li>\n    </ol>\n</div>"
  },
  {
    "title": "1.3 Instalación en Mac",
    "subtitle": "Introduccion",
    "content": "<div>\n    <h1>Instalación en Linux</h1>\n    <div>\n        <header class=\"site-toc__title\">\n            Contenidos\n        </header>\n        <ul class=\"section-nav\">\n            <li>Requerimiento del Sistema</li>\n            <li>Obtener el SDK de Flutter\n                <ul>\n                    <li>Ejecuta flutter doctor</li>\n                    <li>Actualiza tu path</li>\n                </ul>\n            </li>\n            <li>Configuración de Android\n                <ul>\n                    <li>Instalar Android Studio</li>\n                    <li>Configurar tu dispositivo Android</li>\n                    <li>Configurar el emulador de Android</li>\n                </ul>\n            </li>\n            <li>Siguiente paso</li>\n        </ul>\n    </div>\n    <h2>\n        Requerimiento del Sistema</h2>\n\n    <p>Para instalar y ejecutar Flutter, el entorno de trabajo debe estos requisitos mínimos:</p>\n\n    <ul>\n        <li>\n            <strong>Sistema Operativo</strong>: Linux (64-bit)</li>\n        <li>\n            <strong>Espacio en Disco</strong>: 600 MB (no incluye espacio en disco para IDE/herramientas).</li>\n        <li>\n            <strong>Herramientas</strong>: Flutter  depende de que estas herramientas estén disponibles en tu entorno.\n            <ul>\n                <li><code>bash</code></li>\n                <li><code>curl</code></li>\n                <li>\n                    <code>git</code> 2.x</li>\n                <li><code>mkdir</code></li>\n                <li><code>rm</code></li>\n                <li><code>unzip</code></li>\n                <li><code>which</code></li>\n                <li><code>xz-utils</code></li>\n            </ul>\n        </li>\n        <li>\n            <strong>Bibliotecas Compartidas</strong>: El comando <code>test</code> en Flutter  depende de que estas bibliotecas estén disponibles en tu entorno.\n            <ul>\n                <li>\n                    <code>libGLU.so.1</code> -  suministrada por mesa packages ej. <code>libglu1-mesa</code> en Ubuntu/Debian</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>\n        Obtener el SDK de Flutter</h2>\n\n    <ol>\n        <li>\n            <p>Descarga el siguiente paquete de instalación para obtener la versión más reciente stable release del\n                SDK Flutter:</p>\n\n            <p>flutter_linux_1.20.3-stable.tar.xz</p>\n\n            <p>Para otros release channels, y compilaciones más viejas, mira la página SDK\n                archive.</p>\n        </li>\n        <li>\n            <p>Extraiga el archivo en la ubicación deseada, por ejemplo:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code> $ cd ~/development\n $ tar xf ~/Downloads/flutter_linux_1.20.3-stable.tar.xz\n</code></pre></div></div></div>    </div>\n        </li>\n        <li>\n            <p>Agrega la herramienta <code>flutter</code> a tu path:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code> $ export PATH=\"$PATH:`pwd`/flutter/bin\"\n</code></pre></div></div></div>    </div>\n\n            <p>Este comando configura tu variable <code>PATH</code> sólo para la ventana <em>actual</em> de terminal.\n                Para agregar Flutter permanentemente a tu path, mira Actualiza<br>\n                    el path.</p>\n        </li>\n        <li>\n            <p>Opcionalmente, pre-descarga binarios de desarrollo:</p>\n\n            <p>La herramienta <code>flutter</code> descarga binarios de desarrollo específicos de plataforma según\n                los necesita. Para escenarios en los que pre-descargar estos artefactos es preferible\n                (ej., entornos de compilación herméticos, disponibilidad de red intermitente), los binarios iOS\n                y Android pueden ser descargados por anticipado ejecutando:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code> $ flutter precache\n</code></pre></div></div></div>    </div>\n\n            <p>Para opciones adicionales de descarga, mira <code>flutter help precache</code>.</p>\n        </li>\n    </ol>\n\n    <p>¡Ahora estas preparado para ejecutar comandos de Flutter!</p>    \n        <p><i class=\"fas fa-info-circle\"></i> <strong>Nota:</strong>\n            Para actualizar una versión existente de Flutter, mira\n            Actualizando Flutter.</p>\n    </aside>\n\n    <h3 id=\"ejecuta-flutter-doctor\">\n        Ejecuta flutter doctor</h3>\n\n    <p>Ejecuta el siguiente comando para verificar si existe alguna dependencia que se necesite para\n        completar la configuración (para una salida detallada, añade la etiqueta <code>-v</code>):</p>\n\n    <div><div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code>$ flutter doctor\n</code></pre></div></div></div></div>\n\n    <p>Este comando verifica tu entorno y muestra un reporte en la ventana del terminal.\n        El SDK de Dart esta empaquetado con Flutter, no es necesario instalar Dart por separado.\n        Verifica la salida con cuidado para otros programas que\n        pudieras necesitar o tareas a realizar (mostradas en texto en <strong>negrita</strong>).</p>\n\n    <p>Por ejemplo:</p>\n    <div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre>[-] Android toolchain - develop for Android devices\n    • Android SDK at /Users/obiwan/Library/Android/sdk\n    <strong>✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</strong>\n    • Try re-installing or updating your Android SDK,\n      visit https://flutter.io/setup/#android-setup for detailed instructions.\n</pre></div></div>\n\n    <p>La siguiente sección describe cómo desempeñar estas tareas y finalizar el proceso de configuración.</p>\n\n    <p>Una vez que tengaS instalado cualquiera de las dependencias faltantes, ejecuta el comando <code>flutter doctor</code>\n        de nuevo para verificar que todo se ha configurado correctamente.</p>    \n        <p>Las herramienta <code>flutter</code> usa Google Analytics para, anónimamente, reportar estadísticas de\n            características de uso y reportes básicos de errores. Estos datos son utilizados para ayudar a mejorar las herramientas de Flutter con el tiempo.\n            Analytics no envía cada ejecución o cualquier ejecución dentro del <code>flutter config</code>,\n            por lo que puede optar por no participar en los análisis antes de enviar los datos. Para deshabilitar los reportes,\n            teclee <code>flutter config --no-analytics</code> y para mostrar la\n            configuración actual, teclee <code>flutter config</code>. Vea la Privacy Policy de Google</p>\n\n    </aside>\n\n    <h3 id=\"actualiza-tu-path\">\n        Actualiza tu path</h3>\n\n    <p>Se puede actualizar tu variable PATH para sólo para la sesión actual en la línea de comandos,\n        como se muestra en Obtener Flutter SDK. Probablemente necesitarás\n        actualizar esta variable permanentemente, de esta manera podrás ejecutar el comando <code>flutter</code> en cualquier sesión de terminal.</p>\n\n    <p>Los pasos para modificar esta variable permanentemente para todas las sesiones de terminal son específicas del equipo.\n        Típicamente se agrega una línea al archivo que se ejecuta cada que abres\n        una nueva ventana. Por ejemplo:</p>\n\n    <ol>\n        <li>Determine el directorio donde se encuentra el SDK de Flutter.\n            Necesitaras esto en el paso 3.</li>\n        <li>Abre (o crea) <code>$HOME/.bash_profile</code>. La dirección del archivo\n            puede estar en un lugar diferente en tu equipo.</li>\n        <li>Agrega la siguiente línea y cambia <code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code> para ser\n            la ruta donde has clonado el repositorio de Flutter:</li>\n    </ol>\n\n    <p><code>terminal\n        $ export PATH=\"$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin\"\n    </code></p>\n\n    <ol>\n        <li>Ejecuta <code>source $HOME/.bash_profile</code> para refrescar la ventana actual.</li>\n        <li>\n            <p>Verifica que el directorio de <code>flutter/bin</code> esta en tu PATH ejecutando el siguiente comando:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code>$ echo $PATH\n</code></pre></div></div></div>    </div>\n        </li>\n    </ol>\n\n    <p>Para más detalles, ver Estas preguntas en StackExchange.</p>\n\n    <h2>\n        Configuración de Android</h2>\n\n    \n        <p><i class=\"fas fa-info-circle\"></i> <strong>Nota:</strong>\n            Flutter requiere de una completa instalación de Android Studio para proveer\n            las dependencias de la plataforma de Android. De cualquier manera, puede desarrollar sus\n            apps de Flutter en diferentes editores; hablaremos de ello en un paso siguiente.</p>\n    </aside>\n\n    <h3 id=\"instalar-android-studio\">\n        Instalar Android Studio</h3>\n\n    <ol>\n        <li>Descarga e instala Android Studio.</li>\n        <li>Inicia Android Studio, y sigue todo el ‘Android Studio Setup Wizard’. Este\n            Instalará la versión más reciente de Android SDK, Android SDK Platform-Tools y\n            Android SDK Build-Tools, Las cuales son requeridas por Flutter cuando se desarrolla para Android.</li>\n    </ol>\n\n    <h3 id=\"configurar-tu-dispositivo-android\">\n        Configurar tu dispositivo Android</h3>\n\n    <p>Prepara la ejecución y pruebas de app de Flutter en un dispositivo de Android, necesitará\n        un dispositivo Android ejecutando Android 4.1 (API nivel 16) o superior.</p>\n\n    <ol>\n        <li>Habilita <strong>Opciones de desarrollador</strong> y <strong>Depurador por USB</strong> en tu dispositivo. Instrucciones detalladas\n            están disponibles en la Documentación de Android.</li>\n        <li>Solo en Windows: Instala Google USB Driver\n        </li>\n        <li>Utilizando el cable USB, conecta tu móvil de la computadora, de requerirse en tu\n            dispositivo, autoriza el acceso de la computadora a tu dispositivo.</li>\n        <li>En terminal, ejecuta el comando <code>flutter devices</code>  para verificar que Flutter ha reconocido\n            tu dispositivo Android conectado.</li>\n    </ol>\n\n    <p>Por defecto, Flutter utiliza la versión SDK de Android donde se encuentren las herramientas <code>adb</code>. Si\n        quieres que Flutter utilice alguna instalación diferente del SDK de Android, deberás configurar\n        la variable de entorno <code>ANDROID_HOME</code> en el directorio de instalación.</p>\n\n    <h3 id=\"configurar-el-emulador-de-android\">\n        Configurar el emulador de Android</h3>\n\n    <p>Prepare la ejecución y pruebas de app de Flutter en el emulador de Android, siguiendo estos pasos:</p>\n\n    <ol>\n        <li>Habilita VM acceleration en tu equipo.</li>\n        <li>Abra <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> y selecciona\n            <strong>Create Virtual Device</strong>. (El submenú <strong>Android</strong> está presente solo\n            cuando se encuentra dentro de un proyecto de Android.)</li>\n        <li>Elija un dispositivo y seleccione <strong>Next</strong>.</li>\n        <li>Selecciona una o más imágenes del sistema que quieres emular,\n            y selecciona <strong>Next</strong>. Una imagen <em>x86</em> o <em>x86_64</em> es recomendada.</li>\n        <li>Dentro de Emulated Performance, selecciona <strong>Hardware - GLES 2.0</strong> para habilitarlo\n            aceleración de hardware.</li>\n        <li>\n            <p>Verifica que la configuración de AVD es correcta, y selecciona <strong>Finish</strong>.</p>\n\n            <p>Para mayor detalle de los pasos de arriba, vea Administrando AVDs.</p>\n        </li>\n        <li>En el Administrador de Dispositivos Virtuales de Android (AVD), da clic en la barra de herramienta <strong>Run</strong>.\n            El emulador iniciará el arranque y mostrara el lienzo (canvas) por defecto para la versión del SO y dispositivo seleccionado.</li>\n    </ol>\n</div>"
  },
  {
    "title": "2. Configura un editor",
    "subtitle": "Introduccion",
    "content": "<div class=\"container\">\n    <h1>Configurar un Editor</h1>\n    <p>Puedes construir apps con Flutter utilizando cualquier editor de texto combinado con nuestras\n        herramientas en línea de comando. De cualquier manera, recomendamos utilizar alguno de nuestros\n        plugin para una mejor experiencia. Con nuestros plugins de edición, podrás auto completar código,\n        sintaxis resaltada, asistencia al editar widgets, apoyo para ejecutar &amp; depurar, y más.</p>\n\n    <p>Siga los siguientes pasos para agregar un complemento al editor para Android Studio, IntelliJ\n        o VS Code. Si quiere utilizar un editor diferente, está bien, simplemente salte al\n        siguiente paso: crear y ejecutar tu primer app.</p>\n\n    <ul class=\"nav nav-tabs\" id=\"editor-setup\" role=\"tablist\">\n        <li class=\"nav-item\">\n            Android Studio / IntelliJ\n        </li>\n        <li class=\"nav-item\">\n            Visual Studio Code\n        </li>\n    </ul>\n\n    <div class=\"tab-content\">\n\n        <div class=\"tab-pane active\" id=\"androidstudio\" role=\"tabpanel\" aria-labelledby=\"androidstudio-tab\">\n\n            <h3 id=\"instalar-android-studio\">Instalar Android Studio</h3>\n\n            <p>Android Studio ofrece una experiencia completa e integrada del IDE para Flutter.</p>\n\n            <ul>\n                <li>Android Studio, versión 3.0 o superior.</li>\n            </ul>\n\n            <p>Otra opción puede ser utilizar IntelliJ:</p>\n\n            <ul>\n                <li>IntelliJ IDEA Community, versión 2017.1 o superior.</li>\n                <li>IntelliJ IDEA Ultimate, versión 2017.1 o superior.</li>\n            </ul>\n\n            <h3 id=\"instalar-los-plugins-de-flutter-y-dart\">Instalar los plugins de Flutter y Dart</h3>\n\n            <p>Para instalar estos:</p>\n\n            <ol>\n                <li>Inicie Android Studio.</li>\n                <li>Abra preferencias de complementos (<strong>Preferences&gt;Plugins</strong> en macOS,\n                    <strong>File&gt;Settings&gt;Plugins</strong> en Windows &amp; Linux).</li>\n                <li>Seleccione <strong>Browse repositories…</strong>,  elige el complemento de Flutter y presione\n                    <code>install</code>.</li>\n                <li>Presione <code>Yes</code> cuando aparezca para instalar el complemento de Dart.</li>\n                <li>Presione <code>Restart</code> cuando aparezca.</li>\n            </ol>\n\n        </div>\n        <div class=\"tab-pane\" id=\"vscode\" role=\"tabpanel\" aria-labelledby=\"vscode-tab\">\n\n            <h3 id=\"instalar-vs-code\">Instalar VS Code</h3>\n\n            <p>VS Code es un editor ligero con Flutter, asistencia al ejecutar y depurar.</p>\n\n            <ul>\n                <li>VS Code, La versión estable más reciente.</li>\n            </ul>\n\n            <h3 id=\"instalar-el-complemento-de-flutter\">Instalar el complemento de Flutter</h3>\n\n            <ol>\n                <li>Inicie VS Code</li>\n                <li>Llame <strong>View&gt;Command Palette…</strong></li>\n                <li>Teclee ‘install’, y seleccione la acción <strong>‘Extensions: Install Extension’</strong></li>\n                <li>Introduzca <code>flutter</code> en el campo de búsqueda, seleccione ‘Flutter’ en la lista,\n                    y presione <strong>Install</strong></li>\n            </ol>\n\n            <h2 id=\"valida-tu-configuracin-con-flutter-doctor\">Valida tu configuración con Flutter Doctor</h2>\n\n            <ol>\n                <li>Llame a <strong>View&gt;Command Palette…</strong></li>\n                <li>Teclee ‘doctor’, y seleccione la acción <strong>‘Flutter: Run Flutter Doctor’</strong></li>\n                <li>Revise la salida en el panel ‘OUTPUT’ para cualquier inconveniente.</li>\n            </ol>\n\n        </div>\n\n    </div>\n</div>"
  },
  {
    "title": "3. Test inicial",
    "subtitle": "Introduccion",
    "content": "<div>\n    <h2 id=\"create-app\">Crea la app</h2>\n    <ol>\n        <li>Seleccionar <strong>File &gt; New Flutter Project</strong></li>\n        <li>Seleccionar <strong>Flutter application</strong> como tipo de proyecto, y presionar <strong>Next</strong>.</li>\n        <li>Asegúrate que el campo <strong>Flutter SDK Path</strong> especifica la localización\n            del SDK. Instala el SKD si no lo has hecho ya.</li>\n        <li>Introducir nombre de proyecto (ej. <code>myapp</code>), y presionar siguiente.</li>\n        <li>Clic en <strong>Finish</strong>.</li>\n        <li>Espera mientras Android Studio instala el SDK, y crear el proyecto.</li>\n    </ol>\n\n    <p>Los comandos de arriba crean un directorio para el proyecto llamado <code>myapp</code>\n        el cual contiene una app demo sencilla que utiliza Material Components.</p>\n\n    <aside class=\"alert alert-success\" role=\"alert\">\n        <p> <strong>Consejo:</strong>\n            El código de tu app está en <code>lib/main.dart</code>.\n            Para una descripción más avanzada de que hace cada bloque de código, mira los\n            comentarios al princpio de este fichero.</p>\n    </aside>\n\n    <h2 id=\"ejecutar-app\">Ejecutar app</h2>\n\n    <ol>\n        <li>Localiza la barra de herramientas principal de Android Studio:<br>\n            <img src=\"asset:assets/img/3_main-toolbar-857fe8c36d38020e27b502ec643ea8b1716edbe150cc6e39e3560f8fb7bda5b2.png\" alt=\"Main IntelliJ toolbar\" class=\"mw-100\"></li>\n        <li>En el <strong>target selector</strong>, selecciona un dispositivo android para ejecutar la app.\n            Si ninguno esta en la lista como disponible, selecciona <strong>Tools&gt; Android &gt; AVD Manager</strong> y\n            crea uno ahí mismo. Para más detalle, vea [Administrando AVDs].</li>\n        <li>Clic en el <strong>Run icon</strong> en la barra de herramientas, seleccionar <strong>Run &gt; Run</strong> del menú.</li>\n    </ol>\n\n    <p>Después de que el compilado de la app se complete, verás la app inicial en tu dispositivo.</p>\n\n    <figure class=\"site-figure \">\n        <div class=\"site-figure-container\">\n            <img src=\"asset:assets/img/3_starter-app-5e284e57b8dce587ea1dfdac7da616e6ec9dc263a409a9a8f99cf836340f47b8.png\">\n            <figcaption class=\"figure-caption\">Starter app</figcaption>\n        </div>\n    </figure>\n\n    <h2 id=\"probando-el-hot-reload\">Probando el hot reload</h2>\n\n    <p>Flutter ofrece un ciclo de desarrollo rápido con <em>hot reload</em>, la habilidad de recargar\n        el código en una app ejecutando en vivo sin reiniciar o perder el estado de la app. simplemente\n        hace un cambio a tu código fuente, diciéndole a tu IDE o herramienta de línea de comandos que\n        quieres recargar, y ver los cambio en tu simulador, emulador, o dispositivo.</p>\n\n    <ol>\n        <li>Open <code>lib/main.dart</code>.</li>\n        <li>Cambia el texto\n            <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-0\" data-original-title=\"Copy code\"></button><div id=\"code-excerpt-0\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\"><span class=\"str\">'You have </span><span class=\"strike\"><span class=\"str\">pushed</span></span><span class=\"str\"> the button this many times'</span></pre></div></div>\n            <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-1\" data-original-title=\"Copy code\"></button><div id=\"code-excerpt-1\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\"><span class=\"str\">'You have </span><span class=\"highlight\"><span class=\"str\">clicked</span></span><span class=\"str\"> the button this many times'</span></pre></div></div>\n            <aside class=\"alert alert-warning\" role=\"alert\">\n                <p> <strong>Importante:</strong>\n                    Do <em>not</em> stop your app. Let your app run.</p>\n            </aside>\n        </li>\n        <li>Guarda tus cambios: invoca <strong>Save All</strong>, o haz clic en <strong>Hot Reload</strong></li>\n    </ol>\n    <p>Verás el texto actualizado en la app en ejecución casí inmediatamante.</p>\n    <h2 id=\"ejecutar-en-modo-profile\">Ejecutar en modo Profile</h2>\n    <aside class=\"alert alert-warning\" role=\"alert\">\n        <p><strong>Importante:</strong>\n            <em>No</em> pruebes el rendimiento de tu app con el modo depuración y hot reload habilitados.</p>\n    </aside>\n    <p>La app que has ejecutado hasta ahora esta en modo depuración que permite un desarrollo más rapido (ej., hot reload) con una gran sobrecarga de rendimiento. Por tanto, puedes esperar animaciones lentas en este modo. Para ver como rinden las apps en modo release,  prueba invocar el menu <strong>Run &gt; Profile</strong> en el IDE, o\n        el siguiente comando en la terminal.</p>\n    <div class=\"language-terminal highlighter-rouge\"><div class=\"highlight\"><div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-2\" data-original-title=\"Copy code\"></button><div id=\"code-excerpt-2\"><pre class=\"highlight\"><code><span class=\"gp\">$</span> flutter run <span class=\"nt\">--profile</span>\n</code></pre></div></div></div>    </div>\n    <p>Las animaciones deben ser mucho mas suaves comparadas con el modo depuración.</p>\n</div>"
  },
  {
    "title": "4. Escribe tu primera app",
    "subtitle": "Introduccion",
    "content": "<div class=\"container\">\n    <h1>Escribe tu primera app en Flutter, parte 1</h1>\n    <p><img src=\"asset:assets/img/4_startup-namer-part-1-9db323d8383da0000c8be4e1a12e3d9ff6ab3a0eb8b86984451b329f1f3b4196.JPG\"><style>pre .highlight { background-color: #dfd; }</style></p>\n    <p>Esta es una guía para crear tu primera app en Flutter. Si estás familiarizado con la\n        programación orientada a objetos y con conceptos básicos de programación como\n        variables, bucles y condicionales podrás completar este tutorial.\n        No se necesita experiencia previa con Dart o programación móvil.</p>\n    <p>Esta guía es la parte 1 de un codelab de dos partes. Puedes encontrar la\n        parte 2\n        en Google Developers.\n        La Parte 1\n        también se puede encontrar en Google Developers.</p>\n\n    <h2 class=\"no_toc\" id=\"lo-que-haremos-en-la-parte-1\">\n        Lo que haremos en la parte 1</h2>\n\n    <p>Se implementará una app móvil sencilla que generará nombres propuestos para un\n        startup. El usuario puede seleccionar o deseleccionar nombres,\n        almacenando los mejores. El código genera nombres de forma “vaga”.\n        A medida que el usuario se desplaza por la pantalla, nuevos nombres son generados.\n        No hay límite a cuán lejos puede un usuario hacer scroll.</p>\n\n    <p>El GIF animado muestra como trabaja la app al completar la parte 1.</p>\n\n    <aside class=\"alert alert-secondary\" role=\"alert\">\n        <h4 class=\"no_toc\">\n            Lo que aprenderemos en la parte 1</h4>\n\n        <ul>\n            <li>Como escribir una apliación Flutter que se vea natural en iOS y Android</li>\n            <li>Estructura básica de una app en Flutter.</li>\n            <li>Encontrar y utilizar paquetes para extender funcionalidades.</li>\n            <li>Usar hot reload para un ciclo de desarrollo más rápido.</li>\n            <li>Cómo implementar un “stateful widget”.</li>\n            <li>Cómo crear una lista de carga “vaga” e infinita.</li>\n        </ul>\n\n        <p>En la parte 2\n            de este codelab, añadirás interactividad, modificarás el theme de la app, y\n            añadirás la habilidad de navegar a una nueva pantala (llamada una <em>ruta</em> en Flutter).</p>\n    </aside>\n\n    <aside class=\"alert alert-secondary\" role=\"alert\">\n        <h4 class=\"no_toc\">\n            Lo que vamos a usar</h4>\n\n        <p>Necesitas dos piezas de software para completar este “lab”: el\n            SDK de Flutter y un editor.\n            Este codelab presupone Android Studio, pero puedes usar el editor que\n            prefieras.</p>\n\n        <p>Puedes ejecutar este codelab usando cualquiera de los siguientes dispositivos:</p>\n\n        <ul>\n            <li>Un dispositivo físico (Android\n                o iOS) conectado a tu ordenador\n                y configurado en modo desarrollo.</li>\n            <li>El simulador de iOS.</li>\n            <li>El emulador de Android.</li>\n        </ul>\n    </aside>\n\n    <h1 id=\"paso-1-crear-la-app-inicial-de-flutter\">Paso 1: Crear la app inicial de Flutter</h1>\n\n    <p>Crear un app sencilla desde una plantilla de Flutter, utilizando las instrucciones en\n        Iniciando con tu primer app de\n            Flutter.\n        Nombre del proyecto <strong>startup_namer</strong> (en lugar de <em>myapp</em>).</p>\n\n    <aside class=\"alert alert-success\" role=\"alert\">\n        <p> <strong>Consejo:</strong>\n            Si no ves “New Flutter Project” como opción en tu IDE, asegúrate\n            que tienes instalados los plugins para Flutter y\n                Dart</p>\n    </aside>\n\n    <p>En este codelab, en su mayoría editarás <strong>lib/main.dart</strong>,\n        donde se encuentra el código Dart.</p>\n\n    <ol>\n        <li>\n            <p>Reemplaza el contenido de <code class=\"highlighter-rouge\">lib/main.dart</code>.<br>\n                Borra todo el código de <strong>lib/main.dart</strong>.\n                Reemplaza con el siguiente código, el cual muestra “Hello World” en el centro\n                de la pantalla.</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-0\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-0\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">import 'package:flutter/material.dart';\n\nvoid main() =&gt; runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Welcome to Flutter',\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Welcome to Flutter'),\n        ),\n        body: Center(\n          child: Text('Hello World'),\n        ),\n      ),\n    );\n  }\n}</pre></div></div>\n            </div>\n\n            <aside class=\"alert alert-success\" role=\"alert\">\n                <p> <strong>Consejo:</strong>\n                    Cuando copias código en tu app, la identación puede romperse.\n                    Puedes corregirla automáticamente con las herramientas de Flutter:</p>\n\n                <ul>\n                    <li>Android Studio / IntelliJ IDEA: Clic derecho sobre el código y elige\n                        <strong>Reformat Code with dartfmt</strong>.</li>\n                    <li>VS Code: Clic derecho y elige <strong>Format Document</strong>.</li>\n                    <li>Terminal: Ejecuta <code class=\"highlighter-rouge\">flutter format &lt;filename&gt;</code>.</li>\n                </ul>\n            </aside>\n        </li>\n        <li>\n            <p>Ejecuta la app de la forma que describe tu IDE.\n                Deberías ver la salida Android o iOS, dependiendo de tu dispositivo.</p>\n\n            <figure class=\"site-figure\">\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_hello-world-fadb9765c01d33f0fea92d7ac767e036ea90e9159335ea1841277bc6bef3a10a.png\">\n                    <figcaption class=\"figure-caption\">Android</figcaption>\n                </div>\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png\">\n                    <figcaption class=\"figure-caption\">iOS</figcaption>\n                </div>\n            </figure>\n\n            <aside class=\"alert alert-success\" role=\"alert\">\n                <p> <strong>Consejo:</strong>\n                    La primera vez que ejecutas en un dispositivo físico, tomará un poco la carga.\n                    Después de esto, puedes usar hot reload para actualizaciones rápidas. <strong>Save</strong> también\n                    realiza un hot reload si la app esta en ejecución.</p>\n            </aside>\n        </li>\n    </ol>\n\n    <h2 class=\"no_toc\" id=\"observaciones\">\n        Observaciones</h2>\n\n    <ul>\n        <li>Este ejemplo crea una “Material app”.\n            Material es un lenguaje de diseño visual\n            el cual es un estándar en web y móvil. Flutter ofrece un gran conjunto\n            de “Material widgets”.</li>\n        <li>El método main usa la anotación fat arrow (<code class=\"highlighter-rouge\">=&gt;</code>).\n            Usa anotación fat arrow para funciones o métodos de una sola linea.</li>\n        <li>La app hereda de <code class=\"highlighter-rouge\">StatelessWidget</code> el cual hace la app un widget en sí misma.\n            En Flutter, casi todo es un widget, incluido alineaciónes,\n            padding y layouts.</li>\n        <li>El widget <code class=\"highlighter-rouge\">Scaffold</code>, de la librería de Material,\n            provee una AppBar por defecto, “title”, y una propiedad “body” el cual\n            soporta el árbol de widget para la pantalla de inicio. El subárbol de widget\n            puede ser bastante complejo.</li>\n        <li>El trabajo principal de un widget es proporcionar un método build()\n            que describa cómo mostrar el widget en términos de otros widgets\n            de nivel inferior.</li>\n        <li>El body en este ejemplo consiste en un widget <code class=\"highlighter-rouge\">Center</code> conteniendo un\n            widget <code class=\"highlighter-rouge\">Text</code> hijo. El widget Center alinea su sub-árbol de wigets\n            en el centro de la pantalla.</li>\n    </ul>\n\n    <h1 id=\"paso-2-usar-un-paquete-externo\">Paso 2: Usar un paquete externo</h1>\n\n    <p>En este paso, empezarás utilizando un paquete de código libre llamado\n        english_words,\n        el cual contiene unos cuantos de miles de las palabras\n        en Inglés más utilizadas, además de otras funciones de utilidad.</p>\n\n    <p>Puedes encontrar el paquete <code class=\"highlighter-rouge\">english_words</code> package, así como muchos otros paquetes\n        open source, en pub.dartlang.org.</p>\n\n    <ol>\n        <li>\n            <p>El archivo pubspec gestiona los assets y dependencias para una app Flutter.\n                En <code class=\"highlighter-rouge\">pubspec.yaml</code>, agrega <code class=\"highlighter-rouge\">english_words</code> (3.1.0 o mayor)\n                a las lista de dependencias.\n                Añade la línea resaltada abajo:</p>\n\n        </li>\n        <li>\n            <p>Mientras vez el pubspec en el editor de Android Studio,\n                clic <strong>Packages get</strong>. Esto trae los paquetes dentro\n                del proyecto. Se deberá ver lo siguiente en la consola:</p>\n\n            <div class=\"language-terminal highlighter-rouge\">\n                <div class=\"highlight\"><div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-1\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-1\"><pre class=\"highlight\"><code>$ flutter pub get\nRunning \"flutter pub get\" in startup_namer...\nProcess finished with exit code 0\n</code></pre></div></div></div>    </div>\n\n            <p>Realizando <code class=\"highlighter-rouge\">Packages get</code> también auto-generas el fichero <code class=\"highlighter-rouge\">pubspec.lock</code>\n                con una lista de todos los paquetes añadidos al proyecto y\n                sus números de version.</p>\n        </li>\n        <li>\n            <p>En <code class=\"highlighter-rouge\">lib/main.dart</code>, importa el nuevo paquete:</p>\n\n            <!-- skip -->\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-2\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-2\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">import 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';</pre></div></div>\n            </div>\n\n            <p>Mientras tecleas, Android Studio da sugerencias para las bibliotecas a\n                importar. Entonces renderiza el texto de “import” en gris, haciéndote\n                saber que la librería importada no ha sido utilizada (hasta el momento).</p>\n        </li>\n        <li>\n            <p>Usa el paquete de palabras en inglés para generar texto en lugar de\n                utilizar el texto “Hello World”.</p>\n            <aside class=\"alert alert-info\" role=\"alert\">\n                <p> <strong>Nota:</strong>\n                    “Pascal case” (también conocido como “upper camel case”),\n                    significa que cada palabra en el texto, incluyendo la primera,\n                    empezará con letra mayúscula. Entonces, “uppercamelcase” se convierte\n                    “UpperCamelCase”.</p>\n            </aside>\n        </li>\n        <li>\n            <p>Si la app esta ejecutándose, haz hot reload\n                para actualizar la app. Cada vez que se presione hot reload\n                o se guarde el proyecto, deberá verse una palabra diferente,\n                elegida aleatoriamente, en la app.\n                Esto es debido a que las palabras generadas dentro del método “build”,\n                el cual se ejecuta cada vez que la MaterialApp requiere renderizar\n                o al alternar la plataforma en el inspector de Flutter .</p>\n\n            <figure class=\"site-figure\">\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step2-45e5a16e59926599e09b25b1c6d37372f77b69151cbebd070d2f94f657b1abde.png\">\n                    <figcaption class=\"figure-caption\">Android</figcaption>\n                </div>\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step2-de9da90d2a90351c8d651c50f345c822472dbcd93cd8bad099e4edf2aa499c43.png\">\n                    <figcaption class=\"figure-caption\">iOS</figcaption>\n                </div>\n            </figure>\n        </li>\n    </ol>\n\n    <h2 class=\"no_toc\" id=\"problemas\">\n        ¿Problemas?</h2>\n\n    <p>Si tu app no esta ejecutando correctamente, busca por errores al teclear. De ser necesario,\n        usa el código en el siguiente enlace y continuar.</p>\n\n    <ul>\n        <li>pubspec.yaml</li>\n        <li>lib/main.dart</li>\n    </ul>\n\n    <h1 id=\"paso-3-agregar-un-stateful-widget\">Paso 3: Agregar un Stateful widget</h1>\n\n    <p>Los widgets State<em>less</em> son inmutables, esto quiere decir que\n        sus propiedades no puedes cambiar—todos sus valores son finales.</p>\n\n    <p>Con widgets State<em>ful</em> mantienes un estado que puede cambiar\n        durante el tiempo de vida del widget. Implementar un stateful\n        widget requerirá al menos dos clases: 1) una clase StatefulWidget\n        la cual crea la instancia 2) una clase State. La clase StatefulWidget es,\n        a si misma, inmutable, pero la clase State persiste sobre el tiempo de\n        vida de el widget.</p>\n\n    <p>En este paso, agregaras un stateful widget, <code class=\"highlighter-rouge\">RandomWords</code>, el cual crea su clase\n        <code class=\"highlighter-rouge\">State</code>, <code class=\"highlighter-rouge\">RandomWordsState</code>. Entonces usarás <code class=\"highlighter-rouge\">RandomWords</code> como\n        un hijo dentro del existentea stateless widget <code class=\"highlighter-rouge\">MyApp</code>.</p>\n\n    <ol>\n        <li>\n            <p>Crea una state class mínima. Añade lo siguiente al final\n                de <code class=\"highlighter-rouge\">main.dart</code>:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (RandomWordsState)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-3\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-3\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWordsState extends State&lt;RandomWords&gt; {\n  // TODO Add build() method\n}</pre></div></div>\n            </div>\n\n            <p>Nota la declaración <code class=\"highlighter-rouge\">State&lt;RandomWords&gt;</code>. Esto indica que estamos\n                usando una clase\n                State\n                genérica especializada para usar <code class=\"highlighter-rouge\">RandomWords</code>. La mayoría de la lógica y el estado\n                de la app residen aquí—esto mantiene el estado para el widget <code class=\"highlighter-rouge\">RandomWords</code>.\n                Esta clase guarda el par de palabras generados, que crecen infinitamente cuando el\n                usuario hace scrolls, y los pares de palabras favoritos (en la\n                parte 2),\n                que el usuario añado o elimina de la lista alternando con el icon del corazón.</p>\n\n            <p><code class=\"highlighter-rouge\">RandomWordsState</code> depende de la clase <code class=\"highlighter-rouge\">RandomWords</code>. La añadirás a continuación.</p>\n        </li>\n        <li>\n            <p>Añade el widget stateful <code class=\"highlighter-rouge\">RandomWords</code> a <code class=\"highlighter-rouge\">main.dart</code>.\n                El widget <code class=\"highlighter-rouge\">RandomWords</code> hace poco más aparte de crear su clase State:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (RandomWords)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-4\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-4\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWords extends StatefulWidget {\n  @override\n  RandomWordsState createState() =&gt; new RandomWordsState();\n}</pre></div></div>\n            </div>\n\n            <p>Después de agregar esta clase de estado, el IDE se quejara que\n                a la clase le hace falta el método build. Siguiente, agregar un método\n                build básico que genera el juego de palabras moviendo la\n                generación de código de <code class=\"highlighter-rouge\">MyApp</code> a <code class=\"highlighter-rouge\">RandomWordsState</code>.</p>\n        </li>\n        <li>\n            <p>Añade el método <code class=\"highlighter-rouge\">build()</code> a <code class=\"highlighter-rouge\">RandomWordsState</code>:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (RandomWordsState)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-5\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-5\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWordsState extends State&lt;RandomWords&gt; {\n  @override\n  Widget build(BuildContext context) {\n    final wordPair = WordPair.random();\n    return Text(wordPair.asPascalCase);\n  }\n}</pre></div></div>\n            </div>\n        </li>\n        <li>\n            <p>Elimina el código de generación de palabras de <code class=\"highlighter-rouge\">MyApp</code> haciendo los cambios que se muestran en el siguiente diff:</p>\n        </li>\n        <li>\n            <p>Reinicia la app.\n                La app debería comportarse como antes, mostrando una palabra\n                emparejada cada vez que haces hot reload o guardas la app.</p>\n        </li>\n    </ol>\n\n    <aside class=\"alert alert-success\" role=\"alert\">\n        <p> <strong>Consejo:</strong>\n            Si ves la siguiente advertencia en el hot reload, considera reiniciar la app:\n            **Reloading…<br></p>\n\n        <p>Some program elements were changed during reload but did not run when\n            the view was reassembled; you may need to restart the app (by pressing “R”)\n            for the changes to have an effect.**</p>\n\n        <p>Podría ser un falso positivo, pero considere reiniciar en orden de asegurar estos\n            cambios sean reflejados en la UI de la app.</p>\n\n    </aside>\n\n    <h2 class=\"no_toc\" id=\"problemas-1\">\n        ¿Problemas?</h2>\n\n    <p>Si tu app no esta corriendo correctamente, puedes utilizar este código\n        del siguiente enlace y continuar.</p>\n\n    <ul>\n        <li>lib/main.dart</li>\n    </ul>\n\n    <h1 id=\"paso-4-crear-un-listview-de-scroll-infinito\">Paso 4: Crear un ListView de scroll infinito</h1>\n\n    <p>En este paso, extenderemos la clase <code class=\"highlighter-rouge\">RandomWordsState</code> para generar\n        y desplegar una lista de palabras. Mientras el usuario se desplaza, la lista\n        lo desplegara en un widget <code class=\"highlighter-rouge\">ListView</code>, que crecerá infinitamente. El <code class=\"highlighter-rouge\">builder</code> factory\n        constructor del  <code class=\"highlighter-rouge\">ListView</code> permite construir una lista de carga\n        retrasada, a petición.</p>\n\n    <ol>\n        <li>\n            <p>Añade una lista <code class=\"highlighter-rouge\">_suggestions</code> a la clase <code class=\"highlighter-rouge\">RandomWordsState</code>\n                para guardar pares de palabras sugeridas.\n                También, agrega una variable <code class=\"highlighter-rouge\">_biggerFont</code> para hacer el tamaño de la fuente más grande.</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-6\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-6\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWordsState extends State&lt;RandomWords&gt; {\n  final _suggestions = &lt;WordPair&gt;[];\n  final _biggerFont = const TextStyle(fontSize: 18.0);\n  // ···\n}</pre></div></div>\n            </div>\n\n            <aside class=\"alert alert-info\" role=\"alert\">\n                <p> <strong>Nota:</strong>\n                    Prefijar un identificador con guion bajo lo fuerza a ser\n                        privado\n                    in the Dart language.</p>\n            </aside>\n\n            <p>A continuación añade una función <code class=\"highlighter-rouge\">_buildSuggestions()</code> a la clase <code class=\"highlighter-rouge\">RandomwordsState</code>.\n                Este método construirá el <code class=\"highlighter-rouge\">ListView</code> que muestra las\n                palabras sugeridas.</p>\n\n            <p>La clase <code class=\"highlighter-rouge\">ListView</code> provee una propiedad builder, <code class=\"highlighter-rouge\">itemBuilder</code>,\n                un factory builder y un función callback especificada como función anónima,\n                dos parámetros se pasan a la función—el <code class=\"highlighter-rouge\">BuildContext</code>,\n                y un fila de iteración , <code class=\"highlighter-rouge\">i</code>. El iterador empieza desde 0 e incrementa\n                cada vez que la función es llamada. Este incrementa dos veces por cada pareja de palabras sugeridas:\n                una para el ListTile, y una para el Divider. Este modelo permie a la lista de sugerencias crecer infinitamente cuando el usuario hace scroll.</p>\n        </li>\n        <li>\n            <p>Añade una función <code class=\"highlighter-rouge\">_buildSuggestions()</code>, mostrada\n                abajo, a la clase <code class=\"highlighter-rouge\">RandomWordsState</code> (borra los comentarios, si lo prefieres).</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (_buildSuggestions)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-7\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-7\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">Widget _buildSuggestions() {\n  return ListView.builder(\n      padding: const EdgeInsets.all(16.0),\n      itemBuilder: /*1*/ (context, i) {\n        if (i.isOdd) return Divider(); /*2*/\n\n        final index = i ~/ 2; /*3*/\n        if (index &gt;= _suggestions.length) {\n          _suggestions.addAll(generateWordPairs().take(10)); /*4*/\n        }\n        return _buildRow(_suggestions[index]);\n      });\n}</pre></div></div>\n            </div>\n\n            <ol class=\"numbered-code-notes\">\n                <li>El callback <code class=\"highlighter-rouge\">itemBuilder</code> es llamado una vez por cada par de palabras sugeridas,\n                    y coloca cada sugerencia en una fila <code class=\"highlighter-rouge\">ListTile</code>. Por cada fila, la\n                    función añade una fila <code class=\"highlighter-rouge\">ListTile</code> para las parejas de\n                    palabras. Para las filas impares, la\n                    función añade un widget <code class=\"highlighter-rouge\">Divider</code> para separar visualmente\n                    las entradas. Nota\n                    que este divisor puede ver ser dificil de ver en los\n                    dispositivos más pequeños.</li>\n                <li>Añade un widget divisor de un pixel de altura antes de\n                    cada fila en el <code class=\"highlighter-rouge\">ListView</code>.</li>\n                <li>La expresión <code class=\"highlighter-rouge\">i ~/ 2</code> divide <code class=\"highlighter-rouge\">i</code> entre 2 y devuelve un\n                    resultado entero.\n                    Por ejemplo: 1, 2, 3, 4, 5 dan como resultado 0, 1, 1, 2, 2. Esto calcula el actual numero de palbras emparejadas en el <code class=\"highlighter-rouge\">ListView</code>, menos los widgests\n                    divisores.</li>\n                <li>Si has alcanzado el final de los pares de palabras dispobibles, entonces genera\n                    10 más y añade estos a la lista de sugerencias.</li>\n            </ol>\n\n            <p>La función <code class=\"highlighter-rouge\">_buildSuggestions()</code> llama a <code class=\"highlighter-rouge\">_buildRow()</code> una vez por\n                cada pareja de palabras. Esta función muestra cada pareja en un <code class=\"highlighter-rouge\">ListTile</code>,\n                que te permite hacer las filas más atractivas en el siguiente paso.</p>\n        </li>\n        <li>\n            <p>Añade una función <code class=\"highlighter-rouge\">_buildRow()</code> a <code class=\"highlighter-rouge\">RandomWordsState</code>:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (_buildRow)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-8\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-8\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">Widget _buildRow(WordPair pair) {\n  return ListTile(\n    title: Text(\n      pair.asPascalCase,\n      style: _biggerFont,\n    ),\n  );\n}</pre></div></div>\n            </div>\n        </li>\n        <li>\n            <p>En la clase <code class=\"highlighter-rouge\">RandomWordsState</code>, actualiza el método <code class=\"highlighter-rouge\">build</code>\n                para usar <code class=\"highlighter-rouge\">_buildSuggestions()</code>, mejor que llamar directamente a la\n                biblioteca de generación de palabras.\n                (Scaffold\n                implementa el layout visual básico de Material Design.)</p>\n\n            <p>Reemplaza el cuerpo del método con el código marcado:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (build)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-9\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-9\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('Startup Name Generator'),\n    ),\n    body: _buildSuggestions(),\n  );\n}</pre></div></div>\n            </div>\n        </li>\n        <li>\n            <p>Actualiza el método <code class=\"highlighter-rouge\">build</code> de <code class=\"highlighter-rouge\">MyApp</code>, cambiando el title,\n                y cambiando home para ser el widget <code class=\"highlighter-rouge\">RandomWords</code>.</p>\n            <p>Reemplaza el método original con el método <code class=\"highlighter-rouge\">build</code> remarcado abajo:</p>\n        </li>\n        <li>\n            <p>Reinicia la app. Deberías ver una lista de palabras emparejadas no importa lo lejos\n                que hagas scroll.</p>\n\n            <figure class=\"site-figure\">\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step4-infinite-list-69f7c62bf16f67eaade07551db4b18b065d6c7a81e042a10cd34d31ecb7f2514.png\">\n                    <figcaption class=\"figure-caption\">Android</figcaption>\n                </div>\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step4-infinite-list-70ea9d8fd7191fb3726f1743bb03499815f93df4f42b687cfd7916052c35eb07.png\">\n                    <figcaption class=\"figure-caption\">iOS</figcaption>\n                </div>\n            </figure>\n        </li>\n    </ol>\n\n    <h2>¿Problemas?</h2>\n    <p>Si tu app no esta funcionando correctamente, puedes ver el código\n        en el siguiente enlace y continuar.</p>\n    <ul>\n        <li>lib/main.dart</li>\n    </ul>\n\n    <h1 class=\"no_toc\" id=\"siguientes-pasos\">Siguientes pasos</h1>\n\n    <figure class=\"site-figure site-image-right\">\n        <div class=\"site-figure-container\">\n            <img src=\"asset:assets/img/4_startup-namer-b85740ef920a57e28524f84e9c06cfb380128d10780e91eaf2c7613a56f3f511.gif\">\n            <figcaption class=\"figure-caption\">The app from part 2</figcaption>\n        </div>\n    </figure>\n\n    <p>Enhorabuena!</p>\n\n    <p>Has escrito una app interactiva en Flutter que se ejecuta en ambos iOS y Android\n        En este laboratorio, tu has:</p>\n\n    <ul>\n        <li>Creado una app de Flutter desde cero.</li>\n        <li>Escrito código Dart.</li>\n        <li>Utilizado una libreía externa de terceros.</li>\n        <li>Usado hot reload para un ciclo de desarrollo más rápido.</li>\n        <li>Impementado un widget stateful.</li>\n        <li>Creado una lista de scroll infinito, de carga retrasada.</li>\n    </ul>\n\n    <p>Si deseas extender esta app, procede con la\n        parte 2\n        en el sitio\n        Google Developers Codelabs,\n        donde añadiras la siguiente funcionalidad:</p>\n    <ul>\n        <li>Implementar interactividad añadiendo un icono corazón pulsable para guardar\n            tus parejas de palabras favoritas.</li>\n        <li>Implementar navegación a una nueva ruta añadiendo una nueva pantalla\n            conteniendo los favoritos guardados.</li>\n        <li>Modificar el color del tema, fabricando una app todo-blanco.</li>\n    </ul>\n</div>"
  },
  {
    "title": "6 Introducción a los Widgets",
    "subtitle": "Interfaz de Usuario",
    "content": "<h1>Introducción a los Widgets</h1>\n  Contenidos\n    <ul>\n      <li>Hola Mundo</li>\n      <li>Widgets básicos</li>\n      <li>Utilizando Material Components</li>\n      <li>Manejar gestos</li>\n      <li>Cambiar los widgets en respuesta a las entradas</li>\n      <li>Juntando todo</li>\n      <li>Responder a los eventos del ciclo de vida de los widgets</li>\n      <li>Keys</li>\n      <li>Global Keys</li>\n    </ul>\n  \n  <p>Los widgets de Flutter son construidos usando un moderno framework que toma\n    inspiración de React. La idea central es\n    que construyas tu UI de widgets. Los Widgets describen cómo debería ser su vista,\n    dada su configuración y estado actuales. Cuando el estado de un widget cambia,\n    el widget reconstruye su descripción, que el framework difiere de la descripción\n    anterior para determinar los cambios mínimos necesarios en el árbol de renderizado\n    subyacente para la transición de un estado al siguiente.</p>\n\n  <p> <strong>Nota:</strong>\n      Si quieres conocer mejor a Flutter sumergiéndote en algo de código,\n      echa un vistazo a Codelab Layout\n        Básico, Construyendo Layouts en\n        Flutter, y Añadir Interactividad\n        a tu App Flutter.</p>\n  \n\n  <h2>\n    Hola Mundo</h2>\n\n  <p>La aplicación mínima de Flutter simplemente llama a la función runApp() con un widget</p>\n\n    <pre><code>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    Center(\n      child: Text(\n        'Hello, world!',\n        textDirection: TextDirection.ltr,\n      ),\n    ),\n  );\n}\n</code></pre>\n\n  <p>La función runApp() toma el\n    Widget dado y lo convierte en la raíz del\n    árbol de widgets. En este ejemplo, el árbol de widgets consiste de dos widgets, el widget\n    Center y su hijo, el widget\n    Text.El framework obliga al widget raíz a\n    cubrir la pantalla, lo que significa que el texto “Hello, world!” termina centrado\n    en la pantalla. La dirección del texto debe especificarse en esta instancia; cuando se\n    usa el widget MaterialApp, este lo hace por ti, como se demuestra más\n    adelante.</p>\n\n  <p>Al escribir una aplicación, comúnmente creará nuevos widgets que son subclases de,\n    ya sea StatelessWidget o\n    StatefulWidget, dependiendo de\n    si su widget gestiona algún estado. El trabajo principal de un widget es implementar una\n    función de construcción build, que describe\n    el widget en términos de otros widgets de nivel inferior. El framework construye estos\n    widgets en orden, hasta que el proceso toca fondo en widgets que representan\n    el RenderObject subyacente, el cual\n    calcula y describe la geometría del widget.</p>\n\n  <h2>\n    Widgets básicos</h2>\n\n  <p>Flutter viene con un conjunto de potentes widgets básicos, de los cuales los siguientes\n    son de uso muy común:</p>\n\n  <ul>\n    <li>\n      <p>Text: El widget\n        Text te permite crear una cadena de texto\n        con estilo, dentro de tu aplicación.</p>\n    </li>\n    <li>\n      <p>Row,\n        Column: Estos widgets flexibles te\n        permiten crear layouts flexibles tanto en la dirección horizontal\n        (Row) como en la vertical\n        (Column). Su diseño se basa\n        en el modelo de layout flexbox de la web.</p>\n    </li>\n    <li>\n      <p>Stack: En lugar de estar orientados linealmente\n        (ya sea horizontal o verticalmente), un widget\n        Stack te permite apilar los widgets uno\n        encima del otro en el orden como se pintan. Puedes utilizar el widget\n        Positioned en los hijos de un\n        Stack para posicionarlos en relación con\n        el borde superior, derecho, inferior o izquierdo del stack. Los Stacks se basan en\n        el modelo de layout de posicionamiento absoluto en la web.</p>\n    </li>\n    <li>\n      <p>Container: El widget\n        Container te permite crear\n        un elemento visuales rectangular. Un contenedor puede ser decorado con un\n        BoxDecoration, como un fondo,\n        un borde o una sombra. Un\n        Container también puede tener márgenes,\n        relleno interno y restricciones aplicadas a su tamaño. Además, un\n        Container puede transformarse\n        en un espacio tridimensional utilizando una matriz.</p>\n    </li>\n  </ul>\n\n  <p>A continuación, se presentan algunos widgets simples que combinan estos y otros widgets:</p>\n\n    <pre><code>import 'package:flutter/material.dart';\n\nclass MyAppBar extends StatelessWidget {\n  MyAppBar({this.title});\n\n  // Los campos en una subclase de Widgets siempre están marcados como \"final\".\n\n  final Widget title;\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      height: 56.0, // en píxeles lógicos\n      padding: const EdgeInsets.symmetric(horizontal: 8.0),\n      decoration: BoxDecoration(color: Colors.blue[500]),\n      // Row es un diseño horizontal y lineal.\n      child: Row(\n        // &lt;Widget&gt; es el tipo de artículos en la lista.\n        children: &lt;Widget&gt;[\n          IconButton(\n            icon: Icon(Icons.menu),\n            tooltip: 'Navigation menu',\n            onPressed: null, // null desactiva el botón\n          ),\n          // Expanded expande a su hijo para rellenar el espacio disponible.\n          Expanded(\n            child: title,\n          ),\n          IconButton(\n            icon: Icon(Icons.search),\n            tooltip: 'Search',\n            onPressed: null,\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nclass MyScaffold extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Material es una hoja de papel conceptual en la que aparece la UI.\n    return Material(\n      // Column es un diseño vertical y lineal.\n      child: Column(\n        children: &lt;Widget&gt;[\n          MyAppBar(\n            title: Text(\n              'Example title',\n              style: Theme.of(context).primaryTextTheme.title,\n            ),\n          ),\n          Expanded(\n            child: Center(\n              child: Text('Hello, world!'),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'My app', // utilizado por el conmutador de tareas del sistema operativo\n    home: MyScaffold(),\n  ));\n}\n</code></pre>\n\n  <p>Asegúrate de tener una línea <code>uses-material-design: true</code> en la sección <code>flutter</code>\n    de tu archivo <code>pubspec.yaml</code>. Permite utilizar el conjunto predefinido de\n    Iconos de Material Design.</p>\n\n    <pre><code>name: my_app\nflutter:\n  uses-material-design: true\n</code></pre>\n\n  <p>Muchos widgets Material Desgin necesitan estar dentro de un\n    MaterialApp parar mostrarse correctamente, con\n    el fin de heredar los datos del Theme. Por lo tanto, ejecutamos la aplicación con un\n    MaterialApp.</p>\n\n  <p>El widget <code>MyAppBar</code> crea un\n    Container con una altura de 56\n    píxeles independientes del dispositivo con un padding de 8 píxeles, tanto a la izquierda\n    como a la derecha. Dentro del contenedor, <code>MyAppBar</code> usa un layout\n    Row para organizar sus hijos. El hijo\n    del medio, el widget <code>title</code>, se marca como\n    Expanded, lo que significa\n    que se expande para rellenar cualquier espacio disponible\n    que no haya sido consumido por los otros widgets hijos. Puedes tener múltiples\n    Expanded hijos y determinar la\n    proporción en la que consumen el espacio disponible utilizando el argumento\n    flex para\n    Expanded.</p>\n\n  <p>El widget <code>MyScaffold</code> organiza a sus hijos en una columna vertical. En la\n    parte superior de la columna se coloca una instancia de <code>MyAppBar</code>, pasándole un\n    widget Text para usarlo como su título. Pasar\n    widgets como argumentos de widgets es una técnica muy poderosa que te\n    permite crear widgets genéricos que pueden ser reutilizados en\n    una amplia variedad de formas. Finalmente, <code>MyScaffold</code>\n    utiliza un Expanded\n    para rellenar el espacio restante con su cuerpo,\n    que consiste en un mensaje centrado.</p>\n\n  <p>Para más información, mira Layouts</p>\n\n  <h2>\n    Utilizando Material Components</h2>\n\n  <p>Flutter proporciona una serie de widgets que te ayudan a crear aplicaciones que\n    siguen el Material Design. Una aplicación Material comienza con el widget\n    MaterialApp\n    que construye una serie de widgets en la raíz de tu aplicación, incluyendo un\n    Navigator, que gestiona una pila de\n    widgets identificados por strings, también conocidas como “routes”. El\n    Navigator te permite una transición\n    sin problemas entre pantallas de su aplicación. Utilizar el widget\n    MaterialApp\n    es totalmente opcional, pero es una buena práctica.</p>\n\n    <pre><code>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Flutter Tutorial',\n    home: TutorialHome(),\n  ));\n}\n\nclass TutorialHome extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // Scaffold es un layout para la mayoría de los Material Components.\n    return Scaffold(\n      appBar: AppBar(\n        leading: IconButton(\n          icon: Icon(Icons.menu),\n          tooltip: 'Navigation menu',\n          onPressed: null,\n        ),\n        title: Text('Título de ejemplo'),\n        actions: &lt;Widget&gt;[\n          IconButton(\n            icon: Icon(Icons.search),\n            tooltip: 'Search',\n            onPressed: null,\n          ),\n        ],\n      ),\n      // el body es la mayor parte de la pantalla.\n      body: Center(\n        child: Text('Hello, world!'),\n      ),\n      floatingActionButton: FloatingActionButton(\n        tooltip: 'Add', // utilizado por las tecnologías de accesibilidad para discapacitados\n        child: Icon(Icons.add),\n        onPressed: null,\n      ),\n    );\n  }\n}\n</code></pre>\n\n  <p>Ahora que el código ha cambiado de <code>MyAppBar</code> y <code>MyScaffold</code> a los widgets\n    AppBar y\n    Scaffold,\n    de <code>material.dart</code>,\n    la aplicación se está empezando a ver un poco más Material.\n    Por ejemplo, la barra de aplicaciones tiene una sombra y el texto hereda automáticamente\n    el estilo correcto. También se añade acción flotante.</p>\n\n  <p>Note que estamos pasando de nuevo los widgets como argumentos a otros widgets. El widget\n    Scaffold toma un número de widgets diferentes\n    como argumentos con nombre, cada uno de los cuales se coloca en el layout\n    del Scaffold en el lugar apropiado. Del mismo modo, el widget\n    AppBar nos permite pasarle widgets\n    para el leading y los\n    actions de su widget\n    title. Este patrón se repite a\n    lo largo de todo el framework y es algo que podría considerar al diseñar\n    sus propios widgets.</p>\n\n  <p>Para más información, mira Componentes Material.</p>\n\n\n  <p> <strong>Nota:</strong>\n      Material es uno de los dos paquetes de diseño incluidos con Flutter. Para un<br>\n      diseño más centrado en iOS, mira el paquete Componentes Cupertino\n      los cuales tienen su propio set de CupertinoApp, y\n      CupertinoNavigationBar etc.</p>\n  \n\n  <h2>\n    Manejar gestos</h2>\n\n  <p>La mayoría de las aplicaciones incluyen alguna forma de interacción del usuario\n    con el sistema. El primer paso para construir una aplicación interactiva es detectar\n    gestos de entrada. Veamos cómo funciona creando un simple botón:</p>\n\n    <pre><code>class MyButton extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: () {\n        print('MyButton was tapped!');\n      },\n      child: Container(\n        height: 36.0,\n        padding: const EdgeInsets.all(8.0),\n        margin: const EdgeInsets.symmetric(horizontal: 8.0),\n        decoration: BoxDecoration(\n          borderRadius: BorderRadius.circular(5.0),\n          color: Colors.lightGreen[500],\n        ),\n        child: Center(\n          child: Text('Engage'),\n        ),\n      ),\n    );\n  }\n}\n</code></pre>\n\n  <p>El widget GestureDetector\n    no tiene una representación visual, sino que detecta los gestos realizados por el usuario.\n    Cuando el usuario pulsa en\n    Container, el\n    GestureDetector llama a su callback\n    onTap\n    en este caso imprimiendo un mensaje en la consola. Puede utilizar\n    GestureDetector para detectar\n    una variedad de gestos de entrada, incluidos taps, drags y scales.</p>\n\n  <p>Muchos widgets usan un\n    GestureDetector para proporcionar\n    callbacks opcionales para otros widgets. Por ejemplo, los widgets\n    IconButton,\n    RaisedButton, y\n    FloatingActionButton\n    tienen onPressed()\n    callbacks que se activan cuando el usuario toca el widget.</p>\n\n  <p>Para más información, mira: Gestos en Flutter</p>\n\n  <h2>\n    Cambiar los widgets en respuesta a las entradas</h2>\n\n  <p>Hasta ahora, esta página solo ha usado widgets stateless. Los widgets sin estado\n    reciben argumentos de su widget padre, que son almacenados en propiedades\n    final.\n    Cuando en un widget es invocado el método\n    build, usa los valores almacenados\n    por aquél (el widget) para derivar nuevos argumentos para los widgets que crea.</p>\n\n  <p>Con el fin de crear experiencias más complejas, por ejemplo, para reaccionar de formas\n    más interesantes a las entradas del usuario, las aplicaciones generalmente almacenan un estado.\n    Flutter utiliza StatefulWidgets para capturar esta idea. StatefulWidgets son\n    widgets especiales que saben cómo generar objetos State, que luego se usan\n    para mantener el estado. Considera este ejemplo básico, usando el\n    RaisedButton mencionado anteriormente:</p>\n\n    <pre><code>class Counter extends StatefulWidget {\n  // Esta clase es la configuración para el estado. Guarda\n  // los valores (en este caso nada) proporcionados por el padre y usados por el método\n  // build del State. Los campos en una subclase Widget siempre se marcan como \"final\".\n\n  @override\n  _CounterState createState() =&gt; _CounterState();\n}\n\nclass _CounterState extends State&lt;Counter&gt; {\n  int _counter = 0;\n\n  void _increment() {\n    setState(() {\n      // Esta llamada a setState le dice al framework Flutter que\n      // algo ha cambiado en este State, lo que hace que se vuelva a ejecutar\n      // el método build a continuación para que la pantalla pueda reflejar los\n      // valores actualizados. Si cambias _counter sin llamar\n      // setState(), entonces el método build no será llamado de nuevo,\n      // así que aparentará no haber ocurrido nada.\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    // Este método se vuelve a ejecutar cada vez que se llama setState, por ejemplo\n    // como se hace con el método _increment anterior.\n    // El framework Flutter ha sido optimizado para hacer que los métodos build\n    // se vuelvan a ejecutar rápidamente, para que puedas reconstruir cualquier cosa que\n    // necesite ser actualizada en lugar de tener que cambiar individualmente\n    // las instancias de los widgets.\n    return Row(\n      children: &lt;Widget&gt;[\n        RaisedButton(\n          onPressed: _increment,\n          child: Text('Increment'),\n        ),\n        Text('Count: $_counter'),\n      ],\n    );\n  }\n}\n</code></pre>\n\n  <p>Puede que se pregunte por qué StatefulWidget y State son objetos separados. En\n    Flutter, estos dos tipos de objetos tienen diferentes ciclos de vida. Los Widgets son\n    objetos temporales, usados para construir una presentación de la aplicación en su\n    estado actual. Por otro lado, los objetos de estado son persistentes entre llamadas a\n    build(),\n    permitiéndoles recordar información.</p>\n\n  <p>El ejemplo anterior acepta la entrada del usuario y utiliza directamente el resultado\n    en su método build.  En aplicaciones más complejas, diferentes partes de la jerarquía\n    de widgets podrían ser responsables de diferentes aspectos; por ejemplo, un\n    widget puede presentar una interfaz de usuario compleja con el objetivo de recopilar\n    información específica, como una fecha o lugar, mientras que otro widget podría\n    usar esa información para cambiar la presentación general.</p>\n\n  <p>En Flutter, los cambios se notifican “hacia arriba” por la jerarquía de widgets\n    mediante el uso de callbacks, mientras que el estado actual fluye “hacia abajo” a los\n    stateless widgets que hacen la presentación. El padre común que redirige este flujo es\n    el State. Veamos cómo funciona en la práctica, con este ejemplo un poco más complejo:</p>\n\n    <pre><code>class CounterDisplay extends StatelessWidget {\n  CounterDisplay({this.count});\n\n  final int count;\n\n  @override\n  Widget build(BuildContext context) {\n    return Text('Count: $count');\n  }\n}\n\nclass CounterIncrementor extends StatelessWidget {\n  CounterIncrementor({this.onPressed});\n\n  final VoidCallback onPressed;\n\n  @override\n  Widget build(BuildContext context) {\n    return RaisedButton(\n      onPressed: onPressed,\n      child: Text('Increment'),\n    );\n  }\n}\n\nclass Counter extends StatefulWidget {\n  @override\n  _CounterState createState() =&gt; _CounterState();\n}\n\nclass _CounterState extends State&lt;Counter&gt; {\n  int _counter = 0;\n\n  void _increment() {\n    setState(() {\n      ++_counter;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Row(children: &lt;Widget&gt;[\n      CounterIncrementor(onPressed: _increment),\n      CounterDisplay(count: _counter),\n    ]);\n  }\n}\n</code></pre>\n\n  <p>Nótese la creación de dos nuevos stateless widgets, separando limpiamente\n    las responsabilidades de <em>mostrar</em> el contador (CounterDisplay) y <em>cambiar</em>\n    el contador (CounterIncrementor).\n    Aunque el resultado neto es el mismo que el ejemplo anterior, la separación de\n    responsabilidades permite encapsular una mayor complejidad en los widgets individuales\n    manteniendo al mismo tiempo la simplicidad en el padre.</p>\n\n  <p>Para más información, mira:</p>\n\n  <ul>\n    <li>StatefulWidget</li>\n    <li>State.setState</li>\n  </ul>\n\n  <h2>\n    Juntando todo</h2>\n\n  <p>Consideremos un ejemplo más completo que reúne los conceptos\n    introducidos anteriormente. Trabajaremos con una hipotética aplicación de compras,\n    que muestra varios productos puestos a la venta y mantiene un carrito de compras para\n    las compras previstas. Comencemos por definir nuestra clase de presentación,\n    <code>ShoppingListItem</code>:</p>\n\n    <pre><code>class Product {\n  const Product({this.name});\n  final String name;\n}\n\ntypedef void CartChangedCallback(Product product, bool inCart);\n\nclass ShoppingListItem extends StatelessWidget {\n  ShoppingListItem({Product product, this.inCart, this.onCartChanged})\n      : product = product,\n        super(key: ObjectKey(product));\n\n  final Product product;\n  final bool inCart;\n  final CartChangedCallback onCartChanged;\n\n  Color _getColor(BuildContext context) {\n    // El tema depende del BuildContext porque diferentes partes del árbol\n    // pueden tener diferentes temas.  El BuildContext indica dónde se está llevando a cabo la\n    // llamada al método build y por lo tanto qué tema usar.\n\n    return inCart ? Colors.black54 : Theme.of(context).primaryColor;\n  }\n\n  TextStyle _getTextStyle(BuildContext context) {\n    if (!inCart) return null;\n\n    return TextStyle(\n      color: Colors.black54,\n      decoration: TextDecoration.lineThrough,\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return ListTile(\n      onTap: () {\n        onCartChanged(product, !inCart);\n      },\n      leading: CircleAvatar(\n        backgroundColor: _getColor(context),\n        child: Text(product.name[0]),\n      ),\n      title: Text(product.name, style: _getTextStyle(context)),\n    );\n  }\n}\n</code></pre>\n\n  <p>El widget <code>ShoppingListItem</code> sigue un patrón común para los widgets stateless.\n    Almacena los valores que recibe en su constructor en propiedades\n    final,\n    que luego utiliza durante la ejecución del método\n    build.\n    Por ejemplo, el booleano <code>inCart</code> para alternar entre dos apariencias visuales:\n    uno que usa el color primario del tema actual y otro que usa gris.</p>\n\n  <p>Cuando el usuario toca el elemento de la lista, el widget no modifica su valor <code>inCart</code>\n    directamente. En lugar de eso, el widget llama a la función <code>onCartChanged</code>\n    recibido de su widget padre. Este patrón le permite almacenar el estado más arriba\n    en la jerarquía de widgets, lo que hace que el estado persista por períodos más largos de\n    tiempo. En el caso extremo, el estado almacenado en el widget pasado a\n    runApp() persiste\n    durante toda la vida útil de la aplicación.</p>\n\n  <p>Cuando el padre recibe el callback <code>onCartChanged</code>, el padre actualiza\n    su estado interno, lo cual desencadena la re-llamada al método build y crea una nueva\n    instancia de <code>ShoppingListItem</code> con el nuevo valor <code>inCart</code>. Aunque el padre\n    crea una nueva instancia de <code>ShoppingListItem</code> cuando se reconstruye, esa operación no es\n    costosa porque el framework compara los widgets recién construídos con los widgets\n    construídos previamente y aplica solo las diferencias al\n    RenderObject subyacente.</p>\n\n  <p>Veamos un ejemplo de un widget padre que almacena un estado mutable:</p>\n    <pre><code>class ShoppingList extends StatefulWidget {\n  ShoppingList({Key key, this.products}) : super(key: key);\n\n  final List&lt;Product&gt; products;\n\n  // El framework llama createState la primera vez que un widget aparece en una ubicación\n  // dada del árbol. Si el padre vuelve a ejecutar build y usa el mismo tipo de \n  // widget (con la misma llave),\n  // el framework reutiliza el objeto State en lugar de crear un nuevo objeto State.\n\n  @override\n  _ShoppingListState createState() =&gt; _ShoppingListState();\n}\n\nclass _ShoppingListState extends State&lt;ShoppingList&gt; {\n  Set&lt;Product&gt; _shoppingCart = Set&lt;Product&gt;();\n\n  void _handleCartChanged(Product product, bool inCart) {\n    setState(() {\n      // Cuando un usuario cambia lo que hay en el carrito, necesitas cambiar \n      //_shoppingCart dentro de una llamada setState para activar un rebuild.\n      // El framework entonces llama a build, abajo, \n      // que actualiza la apariencia visual de la aplicación.\n\n      if (inCart)\n        _shoppingCart.add(product);\n      else\n        _shoppingCart.remove(product);\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Shopping List'),\n      ),\n      body: ListView(\n        padding: EdgeInsets.symmetric(vertical: 8.0),\n        children: widget.products.map((Product product) {\n          return ShoppingListItem(\n            product: product,\n            inCart: _shoppingCart.contains(product),\n            onCartChanged: _handleCartChanged,\n          );\n        }).toList(),\n      ),\n    );\n  }\n}\n\nvoid main() {\n  runApp(MaterialApp(\n    title: 'Shopping App',\n    home: ShoppingList(\n      products: &lt;Product&gt;[\n        Product(name: 'Eggs'),\n        Product(name: 'Flour'),\n        Product(name: 'Chocolate chips'),\n      ],\n    ),\n  ));\n}\n</code></pre>\n\n  <p>La clase <code>ShoppingList</code> extiende de\n    StatefulWidget,\n    lo que significa que este widget almacena estado mutable. Cuando el widget <code>ShoppingList</code>\n    se inserta por primera vez en el árbol, el framework llama a la función\n    createState()\n    para crear una nueva instancia de <code>_ShoppingListState</code> para asociar\n    con esa ubicación en el árbol. (Note que típicamente nombramos subclases de\n    State con\n    guiones bajos para indicar que son detalles privados de implementación.)\n    Cuando el padre de este widget hace un rebuild, el padre crea una nueva instancia de\n    <code>ShoppingList</code>, pero el framework reutiliza la instancia <code>_ShoppingListState</code>\n    que ya está en el árbol en lugar de llamar a\n    createState de nuevo.</p>\n\n  <p>Para acceder a las propiedades del <code>ShoppingList</code> actual, el <code>_ShoppingListState</code> puede\n    usar su propiedad widget. Si el padre\n    reconstruye y crea una nueva <code>ShoppingList</code>, el <code>_ShoppingListState</code> se\n    reconstruye con el nuevo valor del widget.\n    Si desea ser notificado cuando cambie la propiedad\n    widget\n    puede anular la función\n    didUpdateWidget(),\n    que se pasa como <code>oldWidget</code> para que puedas comparar el widget antiguo\n    con el actual widget.</p>\n\n  <p>Cuando se maneja el callback <code>onCartChanged</code>, el <code>_ShoppingListState</code> muta su\n    estado interno agregando o quitando un producto de <code>_shoppingCart</code>. Para\n    indicar al framework que cambia su estado interno, envuelve esas llamadas\n    en una llamada setState().\n    Llamando setState marca este widget como sucio y lo programa para\n    que sea reconstruido la próxima vez que tu aplicación necesite actualizar la pantalla.\n    Si te olvidas de llamar setState cuando se modifica el estado interno\n    de un widget, el framework no sabrá que tu widget está sucio y podría no\n    llamar a la función build(),\n    lo que significa que es posible que la interfaz de usuario no se actualice\n    para reflejar el estado cambiado.</p>\n\n  <p>Gestionando el estado de esta manera, no es necesario escribir código separado\n    para crear y actualizar widgets hijo. En su lugar, simplemente implementa la función\n    de construcción, que maneja ambas situaciones.</p>\n\n  <h2>\n    Responder a los eventos del ciclo de vida de los widgets</h2>\n\n  <p>Después de llamar a\n    createState en el\n    StatefulWidget, el framework inserta el nuevo objeto de estado en el árbol y\n    luego llama initState en el\n    objeto de estado. Una subclase de State puedes\n    sobreescribir initState para hacer\n    el trabajo que debe suceder solo una vez. Por ejemplo, sobreescribir\n    initState\n    para configurar animaciones o suscribirse a los servicios de la plataforma. Implementaciones de\n    initState\n    deben comenzar llamando super.initState.</p>\n\n  <p>Cuando un objeto de estado ya no es necesario, el framework llama\n    dispose en el objeto de estado.<br>\n    Sobreescribir la función dispose\n    para realizar tareas de limpieza. Por ejemplo, puedes sobreescribir\n    dispose para cancelar timers o\n    darse de baja de los servicios de la plataforma. Las implementaciones de\n    dispose típicamente terminan llamando a\n    super.dispose.</p>\n\n  <p>Para más información, mira: State.</p>\n\n  <h2>Keys</h2>\n\n  <p>Usa keys para controlar que los widgets del framework coinciden con\n    otros widgets cuando un widget se reconstruye. Por defecto, el framework coincide\n    widgets en la construcción actual y anterior de acuerdo con su\n    runtimeType y el orden en que\n    aparecen. Con keys, el framework requiere que los dos widgets tengan\n    la misma key así como el mismo\n    runtimeType.</p>\n\n  <p>Las llaves son más útiles en los widgets que construyen muchas instancias del mismo tipo de\n    widget. Por ejemplo, el widget <code>ShoppingList</code>, que construye solo las instancias\n    <code>ShoppingListItem</code> suficientes para llenar su región visible:</p>\n\n  <ul>\n    <li>\n      <p>Sin las llaves, la primera entrada en la construcción actual siempre se sincronizaría con la\n        primera entrada en la construcción anterior, incluso si, semánticamente, la primera entrada en\n        la lista se ha desplazado fuera de la pantalla y ya no es visible en la ventana de visualización.</p>\n    </li>\n    <li>\n      <p>Asignando a cada entrada de la lista una llave “semántica”, la lista infinita puede\n        ser más eficaz porque el framework sincroniza las entradas con las llaves semánticas\n        coincidentes y, por lo tanto, con apariencias visuales similares (o identicas).\n        Además, sincronizar las entradas semánticamente significa que el estado conservado en\n        los widgets hijo stateful permanecen unidos a la misma entrada semántica en lugar\n        de la entrada, en la misma posición numérica dentro del viewport.</p>\n    </li>\n  </ul>\n  <p>Para más información, mira Key API-</p>\n  <h2>\n    Global Keys</h2>\n\n  <p>Usa global keys para identificar de forma única los widgets hijos. Las global keys\n    deben ser globalmente únicas en toda la jerarquía de widgets, a diferencia de las llaves\n    locales que sólo necesitan ser únicas entre hermanos. Debido a que son globalmente únicos, se\n    puede usar una llave global para recuperar el estado asociado con un widget.</p>\n\n  <p>Para más información, mira\n    GlobalKey API.</p>\n"
  },
  {
    "title": "6.2 Tutorial de layout",
    "subtitle": "Interfaz de Usuario",
    "content": ""
  },
  {
    "title": "6.3 Box constraints",
    "subtitle": "Interfaz de Usuario",
    "content": "  <h1>Tratar con restricciones de cajas</h1>\n    Contenidos\n    <ul>\n      <li>Restricciones ilimitadas</li>\n      <li>Flex</li>\n    </ul>\n  </div>\n  \n    <p> <strong>Nota:</strong>\n      Puede ser redirigido a esta página si el framework detecta problemas que involucren a\n      restricciones de caja (box constraints).</p>\n  \n\n  <p>En Flutter, los widgets son dibujados por su objeto\n    <code>RenderBox</code> subyacente. Las cajas de renderizado boxes toman las restricciones dadas por\n    sus padres, y se dimensioan a si mismos con estas\n    restricciones. Las restricciones consisten en anchos y altos míbimos y\n    máximos; las dimensiones consisten en un acho y alto específicos.</p>\n\n  <p>Generalmente, hay tres tipos de cajas, en términos de como manejan\n    sus restricciones:</p>\n\n  <ul>\n    <li>Aquellas que tratan de ser tan grandes como sea posible.\n      Por ejemplo, las cajas usadas por <code>Center</code> y <code>ListView</code>.</li>\n    <li>Aquellas que tratan de ser del mismo tamaño de sus hijos.\n      Por ejemplo, las cajas usadas por <code>Transform</code> y <code>Opacity</code>.</li>\n    <li>Aquellas que tratan de ser de unas dimensiones concretas.\n      Por ejemplo, las cajas usadas por <code>Image</code> y <code>Text</code>.</li>\n  </ul>\n\n  <p>Algunos widgets, por ejemplo <code>Container</code>, varian de tipo basándose en\n    los argumentos de su constructor. En el caso de <code>Container</code>, por defecto\n    trata de ser tan grande como sea posible, pero si le proporcionas un <code>width</code>, por\n    ejemplo, este trata de cumplir con esto y tener un tamaño concreto.</p>\n\n  <p>Otros, por ejemplo <code>Row</code> y <code>Column</code> (cajas flexibles) varían basándose en las\n    restricciones que se le proporcionen, como se describe abajao en la sección “Flex”.</p>\n\n  <p>Las restricciones son algunas veces “forzadas”, significando esto que estas no dejan espacio\n    al Renderbox para decidir un tamaño (e.j. si el mínimo y\n    el máximo ancho son el mismo, a esto se le llama tener un ancho forzado). El\n    principal ejemplo de esto es el widget <code>App</code>, el cual es contenido por la clase\n    <code>RenderView</code>:\n    la caja usada por el hijo devuelto por la funcion\n    <code>build</code> de la\n    aplicación toma una restricción que le fuerzaa llenar\n    exactamente el area de contenido de la aplicación (normalmente, la pantalla\n    completa). Muchas de las cajas en Flutter, especialmente aquellas que toman un\n    solo hijo, pasan sus restricciones a sus hijos. Esto\n    significa que si anidas un manojo de cajas dentro de otras en la raiz\n    del árbol de renderizado de tu aplicación, todos encajaran exactamente en los\n    otros, obligados por estas restricciones forzadas.</p>\n\n  <p>Algunas cajas <em>aflojan</em> sus restricciones, esto significa que se mantiene el máximo\n    pero se elimina el mínimo. Por ejemplo,\n    <code>Center</code>.</p>\n\n  <h2>\n    Restricciones ilimitadas</h2>\n\n  <p>En ciestas situaciones, la restricción que toma una caja es\n    <em>ilimitada</em>, o infinita. Esto significa que ya sea el ancho máximo o\n    la altura máxima están fijadas a <code>double.INFINITY</code>.</p>\n\n  <p>Una caja que trata de ser lo más grande posible no funcionará convenientemente cuando\n    se le da una restricción ilimitada y, en modo de depuración, tal combinación\n    lanzará un aexcepción que apunta a este docuemnto.</p>\n\n  <p>El caso más común una caja de renderizado se encuentra con restricciones\n    ilimitadas son las cajas flexibles\n    (<code>Row</code>\n    y <code>Column</code>),\n    y <strong>dentro de las regiones con scroll</strong>\n    (<code>ListView</code>\n    y otras subclases de <code>ScrollView</code>).</p>\n\n  <p>En particular, <code>ListView</code>\n    trata de expandirse para llenar el espacio disponible\n    en su cross-direction (ej. si es un block de scroll vertical, este trata\n    de ser tan ancho como su padre). Si anidas un\n    <code>ListView</code> de scroll vertical\n    dentro de un <code>ListView</code>,\n    de scroll horizontal, el interno trata de ser tan ancho como sea posible,\n    lo cual es ancho infinito, ya que el otro tiene scroll en esta dirección.</p>\n\n  <h2>\n    Flex</h2>\n\n  <p>Las cajas flexibles en si mismas,\n    (<code>Row</code>\n    y <code>Column</code>)\n    se conforman de forma diferente\n    dependiendo de si tienen restricciones limitadas o ilimitadas en\n    su dirección dada.</p>\n\n  <p>Con restricciones limitadas, estos tratan de ser tan grandes como sea posible en esta\n    dirección.</p>\n\n  <p>Con restricciones ilimitadas, estos tratan de ajustarse a sus hijos en esta\n    dirección. En este caso, no puedes fijar la propiedad <code>flex</code> en los hijos en\n    ora cosa que no sea 0 (su valor por defecto). En la biblioteca de widgets, esto\n    significa que no puedes usar <code>Expanded</code>\n    cuando la caja flexible esta dentro de\n    otra caja flexible o dentro de una caja con scroll. Si lo haces, onbtendrás un\n    mensaje de excepción remitiéndote a este documento.</p>\n\n  <p>En la dirección <em>cruzada</em>, ej. en su ancho para un <code>Column</code> (flex vertical) y en su\n    alto para un <code>Row</code> (flex horizontal), nunca debern ser ilimitados,\n    sino podrían no alinear razonablemente sus hijos.</p>\n</div>"
  },
  {
    "title": "6.4 Añade Interactividad a Tu App Flutter",
    "subtitle": "Interfaz de Usuario",
    "content": "  <h1>Añade Interactividad a Tu App Flutter</h1>\n  \n    \n      Contenidos\n    \n    <ul>\n      <li>Stateful and stateless widgets</li>\n      <li>Creando un widget stateful\n        <ul>\n          <li>Paso 0: Preparativos</li>\n          <li>Paso 1: Decide cual objeto administra el estado del widget</li>\n          <li>Paso 2: Subclase StatefulWidget</li>\n          <li>Paso 3: Subclase State</li>\n          <li>Paso 4: Enchufa el widget stateful en el árbol de widgets</li>\n          <li>¿Problemas?</li>\n        </ul>\n      </li>\n      <li>Administrar el estado\n        <ul>\n          <li>El widget maneja su propio estado</li>\n          <li>El widget padre administra el estado del widget</li>\n          <li>Un enfoque intermedio</li>\n        </ul>\n      </li>\n      <li>Otros widgets interactivos\n        <ul>\n          <li>Widgets estándar:</li>\n          <li>Material Components:</li>\n        </ul>\n      </li>\n      <li>Recursos</li>\n    </ul>\n  \n  \n    <h4 class=\"no_toc\">\n      Lo que aprenderás</h4>\n\n    <ul>\n      <li>Como responder a gestos tap.</li>\n      <li>Como crear un widget personalizado.</li>\n      <li>La diferencia entre stateless y stateful widgets.</li>\n    </ul>\n  \n\n  <p>¿Cómo modificas tu app para hacer que reaccione a las entradas del usuario?\n    En este tutorial, añadirás interactividad a una app que contiene solo widgets no interactivos.\n    Específicamente, modificarás un icono para hacerlo pulsable creando\n    un widget stateful personalizado que administra dos widgets stateless.</p>\n\n  <p>Tutorial de layout te\n    mostró como crear el layout de la siguiente captura de pantalla.</p>\n\n  <figure class=\"site-figure \">\n    \n      <img src=\"asset:assets/img/6_4_lakes-2e8707102ca4f56f44e40ce3703606e1600ac1574fe5544c0f2d96f966bed853.jpg\">\n      <figcaption class=\"figure-caption\">The layout tutorial app</figcaption>\n    \n  </figure>\n\n  <p>Cuando la app se lanza por primera vez, la estrella esta rellena de rojo, indicando que este lago\n    ha sido marcado previamente como favorito. El número a continuación de la estrella indica que\n    41 personas han marcado como favorito este lago. Después de completar este tutorial,\n    pulsando la estrella se desmarcará como favorito, reemplazando la estrella rellena\n    con una sin relleno y decrecerá el contador. Pulsando de nuevo\n    se marca el lago como favorito, dibujando la estrella rellena e incrementando el contador.</p>\n\n  <p class=\"text-center\"><img src=\"asset:assets/img/6_4_favorited-not-favorited-e819c6dfba41b33418caa51282b524f04c12ec5217c41b19cefed685fb4d814b.png\"></p>\n\n  <p>Para lograr esto, crearás un widget personalizado que incluye tanto la estrella\n    como el contador, que son a su vez widgets. Como pulsar sobre la estrella\n    cambia el estado de ambos widgets, entonces el mismo debería administrar ambos.</p>\n\n  <p>Puedes empezar a tocar el código en  Paso 2: Subclase\n    StatefulWidget. Si quieres probar diferentes\n    maneras de administrar el estado, salta a Administrando el estado.</p>\n\n  <h2>\n    Stateful and stateless widgets</h2>\n\n  <p>Un widget puede ser stateful, o stateless. Si un widget cambia—por ejemplo,\n    cuando el usuario interactúa con el—es stateful.</p>\n\n  <p>Un widget <em>stateless</em> widget. Icon, IconButton, y Text son\n    ejemplos de widgets stateless. Los widgets stateless heredan de la clase StatelessWidget.</p>\n\n  <p>Un widget <em>stateful</em> es dinámico: por ejemplo, este puede cambiar su apariencia en\n    respuesta a eventos desencadenados por la intereacción del usuario o cuando recibe datos.\n    Checkbox, Radio, Slider, InkWell, Form, y TextField\n    son ejemplos de widgets stateful. Los widgets stateful heredan de la clase StatefulWidget.</p>\n\n  <p>El estado de un widget se alamacena en un objeto State, separando el estado del widget\n    de su apariencia. El estado de un widget consiste en valores que pueden cambiar, como el valor actual\n    de un slider o cuando un checkbox esta marcado como checked.\n    Cuando el estado de un widget cambia, el objeto state llama a\n    <code>setState()</code>, diciendo al framework que repinte el widget.</p>\n\n  <h2>\n    Creando un widget stateful</h2>\n\n  \n    <h4 class=\"no_toc\">\n      ¿Qué aprenderás?</h4>\n\n    <ul>\n      <li>Un widget stateful es implementado por dos clases: una subclase de\n        <code>StatefulWidget</code> y una subclase de <code>State</code>.</li>\n      <li>La clase state contiene el estado mutable del widget y el\n        método <code>build()</code>.</li>\n      <li>Cuando el estado del widget cambia, el objeto state llama a\n        <code>setState()</code>, diciéndole al framework que redibuje el widget.</li>\n    </ul>\n  \n\n  <p>En esta sección, crearás un widget stateful personalizado. Reemplazarás dos\n    widgets stateless—la estrella rellena de rojo y el contador numérico junto\n    a ella—con un único stateful widget personalizado que administra una fila\n    con dos widgets hijos: un <code>IconButton</code> y un <code>Text</code>.</p>\n\n  <p>Implementar un widget stateful personalizado requiere crear dos clases:</p>\n\n  <ul>\n    <li>Una subclase de <code>StatefulWidget</code> que define el widget.</li>\n    <li>Una subclase de <code>State</code> que contiene el estado para el widget y define el método\n      <code>build()</code>.</li>\n  </ul>\n\n  <p>Esta sección muestra como construir un StatefulWidget, llamado <code>FavoriteWidget</code>,\n    para la app Lakes. El primer paso es elegir como administrar el\n    estado de <code>FavoriteWidget</code>.</p>\n\n  <h3>\n    Paso 0: Preparativos</h3>\n\n  <p>Si ya has contruido el layout en Tutorial de layout (paso 6),\n    salta a la siguiente sección.</p>\n\n  <ol>\n    <li>Asegúrate que has configurado tu entorno.</li>\n    <li>\n      Crea una app “Hello World” Flutter básica..</li>\n    <li>Reemplaza el fichero <code>lib/main.dart</code> con\n      [<code>main.dart</code>]https://github.com/flutter-es/website/tree/dash/examples/layout/lakes/step6/lib/main.dart).\n      <ul>\n        <li>Reemplaza el fichero <code>pubspec.yaml</code> con\n          [<code>pubspec.yaml</code>]https://github.com/flutter-es/website/tree/dash/examples/layout/lakes/step6/pubspec.yaml).</li>\n        <li>Crea un directorio <code>images</code> en tu proyecto, y añade\n          <code>lake.jpg</code>..</li>\n      </ul>\n    </li>\n  </ol>\n\n  <p>Cuando tienes un dispositivo conectado y habilitado, o has lanzado el [simulador iOS][]\n    (parte de la instalación de Flutter), ¡estás preparado para seguir!</p>\n\n  <p></p>\n  <h3>\n    Paso 1: Decide cual objeto administra el estado del widget</h3>\n\n  <p>El estado de un widget puede ser administrado de varias maneras, pero en nuestro ejemplo,\n    el widget <code>FavoriteWidget</code>, administrará por si mismo su estado.\n    En este ejemplo, alternar la estrella es una acción aislada que no afecta\n    al widget padre o al resto de la UI, por eso el widget puede manejar su estado internamente.</p>\n\n  <p>Aprende mas acerca de la separación de widget y estado,\n    y como puede ser admnistrado el estado, en Administrando el estado.</p>\n\n  <p></p>\n  <h3>\n    Paso 2: Subclase StatefulWidget</h3>\n\n  <p>La clase <code>FavoriteWidget</code> administra su propio estado, sobreescribiendo el método\n    <code>createState()</code> para crear el objeto State.\n    El framework llama a <code>createState()</code> cuando quiere construir el widget.\n    En este ejemplo, <code>createState()</code> crea una instancia de _FavoriteWidgetState, que implementarás en el siguiente paso.</p>\n\n  \n    lib/main.dart (FavoriteWidget)\n      <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class FavoriteWidget extends StatefulWidget {\n  @override\n  _FavoriteWidgetState createState() =&gt; _FavoriteWidgetState();\n}</pre>\n  \n\n  \n    <p> <strong>Nota:</strong>\n      Miembros o clases que empiezan con un guión bajo (_) son privados. Para más información,\n      mira Bibliotecas y visibilidad, una sección en el\n      Dart language tour.</p>\n\n  \n\n  <p></p>\n  <h3>\n    Paso 3: Subclase State</h3>\n\n  <p>La clase _FavoriteWidgetState<code> almacena la información mutable&amp;mdash;la lógica y estado interno que puede cambiar\n    durante el tiempo de vida del widget. Cuando la app se lanza por primera vez, la UI muestra una estrella\n    rellena de rojo, indicando que el lago tiene el estado \"favorite\", y tiene 41 “likes”.\n    El objeto state almacena esta información en las variables </code>_isFavorited<code> y </code>_favoriteCount`.</p>\n\n  \n    lib/main.dart (_FavoriteWidgetState fields)\n      <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class _FavoriteWidgetState extends State&lt;FavoriteWidget&gt; {\n  bool _isFavorited = true;\n  int _favoriteCount = 41;\n  // ···\n}</pre>\n  \n\n  <p>La clase también define el método <code>build</code> que crea una fila conteniendo un <code>IconButton</code>\n    rojo, y un <code>Text</code>. Usas IconButton, (en lugar de <code>Icon</code>), porque este tiene\n    una propiedad <code>onPressed</code> que define el método callback\n    (<code>_toggleFavorite</code>) para manejar un gesto tap. Definirás\n    la función callback a continuación.</p>\n\n  \n    lib/main.dart (_FavoriteWidgetState build)\n      <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class _FavoriteWidgetState extends State&lt;FavoriteWidget&gt; {\n  // ···\n  @override\n  Widget build(BuildContext context) {\n    return Row(\n      mainAxisSize: MainAxisSize.min,\n      children: [\n        Container(\n          padding: EdgeInsets.all(0),\n          child: IconButton(\n            icon: (_isFavorited ? Icon(Icons.star) : Icon(Icons.star_border)),\n            color: Colors.red[500],\n            onPressed: _toggleFavorite,\n          ),\n        ),\n        SizedBox(\n          width: 18,\n          child: Container(\n            child: Text('$_favoriteCount'),\n          ),\n        ),\n      ],\n    );\n  }\n}</pre>\n  \n\n  \n    <p> <strong>Consejo:</strong>\n      Colocando un <code>Text</code> en un SizedBox y configurando su ancho previene un\n      apreciable “salto” cuando el texto cambia entre valores de 40 y 41\n      — ocurriría un salto de otro modo porque estos valores tienen\n      diferentes anchos.</p>\n  \n\n  <p>El método <code>_toggleFavorite()</code>, que es llamado couando el <code>IconButton</code> es presionado,\n    llama a <code>setState()</code>. Llamar a <code>setState()</code> es fundamental, porque esto dice\n    al framework que el estado del widget ha cambiado y el widget deberia redibujarse. La función\n    pasada a <code>setState()</code> alterna la UI entre\n    estos dos estados:</p>\n\n  <ul>\n    <li>Un icono <code>star</code> y el número 41</li>\n    <li>Un icono <code>star_border</code> y el número 40.</li>\n  </ul>\n\n  \n      <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">void _toggleFavorite() {\n  setState(() {\n    if (_isFavorited) {\n      _favoriteCount -= 1;\n      _isFavorited = false;\n    } else {\n      _favoriteCount += 1;\n      _isFavorited = true;\n    }\n  });\n}</pre>\n  \n\n  <p></p>\n  <h3>\n    Paso 4: Enchufa el widget stateful en el árbol de widgets</h3>\n\n  <p>Añade tu widget stateful personalizado al árbol de widgets en el método <code>build()</code>\n    de la app. Primero, localiza el código que creaba el <code>Icon</code> y el <code>Text</code>, y bórralo. En la misma\n    ubicación, crea el widget stateful:</p>\n  <p>¡Esto es todo! Cuando haces hot reload de la app, el icono estrella debería responder a gestos tap.</p>\n\n  <h3>\n    ¿Problemas?</h3>\n\n  <p>Si no puedes hacer que el código se ejecute, mira en tu IDE por posibles errores.\n    Depurar Apps en Flutter puede ayudar.\n    Si sigues sin encontrar el problema,\n    comprueba tu código con el ejemplo “interactive Lakes” en GitHub.</p>\n\n  <ul>\n    <li>lib/main.dart</li>\n    <li>pubspec.yaml</li>\n    <li>lakes.jpg</li>\n  </ul>\n\n  <p>Si sigues teniendo preguntas, dirígete a uno de los\n    canales de desarrolladores de la comunidad.</p>\n\n  <hr>\n\n  <p>El resto de esta página cubre varias maneras en que puede ser administrado el estado de un widget,\n    y lista otros widgets interactivos disponibles.</p>\n\n  <h2>\n    Administrar el estado</h2>\n\n  \n    <h4 class=\"no_toc\">\n      ¿Qué aprenderás?</h4>\n\n    <ul>\n      <li>Hay diferentes enfoques para administrar estados.</li>\n      <li>Tú, como diseñador del widget, eliges que enfoque usar.</li>\n      <li>Si dudas, empieza administrando el estado en el widget padre.</li>\n    </ul>\n  \n\n  <p>¿Quién administra el estado de un widget stateful? ¿El propio widget? ¿El widget padre?\n    ¿Ambos? ¿Otro objeto? La respuesta es… depende.\n    Hay muchas formas válidas de hacer tu widget interactivo.\n    Tú, como diseñador del widget, tomas la decisión basándote en como esperas que\n    tu widget sea usado. Aqui están las maneras más comunes de administrar estados:</p>\n\n  <ul>\n    <li>El widget administra su propio estado</li>\n    <li>El padre administra el estado del widget</li>\n    <li>Un enfoque intermedio</li>\n  </ul>\n\n  <p>¿Cómo decides que enfoque usar? Los siguientes principios deberían ayudarte a\n    decidirte:</p>\n\n  <ul>\n    <li>\n      <p>Si el estado en cuestión son datos que genera el usuario, por ejemplo el modo\n        checked o unchecked de un checkbox, o la posición de un slider, entonces es mejor\n        administrar el estado en el widget padre.</p>\n    </li>\n    <li>\n      <p>Si el estado en cuestión es estético, por ejemplo una animación,\n        entonces el estado es mejor administrarlo en el propio widget.</p>\n    </li>\n  </ul>\n\n  <p>Si dudas, empieza administrando el estado en el widget padre.</p>\n\n  <p>Vamos a dar ejemplos de las diferentes maneras de administrar el estado creando tres\n    ejemplos simples: TapboxA, TapboxB, y TapboxC.\n    Todos los ejemplos funcionan de forma similar—cada uno crea un container que,\n    cuando es pulsado, alterna entre una caja verde o gris.\n    El boolean <code>_active</code> determina el color: verede para activo o gris para inactivo.</p>\n\n  \n    \n      <img src=\"asset:assets/img/6_4_tapbox-active-state-c15c36d6d1dba545455bdf35a9296a5c10e687766827eb34b65a5249f6f8fb26.png\">\n      <img src=\"asset:assets/img/6_4_tapbox-inactive-state-aca712be6a90ad554342ab72926c4f167d76ca505794fcdad9caf6a3ff6f94b7.png\">\n    \n  \n\n  <p>Estos ejemplos usan GestureDetector para capturar la actividad en el Container.</p>\n\n  <p></p>\n  <h3>\n    El widget maneja su propio estado</h3>\n\n  <p>A veces tiene más sentido que el widget administre su estado internamente.\n    Por ejemplo, ListView hace automáticamente scroll cuando su contenido excede la render box. La mayoría\n    de desarrolladores que usan ListView no tienen que administrar el compartamiento de\n    scroll del ListView, ya que ListView administra por si mismo su scroll offset.</p>\n\n  <p>La clase <code>_TapboxAState</code>:</p>\n\n  <ul>\n    <li>Administra el estado para TapboxA.</li>\n    <li>Define la propiedad boolean <code>_active</code> que determina el color actual de la caja.</li>\n    <li>Define la función <code>_handleTap()</code>, que actualiza <code>_active</code> cuando la caja es\n      pulsada y llama la función <code>setState()</code> para actualizar el UI.</li>\n    <li>Implementa todo el comportamiento interactivo para el widget.</li>\n  </ul>\n\n    <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">// TapboxA manages its own state.\n\n//------------------------- TapboxA ----------------------------------\n\nclass TapboxA extends StatefulWidget {\n  TapboxA({Key key}) : super(key: key);\n\n  @override\n  _TapboxAState createState() =&gt; _TapboxAState();\n}\n\nclass _TapboxAState extends State&lt;TapboxA&gt; {\n  bool _active = false;\n\n  void _handleTap() {\n    setState(() {\n      _active = !_active;\n    });\n  }\n\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: _handleTap,\n      child: Container(\n        child: Center(\n          child: Text(\n            _active ? 'Active' : 'Inactive',\n            style: TextStyle(fontSize: 32.0, color: Colors.white),\n          ),\n        ),\n        width: 200.0,\n        height: 200.0,\n        decoration: BoxDecoration(\n          color: _active ? Colors.lightGreen[700] : Colors.grey[600],\n        ),\n      ),\n    );\n  }\n}\n\n//------------------------- MyApp ----------------------------------\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Flutter Demo'),\n        ),\n        body: Center(\n          child: TapboxA(),\n        ),\n      ),\n    );\n  }\n}</pre>\n\n  <hr>\n\n  <p></p>\n  <h3>\n    El widget padre administra el estado del widget</h3>\n\n  <p>A menudo tiene mas sentido que el widget padre administre el estado y le diga al\n    widget hijo cuando actualizarse. Por ejemplo, IconButton te permite tratar un\n    icono como un botón pulsable.\n    IconButton es un widget stateless porque decidimos que el widget padre\n    necesita saber cuando se ha pulsado el botón, para entonces, poder tomar la acción adecuada.</p>\n\n  <p>En el siguiente ejemplo, TapboxB exporta su estado a su padre a través de un\n    callback. Como TapboxB no administra su estado, es\n    una subclase de StatelessWidget.</p>\n\n  <p>La clase ParentWidgetState:</p>\n\n  <ul>\n    <li>Administra el estado <code>_active</code> para TapboxB.</li>\n    <li>Implementa <code>_handleTapboxChanged()</code>, el método llamado cuando la caja es pulsada.</li>\n    <li>Cuando el estado cambia, llama a <code>setState()</code> para actualizar el UI.</li>\n  </ul>\n\n  <p>La clase TapboxB:</p>\n\n  <ul>\n    <li>Hereda de StatelessWidget porque todo estado es manejado por su padre.</li>\n    <li>Cuando detecta un gesto tap, notifica al padre.</li>\n  </ul>\n\n    <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">// ParentWidget manages the state for TapboxB.\n\n//------------------------ ParentWidget --------------------------------\n\nclass ParentWidget extends StatefulWidget {\n  @override\n  _ParentWidgetState createState() =&gt; _ParentWidgetState();\n}\n\nclass _ParentWidgetState extends State&lt;ParentWidget&gt; {\n  bool _active = false;\n\n  void _handleTapboxChanged(bool newValue) {\n    setState(() {\n      _active = newValue;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      child: TapboxB(\n        active: _active,\n        onChanged: _handleTapboxChanged,\n      ),\n    );\n  }\n}\n\n//------------------------- TapboxB ----------------------------------\n\nclass TapboxB extends StatelessWidget {\n  TapboxB({Key key, this.active: false, @required this.onChanged})\n      : super(key: key);\n\n  final bool active;\n  final ValueChanged&lt;bool&gt; onChanged;\n\n  void _handleTap() {\n    onChanged(!active);\n  }\n\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onTap: _handleTap,\n      child: Container(\n        child: Center(\n          child: Text(\n            active ? 'Active' : 'Inactive',\n            style: TextStyle(fontSize: 32.0, color: Colors.white),\n          ),\n        ),\n        width: 200.0,\n        height: 200.0,\n        decoration: BoxDecoration(\n          color: active ? Colors.lightGreen[700] : Colors.grey[600],\n        ),\n      ),\n    );\n  }\n}</pre>\n\n  \n    <p> <strong>Consejo:</strong>\n      Cuando creas la API, considera usar la notación <code>@required</code> para cualquier\n      parámetro en que se base tu código. Para usar <code>@required</code>, importa la [biblioteca foundation][]\n      (que re-exporta la blibioteca meta.dart):</p>\n\n    <p><!-- skip --></p>\n    \n        <pre class=\"highlight\"><code>  import 'package:flutter/foundation.dart';\n</code></pre>  \n  \n\n  <hr>\n\n  <p></p>\n  <h3>\n    Un enfoque intermedio</h3>\n\n  <p>Para algunos widgets, un enfoque intermedio es más conveniente.\n    En este escenario, el widget stateful administra algo del estado, y el\n    widget padre administra otro aspecto del estado.</p>\n\n  <p>En el ejemplo <code>TapboxC</code>, cuando el gesto tap inicia, <em>tap down</em>, un borde verde oscuro aparece\n    alrededor de la caja. Cuando el gesto tap acaba, <em>tap up</em>, el borde desaparece y el color\n    de la caja cambia. <code>TapboxC</code> exporta su estado <code>_active</code> a su padre pero administra\n    internamente su estado <code>_highlight</code>. Este\n    ejemplo tiene dos objetos State, <code>_ParentWidgetState</code> y <code>_TapboxCState</code>.</p>\n\n  <p>El objeto <code>_ParentWidgetState</code>:</p>\n\n  <ul>\n    <li>Administra el estado <code>_active</code>.</li>\n    <li>Implementa <code>_handleTapboxChanged()</code>, el método que se llama cuando la caja es pulsada.</li>\n    <li>Llama a <code>setState()</code> para actualizar el UI cuando un gesto tap ocurre y el estado <code>_active</code>\n      cambia.</li>\n  </ul>\n\n  <p>El objeto <code>_TapboxCState</code>:</p>\n\n  <ul>\n    <li>Administra el estado <code>_highlight</code>.</li>\n    <li>El <code>GestureDetector</code> escucha todos los eventos tap.  Cuando el usaurio hace <em>tap down</em>,\n      añade el resaltado (implementado como un borde verde oscuro). Cuando el\n      usuario termina de pulsar, <em>tap up</em>, el resaltado se elimina.</li>\n    <li>LLama a <code>setState()</code> para actualizar el UI cuando se hace tap down, tap up, o se cancela el tap, y\n      cambie el estado <code>_highlight</code>.</li>\n    <li>Cuan hay un evento tap, pasa este cambio de estado al widget padre para tomar la acción\n      adecuada usando la propiedad widget.</li>\n  </ul>\n\n    <pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">//---------------------------- ParentWidget ----------------------------\n\nclass ParentWidget extends StatefulWidget {\n  @override\n  _ParentWidgetState createState() =&gt; _ParentWidgetState();\n}\n\nclass _ParentWidgetState extends State&lt;ParentWidget&gt; {\n  bool _active = false;\n\n  void _handleTapboxChanged(bool newValue) {\n    setState(() {\n      _active = newValue;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      child: TapboxC(\n        active: _active,\n        onChanged: _handleTapboxChanged,\n      ),\n    );\n  }\n}\n\n//----------------------------- TapboxC ------------------------------\n\nclass TapboxC extends StatefulWidget {\n  TapboxC({Key key, this.active: false, @required this.onChanged})\n      : super(key: key);\n\n  final bool active;\n  final ValueChanged&lt;bool&gt; onChanged;\n\n  _TapboxCState createState() =&gt; _TapboxCState();\n}\n\nclass _TapboxCState extends State&lt;TapboxC&gt; {\n  bool _highlight = false;\n\n  void _handleTapDown(TapDownDetails details) {\n    setState(() {\n      _highlight = true;\n    });\n  }\n\n  void _handleTapUp(TapUpDetails details) {\n    setState(() {\n      _highlight = false;\n    });\n  }\n\n  void _handleTapCancel() {\n    setState(() {\n      _highlight = false;\n    });\n  }\n\n  void _handleTap() {\n    widget.onChanged(!widget.active);\n  }\n\n  Widget build(BuildContext context) {\n    // This example adds a green border on tap down.\n    // On tap up, the square changes to the opposite state.\n    return GestureDetector(\n      onTapDown: _handleTapDown, // Handle the tap events in the order that\n      onTapUp: _handleTapUp, // they occur: down, up, tap, cancel\n      onTap: _handleTap,\n      onTapCancel: _handleTapCancel,\n      child: Container(\n        child: Center(\n          child: Text(widget.active ? 'Active' : 'Inactive',\n              style: TextStyle(fontSize: 32.0, color: Colors.white)),\n        ),\n        width: 200.0,\n        height: 200.0,\n        decoration: BoxDecoration(\n          color:\n              widget.active ? Colors.lightGreen[700] : Colors.grey[600],\n          border: _highlight\n              ? Border.all(\n                  color: Colors.teal[700],\n                  width: 10.0,\n                )\n              : null,\n        ),\n      ),\n    );\n  }\n}</pre>\n\n  <p>Una implementación alternativa podría haber sido exportar el estado resaltado al\n    padre mientras mantiene el estado active internamente,\n    pero si preguntas a alguien por usar este tap box, probablemente opinen que no tienen mucho\n    sentido. Al desarrollador le importa si la caja esta activa. Al desarrollador\n    probablemente no le preocupe como se administra el resaltado, y prefiera\n    que el tap box maneje estos detalles.</p>\n\n  <hr>\n\n  <h2>\n    Otros widgets interactivos</h2>\n\n  <p>Flutter ofrece una variedad de botones y widgets interactivos similares.\n    La mayoría de estos widgets implementan las [Material Design guidelines,][] que definen un conjunto de\n    componentes con una UI pragmática.</p>\n\n  <p>Si lo prefieres, puedes usar GestureDetector para construir interactividad\n    en cualquier widget personalizado. Puedes encontrar ejemplos de GestureDetector\n    en Administrado el estado, y en la Flutter Gallery.</p>\n\n  \n    <p> <strong>Consejo:</strong>\n      Flutter también proporciona un conjunto de widgets con estilo iOS llamados Cupertino.</p>\n  \n\n  <p>Cuando necesitas interactividad,\n    lo más sencillo es usar uno de los widgets prefabricados. Aquí está una lista parcial:</p>\n\n  <h3>\n    Widgets estándar:</h3>\n\n  <ul>\n    <li>Form</li>\n    <li>FormField</li>\n  </ul>\n\n  <h3>\n    Material Components:</h3>\n\n  <ul>\n    <li>Checkbox</li>\n    <li>DropdownButton</li>\n    <li>FlatButton</li>\n    <li>FloatingActionButton</li>\n    <li>IconButton</li>\n    <li>Radio</li>\n    <li>RaisedButton</li>\n    <li>Slider</li>\n    <li>Switch</li>\n    <li>TextField</li>\n  </ul>\n\n  <h2>\n    Recursos</h2>\n\n  <p>Los siguientes recursos pueden ayudar cuando añades interactividad a tu app.</p>\n\n  <ul>\n    <li>\n      Manejando gestos, una sección en Introducción a los widgets<br>\n      Como crear un botón y hacer que responda a las entradas.</li>\n    <li>\n      Gestos en Flutter<br>\n      Una descripción del mecanismo de gestos de Flutter.</li>\n    <li>\n      Documentación de la API de Flutter API<br>\n      Referencia para todas las bibliotecas de Flutter.</li>\n    <li>\n      Flutter Gallery<br>\n      App de demostración mostrando muchos Material Components y otras características de Flutter.</li>\n    <li>\n      Flutter’s Layered Design (video)<br>\n      Este video incluye información acerca de state y stateless widgets.\n      Presentado por el ingeniero de Google, Ian Hickson.</li>\n  </ul>"
  },
  {
    "title": "6.5 Assets e imagenes",
    "subtitle": "Interfaz de Usuario",
    "content": "  <h1>Añadir assets e imágenes</h1>\n    Contenidos\n    <ul>\n      <li>Especificando recursos\n        <ul>\n          <li>Agrupación de recursos</li>\n          <li>Variantes de recursos</li>\n        </ul>\n      </li>\n      <li>Cargando recursos\n        <ul>\n          <li>Cargando elementos de texto</li>\n          <li>Cargando imágenes\n            <ul>\n              <li>Declaración de assets de imagen según la resolución</li>\n              <li>Cargando imagenes</li>\n            </ul>\n          </li>\n          <li>Recursos de imágenes en paquetes\n            <ul>\n              <li>Agrupando recursos de un paquete</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Compartir recursos con la plataforma subyacente\n        <ul>\n          <li>Android</li>\n          <li>iOS</li>\n        </ul>\n      </li>\n      <li>Recursos de plataforma\n        <ul>\n          <li>Actualizando el ícono de la aplicación\n            <ul>\n              <li>Android</li>\n              <li>iOS</li>\n            </ul>\n          </li>\n          <li>Actualizando la pantalla de bienvenida\n            <ul>\n              <li>Android</li>\n              <li>iOS</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n    </ul>\n  \n  <p>Las aplicaciones de Flutter pueden incluir tanto código como <em>assets</em> (algunas veces llamado\n    recursos). Un asset es un archivo que se incluye e implementa con su aplicación, y es accesible en\n    tiempo de ejecución. Los tipos comunes de recursos incluyen datos estáticos (por ejemplo, archivos\n    JSON), archivos de configuración, iconos e imágenes (JPEG, WebP, GIF, WebP/GIF animados, PNG, BMP y\n    WBMP).</p>\n\n  <h2>\n    Especificando recursos</h2>\n\n  <p>Flutter usa el archivo\n    <code>pubspec.yaml</code>,\n    ubicado en la raíz de su proyecto, para identificar los recursos requeridos\n    por una aplicación.</p>\n\n  <p>Aquí hay un ejemplo:</p>\n\n    <pre><code>flutter:\n  assets:\n    - assets/my_icon.png\n    - assets/background.png\n</code></pre>\n\n  <p>Para incluir todos los assets en un directorio, especifique el nombre del directorio\n    con el carácter <code>/</code> al final:</p>\n\n    <pre><code>flutter:\n  assets:\n    - assets/\n</code></pre>\n\n  <p>Tenga en cuenta que solo se incluirán los archivos ubicados directamente\n    en el directorio; para agregar archivos ubicados en subdirectorios, cree una entrada\n    por directorio.</p>\n\n  <h3>\n    Agrupación de recursos</h3>\n\n  <p>La subsección <code>assets</code> de la sección <code>flutter</code> especifica los archivos que\n    deberían incluirse con la aplicación. Cada recurso se identifica mediante\n    una ruta explícita (relativa al archivo <code>pubspec.yaml</code>) donde se encuentra\n    la carpeta de recursos. El orden en que se declaran los recursos\n    no importa. El directorio real\n    utilizado ( <code>assets</code> en este caso) no importa.</p>\n\n  <p>Durante una compilación, Flutter coloca los recursos en un archivo especial llamado\n    <em>asset bundle</em> (paquete de recursos), del cual las aplicaciones pueden leer en tiempo de ejecución.</p>\n\n  <h3>\n    Variantes de recursos</h3>\n\n  <p>El proceso de compilación admite la noción de variantes de recursos: diferentes versiones\n    de un activo que pueden mostrarse en diferentes contextos. Cuando se especifica la\n    ruta de un recurso en la sección <code>assets</code> de <code>pubspec.yaml</code>, el proceso de compilación\n    busca cualquier archivo con el mismo nombre en subdirectorios\n    adyacentes. Dichos archivos se incluyen en el paquete de recursos junto\n    con el activo especificado.</p>\n\n  <p>Por ejemplo, si tienes los siguientes archivos en el directorio de tu\n    aplicación:</p>\n\n    <pre><code>  .../pubspec.yaml\n  .../graphics/my_icon.png\n  .../graphics/background.png\n  .../graphics/dark/background.png\n  ...etc.\n</code></pre>\n\n  <p>…y su archivo <code>pubspec.yaml</code> contiene:</p>\n\n    <pre><code>flutter:\n  assets:\n    - graphics/background.png\n</code></pre>\n\n  <p>…entonces ambos <code>graphics/background.png</code> y <code>graphics/dark/background.png</code> se incluirán en su\n    paquete de recursos. El primero se considera el <em>main asset</em> (recurso principal), mientras\n    que el segundo se considera una <em>variante</em>.</p>\n\n  <p>Si, por otro lado, se especifica el directorio de gráficos:</p>\n\n    <pre><code>flutter:\n  assets:\n    - graphics/\n</code></pre>\n\n  <p>…entonces <code>graphics/my_icon.png</code>, <code>graphics/background.png</code> y <code>graphics/dark/background.png</code> serán incluidos.</p>\n\n  <p>Flutter utiliza variantes de recursos al elegir imágenes apropiadas para la\n    resolución; observa abajo. En el futuro, este mecanismo se puede ampliar\n    para incluir variantes para diferentes lugares o regiones,\n    leer instrucciones, etc.</p>\n\n  <h2>\n    Cargando recursos</h2>\n\n  <p>Tu aplicación puede acceder a sus recursos a través de un objeto\n    <code>AssetBundle</code>\n    (paquete de recursos).</p>\n\n  <p>Los dos métodos principales en un paquete de recursos te permiten cargar un\n    elemento de texto (<code>loadString</code>) o una imagen/recurso binario (<code>load</code>) fuera\n    del paquete, dada una clave lógica. La clave lógica se correlaciona con la\n    ruta al recurso especificado en el archivo <code>pubspec.yaml</code> durante el tiempo de compilación.</p>\n\n  <h3>\n    Cargando elementos de texto</h3>\n\n  <p>Cada aplicación Flutter tiene un\n    <code>rootBundle</code>\n    (paquete raiz) para acceder fácilmente al paquete de recursos\n    principal. Es posible cargar recursos directamente utilizando la\n    <code>rootBundle</code> estática global de <code>package:flutter/services.dart</code>.</p>\n\n  <p>Sin embargo, se recomienda obtener el AssetBundle para\n    el BuildContext actual utilizando <code>DefaultAssetBundle</code>. En\n    lugar del paquete de recursos predeterminado que\n    se creó con la aplicación, este enfoque permite que\n    un Widget principal sustituya un AssetBundle diferente\n    en tiempo de ejecución, lo que puede ser útil para\n    escenarios de localización o prueba.</p>\n\n  <p>Normalmente, utilizará <code>DefaultAssetBundle.of()</code> para cargar indirectamente\n    un recurso, por ejemplo un archivo JSON, desde el <code>rootBundle</code> en tiempo de ejecución de la aplicación.</p>\n\n  <p>Fuera de un contexto de Widget, o cuando no está disponible un\n    identificador para un AssetBundle, puede usar <code>rootBundle</code> para\n    cargar directamente dichos recursos, por ejemplo:</p>\n\n    <pre><code>import 'dart:async' show Future;\nimport 'package:flutter/services.dart' show rootBundle;\n\nFuture&lt;String&gt; loadAsset() async {\n  return await rootBundle.loadString('assets/config.json');\n}\n</code></pre>\n\n  <h3>\n    Cargando imágenes</h3>\n\n  <p>Flutter puede cargar imágenes con la resolución apropiada para la relación de\n    píxeles del dispositivo actual.</p>\n\n  <h4 id=\"resolution-aware\">\n    Declaración de assets de imagen según la resolución</h4>\n\n  <p><code>AssetImage</code>\n    entiende cómo asignar un recurso solicitado lógico a uno que se aproxime\n    más a la proporción actual de píxeles del dispositivo. Para que esta\n    asignación funcione, los activos se deben organizar de acuerdo con una\n    estructura de directorios particular:</p>\n\n    <pre><code>  .../image.png\n  .../Mx/image.png\n  .../Nx/image.png\n  ...etc.\n</code></pre>\n\n  <p>…donde <strong>M</strong> y <strong>N</strong> son identificadores numéricos que corresponden a la\n    resolución nominal de las imágenes contenidas en el interior, en otras\n    palabras, especifican la relación de píxel del dispositivo para el que están destinadas las imágenes.</p>\n\n  <p>Se supone que el recurso principal corresponde a una resolución\n    de 1.0. Por ejemplo, considera el siguiente diseño de recursos para\n    una imagen llamada <code>my_icon.png</code>:</p>\n\n    <pre><code>  .../my_icon.png\n  .../2.0x/my_icon.png\n  .../3.0x/my_icon.png\n</code></pre>\n\n  <p>En los dispositivos con una relación de píxel de dispositivo de 1.8, se\n    elegiría el recurso <code>.../2.0x/my_icon.png</code>. Para una proporción de píxel\n    de dispositivo de 2.7, se elegiría el recurso <code>.../3.0x/my_icon.png</code>.</p>\n\n  <p>Si el ancho y el alto de la imagen renderizada no están especificados en el Widget\n    <code>Image</code>, la resolución nominal se usa para escalar el recurso de modo que ocupe\n    la misma cantidad de espacio en la pantalla que el recurso principal, solo con\n    una resolución más alta. Es decir, si <code>.../my_icon.pnges</code> es de 72px por 72px,\n    entonces <code>.../3.0x/my_icon.png</code> debería ser de 216px por 216px; pero ambos se\n    procesarán en 72px por 72px (en píxeles lógicos) si no se especifican el ancho y el alto.</p>\n\n  <p>Cada entrada en la sección de recursos de <code>pubspec.yaml</code> debe corresponder a un archivo\n    real, con la excepción de la entrada del recurso principal. Si la entrada del recurso\n    principal no corresponde a un archivo real, entonces el recurso con la resolución\n    más baja se utilizará como respaldo para los dispositivos con proporciones de píxel del dispositivo\n    por debajo de esa resolución. Sin embargo, la entrada debe incluirse en el manifiesto <code>pubspec.yaml</code>.</p>\n\n  <h4 id=\"cargando-imagenes\">\n    Cargando imagenes</h4>\n\n  <p>Para cargar una imagen, usa la clase\n    <code>AssetImage</code> en el\n    método <code>build</code> de un Widget.</p>\n\n  <p>Por ejemplo, tu aplicación puede cargar la imagen de fondo de las declaraciones de\n    recursos anteriores:</p>\n\n    <pre><code>Widget build(BuildContext context) {\n  // ...\n  return DecoratedBox(\n    decoration: BoxDecoration(\n      image: DecorationImage(\n        image: AssetImage('graphics/background.png'),\n        // ...\n      ),\n      // ...\n    ),\n  );\n  // ...\n}\n</code></pre>\n\n  <p>Cualquier cosa que use el paquete de assets predeterminado heredará el conocimiento de\n    la resolución al cargar imágenes. (Si trabaja con algunas de las clases de\n    nivel inferior, como\n    <code>ImageStream</code>\n    o\n    <code>ImageCache</code>,\n    también notarás los parámetros relacionados con la escala).</p>\n\n  <h3>\n    Recursos de imágenes en paquetes</h3>\n\n  <p>Para cargar una imagen desde un\n    paquete, el argumento <code>package</code> se debe proporcionar a <code>AssetImage</code>.</p>\n\n  <p>Por ejemplo, supongamos que su aplicación depende de un paquete llamado <code>my_icons</code>, que tiene la siguiente estructura de directorio:</p>\n\n    <pre><code>  .../pubspec.yaml\n  .../icons/heart.png\n  .../icons/1.5x/heart.png\n  .../icons/2.0x/heart.png\n  ...etc.\n</code></pre>\n\n  <p>Entonces, para cargar la imágen, usa:</p>\n\n  <!-- skip -->\n    <pre><code> AssetImage('icons/heart.png', package: 'my_icons')\n</code></pre>\n\n  <p>Los recursos utilizados por el paquete en sí también se deben buscar usando el argumento <code>package</code> como se indica arriba.</p>\n\n  <h4 id=\"agrupando-recursos-de-un-paquete\">\n    Agrupando recursos de un paquete</h4>\n\n  <p>Si el recurso deseado se especifica en el archivo <code>pubspec.yaml</code> del paquete, se incluye automáticamente con la aplicación. En particular, los assets utilizados por el paquete en sí se deben especificar en su <code>pubspec.yaml</code>.</p>\n\n  <p>Un paquete también puede elegir tener activos en su carpeta <code>lib/</code> que no estén especificados en su archivo <code>pubspec.yaml</code>. En este caso, para que las imágenes se agrupen, la aplicación debe especificar cuáles incluir en su <code>pubspec.yaml</code>. Por ejemplo, un paquete nombrado <code>fancy_backgrounds</code> podría tener los siguientes archivos:</p>\n\n    <pre><code>  .../lib/backgrounds/background1.png\n  .../lib/backgrounds/background2.png\n  .../lib/backgrounds/background3.png\n</code></pre>\n\n  <p>Para incluir, por ejemplo, la primera imagen, el <code>pubspec.yaml</code> de la aplicación debe especificarla en la sección <code>assets</code>:</p>\n\n    <pre><code>flutter:\n  assets:\n    - packages/fancy_backgrounds/backgrounds/background1.png\n</code></pre>\n\n  <p>La <code>lib/</code> está implícita, por lo que no debe incluirse en la ruta del recurso.</p>\n\n  <h2>\n    Compartir recursos con la plataforma subyacente</h2>\n\n  <p>Los recursos de Flutter están disponibles para el código de la plataforma a través de AssetManager en Android y NSBundle en iOS.</p>\n\n  <h3>\n    Android</h3>\n\n  <p>En Android, los recursos están disponibles a través de la\n    API de AssetManager.\n    La clave de búsqueda utilizada, por ejemplo openFd se obtiene a partir de <code>lookupKeyForAsset</code>\n    en PluginRegistry.Registrar o <code>getLookupKeyForAsset</code> en\n    FlutterView. <code>PluginRegistry.Registrar</code> está disponible cuando se desarrolla\n    un complemento, mientras que <code>FlutterView</code> sería la opción al desarrollar una aplicación que incluye una vista de plataforma.</p>\n\n  <p>Como ejemplo, suponga que ha especificado esto en su pubspec.yaml</p>\n\n    <pre><code>flutter:\n  assets:\n    - icons/heart.png\n</code></pre>\n\n  <p>reflejando la siguiente estructura en su aplicación Flutter.</p>\n\n    <pre><code>  .../pubspec.yaml\n  .../icons/heart.png\n  ...etc.\n</code></pre>\n\n  <p>Para acceder a <code>icons/heart.png</code> desde tu código de complemento de Java, lo harías;</p>\n\n    <pre><code>AssetManager assetManager = registrar.context().getAssets();\nString key = registrar.lookupKeyForAsset(\"icons/heart.png\");\nAssetFileDescriptor fd = assetManager.openFd(key);\n</code></pre>\n\n  <h3>\n    iOS</h3>\n\n  <p>En iOS, los recursos están disponibles a través de\n    mainBundle. La clave de búsqueda utilizada, por ejemplo pathForResource:ofType:\n    se obtiene de <code>lookupKeyForAsset</code> o <code>lookupKeyForAsset:fromPackage:</code> en FlutterPluginRegistrar o\n    <code>lookupKeyForAsset:</code> o <code>lookupKeyForAsset:fromPackage:</code> en FlutterViewController.\n    <code>FlutterPluginRegistrar</code> está disponible cuando se desarrolla un complemento,\n    mientras que <code>FlutterViewController</code> sería la opción al desarrollar una aplicación que incluye una vista de plataforma.</p>\n\n  <p>Como ejemplo, supongamos que tiene la configuración de Flutter de arriba.</p>\n\n  <p>Para acceder <code>icons/heart.png</code> desde tu código de complemento Objective-C, lo haría;</p>\n\n    <pre><code>NSString* key = [registrar lookupKeyForAsset:@\"icons/heart.png\"];\nNSString* path = [[NSBundle mainBundle] pathForResource:key ofType:nil];\n</code></pre>\n\n  <p>Para obtener un ejemplo más completo, consulta la implementación\n    del plugin de video_player de Flutter.</p>\n\n  <h2>\n    Recursos de plataforma</h2>\n\n  <p>También habrá ocasiones para trabajar directamente con los recursos en los proyectos de la plataforma.\n    A continuación, se muestran dos casos comunes en los que se utilizan recursos antes de que se cargue y se ejecute el framework Flutter.</p>\n\n  <h3>\n    Actualizando el ícono de la aplicación</h3>\n\n  <p>La actualización del icono de inicio de la aplicación de Flutter funciona de la misma manera\n    que la actualización de iconos de inicio en aplicaciones nativas de Android o iOS.</p>\n\n  <p><img src=\"asset:assets/img/6_5_assets-and-images/icon.png\" alt=\"Launch icon\"></p>\n\n  <h4 id=\"android-1\">\n    Android</h4>\n\n  <p>En el directorio raíz de tu proyecto Flutter, ve a <code>.../android/app/src/main/res</code>. Las diversas\n    carpetas de recursos de mapa de bits como <code>mipmap-hdpi</code> ya contienen imágenes placeholder nombradas\n    <code>ic_launcher.png</code>. Simplemente reemplázalos con tus recursos deseados respetando el tamaño de icono\n    recomendado por densidad de pantalla según lo indicado por la\n    Guía del desarrollador de Android.</p>\n\n  <p><img src=\"asset:assets/img/6_5_android-icon-path.png\" alt=\"Android icon location\"></p>\n\n  \n    <p> <strong>Nota:</strong>\n      Si cambia el nombre de los archivos .png, también debe coincidir con el nuevo nombre en el\n      atributo <code>android:icon</code> de <code>AndroidManifest.xml</code> en su etiqueta <code>&lt;application&gt;</code>.</p>\n  \n\n  <h4 id=\"ios-1\">\n    iOS</h4>\n\n  <p>En el directorio raíz de tu proyecto Flutter, ve a <code>.../ios/Runner</code>. El directorio <code>Assets.xcassets/AppIcon.appiconset</code> ya contiene imágenes placeholder. Simplemente reemplácelos con las imágenes de tamaño adecuado según lo indicado por su nombre de archivo según lo dictado por las Pautas de interfaz humana de Apple. Mantener los nombres de los archivos originales.</p>\n\n  <p><img src=\"asset:assets/img/6_5_ios-icon-path.png\" alt=\"iOS icon location\"></p>\n\n  <h3>\n    Actualizando la pantalla de bienvenida</h3>\n\n  <p align=\"center\">\n    <img src=\"asset:assets/img/6_5_launch-screen.png\" alt=\"Launch screen\">\n  </p>\n\n  <p>Flutter también usa mecanismos de plataformas nativas para dibujar pantallas de lanzamiento de transición a su aplicación Flutter mientras se carga el framework Flutter. Esta pantalla de bienvenida continuará hasta que Flutter represente el primer frame de tu aplicación.</p>\n\n  \n    <p> <strong>Nota:</strong>\n      Esto implica que si no llamas a\n      runApp en\n      la función <code>void main()</code> de tu aplicación (o más específicamente, si no llamas a\n      <code>window.render</code>\n      en respuesta a\n      <code>window.onDrawFrame</code>),\n      la pantalla de bienvenida se mantendrá para siempre.</p>\n  \n\n  <h4 id=\"android-2\">\n    Android</h4>\n\n  <p>Para agregar una “pantalla de bienvenida” a tu aplicación Flutter, ve a <code>.../android/app/src/main</code>. En <code>res/drawable/launch_background.xml</code>, puedes usar esta layer list drawable XML para personalizar el aspecto de su pantalla de bienvenida. La plantilla existente proporciona un ejemplo para agregar una imagen a la mitad de una pantalla blanca en el código comentado. Puedes descomentarlo o usar otros objetos drawables para lograr el efecto deseado.</p>\n\n  <h4 id=\"ios-2\">\n    iOS</h4>\n\n  <p>Para agregar una imagen al centro de tu “pantalla de bienvenida”, ve a <code>.../ios/Runner</code>. En, <code>Assets.xcassets/LaunchImage.imageset</code>, coloca imágenes llamadas <code>LaunchImage.png</code>, <code>LaunchImage@2x.png</code>, <code>LaunchImage@3x.png</code>. Si usas diferentes nombres de archivo, también deberás actualizar el archivo <code>Contents.json</code> en el mismo directorio.</p>\n\n  <p>También puedes personalizar completamente tu storyboard de pantalla de bienvenida en Xcode abriendo <code>.../ios/Runner.xcworkspace</code>. Navega hasta <code>Runner/Runner</code> en el Navegador de proyectos y coloca las imágenes abriendo <code>Assets.xcassets</code> o realiza cualquier personalización usando el Constructor de interfaces en <code>LaunchScreen.storyboard</code>.</p>\n\n  <p><img src=\"asset:assets/img/6_5_ios-launchscreen-xcode.png\" alt=\"Adding launch icons in Xcode\"></p>"
  }
]