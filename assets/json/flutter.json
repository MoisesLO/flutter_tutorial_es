[
    {
        "title": "1.1 Instalación en Windows",
        "subtitle": "Introduccion",
        "content": "<main>\n    <div>\n        <div>\n            <header> Contenidos</header>\n            <ul>\n                <li>Requerimientos del Sistema</li>\n                <li>Obtener el SDK de Flutter\n                    <ul>\n                        <li>Actualizando tu “path”</li>\n                        <li>Ejecuta flutter doctor</li>\n                    </ul>\n                </li>\n                <li>Configuración de Android\n                    <ul>\n                        <li>Instalar Android Studio</li>\n                        <li>Configurar tu dispositivo Android</li>\n                        <li>Configurar el emulador de Android</li>\n                    </ul>\n                </li>\n                <li>Siguiente paso</li>\n            </ul>\n        </div>\n        <h2><span></span>Requerimientos del Sistema</h2>\n        <p>Para instalar y ejecutar Flutter, el ambiente de trabajo debe de cumplir al menos con los\n            siguientes requerimientos:</p>\n        <ul>\n            <li><strong>Sistema Operativo</strong>: Windows 7 SP1 o superior (64-bit)</li>\n            <li><strong>Espacio en Disco</strong>: 400 MB (no incluye espacio en disco para\n                IDE/herramientas).\n            </li>\n            <li><strong>Herramientas</strong>: Flutter depende de que estas herramientas estén\n                disponibles en tu entorno.\n                <ul>\n                    <li>Windows PowerShell 5.0 o superior (este es pre-instalado con Windows\n                        10)\n                    </li>\n                    <li><p>Git para Windows 2.x, con la opción <strong>Use Git from the\n                        Windows Command Prompt</strong></p>\n                        <p>Si Git para Windows está ya instalado, asegúrate de poder correr comandos\n                            con <code>git</code> desde el Command Prompt o PowerShell.</p></li>\n                </ul>\n            </li>\n        </ul>\n        <h2><span></span>Obtener el SDK de Flutter</h2>\n        <ol>\n            <li><p>Descarga el siguiente paquete de instalación para obtener la versión más reciente\n                stable release del SDK Flutter:</p>\n                <p>flutter_windows_1.20.3-stable.zip</p>\n                <p>Para otros release channels, y compilaciones más viejas, mira la página SDK\n                    archive.</p></li>\n            <li>Extraiga el archivo zip y coloque el contenido de <code>flutter</code> en la\n                ubicación deseada de instalación para el Flutter SDK (ej.\n                <code>C:\\src\\flutter</code>; no instale flutter en un directorio como <code>C:\\Program\n                    Files\\</code> que requiere permisos de administrador).\n            </li>\n            <li>Localice el archivo <code>flutter_console.bat</code> dentro del directorio de <code>flutter</code>.\n                Inícialo con doble clic.\n            </li>\n        </ol>\n        <p>¡Ahora está todo listo para ejecutar los comandos de Flutter en la consola de\n            Flutter!</p>\n        <p>Para actualizar una versión existente de Flutter, vea Actualizando Flutter.</p>\n        <h3><span></span>Actualizando tu “path”</h3>\n        <p>Si deseas ejecutar los comandos de Flutter en un ventana de comandos regular de Windows,\n            siga estos pasos y agregue Flutter a las variables de entorno en el <code>PATH</code>:\n        </p>\n        <ul>\n            <li>Desde la barra de busqueda en Inicio, escribe ‘env’ y selecciona <strong>Editar\n                variables de entorno para tu cuenta</strong></li>\n            <li>Debajo de <strong>Variables de usuario</strong> verifica si existe una entrada\n                llamada <strong>Path</strong>:\n                <ul>\n                    <li>Si la entrada existe, agrega la ruta completa a <code>flutter\\bin</code>\n                        usando <code>;</code> como separador de los valores existentes.\n                    </li>\n                    <li>Si la entrada no existe, crea una nueva variable de usuario llamada <code>Path</code>\n                        con la ruta completa <code>flutter\\bin</code> como su valor.\n                    </li>\n                </ul>\n            </li>\n        </ul>\n        <p>Ten en cuenta que tendrás que cerrar y reabrir cualquier ventana de consola existente\n            para que estos cambios surtan efecto.</p>\n        <h3><span></span>Ejecuta <code>flutter doctor</code></h3>\n        <p>Desde una ventana de consola que tenga el directorio Flutter en su path (ver arriba),\n            ejecuta el siguiente comando para ver si hay algunas dependencias de la plataforma que\n            necesites para completar la configuración:</p>\n        <div>\n            <div>\n                <div>\n                    <button><i>content_copy</i></button>\n                    <div> <pre><code><span>C:\\src\\flutter></span>flutter doctor\n</code></pre>\n                    </div>\n                </div>\n            </div>\n        </div>\n        <p>Este comando verifica tu entorno y muestra un reporte del estado de tu instalación de\n            Flutter. Verifica la salida con cuidado para otros programas que pudieras necesitar o\n            tareas a realizar (mostradas en texto en <strong>negrita</strong>).</p>\n        <p>Por Ejemplo:</p>\n        <div>\n            <button><i>content_copy</i></button>\n            <div> <pre>[-] Android toolchain - develop for Android devices\n  • Android SDK at D:\\Android\\sdk\n  <strong>✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</strong>\n  • Try re-installing or updating your Android SDK,\n    visit https://flutter.io/setup/#android-setup for detailed instructions.\n</pre>\n            </div>\n        </div>\n        <p>La siguiente sección describe como desempeñar estas tareas y finalizar el proceso de\n            configuración. Una vez que tenga instalado cualquiera de las dependencias faltantes,\n            puedes ejecutar el comando <code>flutter doctor</code> de nuevo para verificar que todo\n            se ha configurado correctamente.</p>\n        <p>Las herramienta <code>flutter</code> usa\n            Google Analytics para, anónimamente, reportar estadísticas de características de uso y\n            reportes básicos de errores. Estos datos son utilizados para ayudar a mejorar las\n            herramientas de Flutter con el tiempo. Analytics no envía cada ejecución o cualquier\n            ejecución dentro del <code>flutter config</code>, por lo que puede optar por no\n            participar\n            en los análisis antes de enviar los datos. Para deshabilitar los reportes, teclee <code>flutter\n                config --no-analytics</code> y para mostrar la configuración actual, teclee <code>flutter\n                config</code>. Vea la Privacy Policy de Google</p></aside> <h2>\n        <span></span>Configuración de Android</h2>\n        <p><i></i> <strong>Nota:</strong>\n            Flutter requiere de una completa instalación de Android Studio para proveer las\n            dependencias\n            de la plataforma de Android. De cualquier manera, puede desarrollar sus apps de Flutter\n            en\n            diferentes editores; hablaremos de ello en un paso siguiente.</p></aside> <h3>\n        <span></span>Instalar Android Studio</h3>\n        <ol>\n            <li>Descarga e instala Android Studio.</li>\n            <li>Inicia Android Studio, y sigue todo el ‘Android Studio Setup Wizard’. Este Instalará\n                la versión más reciente de Android SDK, Android SDK Platform-Tools y Android SDK\n                Build-Tools, Las cuales son requeridas por Flutter cuando se desarrolla para\n                Android.\n            </li>\n        </ol>\n        <h3><span></span>Configurar tu dispositivo Android</h3>\n        <p>Prepara la ejecución y pruebas de app de Flutter en un dispositivo de Android, necesitará\n            un dispositivo Android ejecutando Android 4.1 (API nivel 16) o superior.</p>\n        <ol>\n            <li>Habilita <strong>Opciones de desarrollador</strong> y <strong>Depurador por\n                USB</strong> en tu dispositivo. Instrucciones detalladas están disponibles en la\n                Documentación\n                de Android.\n            </li>\n            <li>Solo en Windows: Instala Google USB Driver</li>\n            <li>Utilizando el cable USB, conecta tu móvil de la computadora, de requerirse en tu\n                dispositivo, autoriza el acceso de la computadora a tu dispositivo.\n            </li>\n            <li>En terminal, ejecuta el comando <code>flutter devices</code> para verificar que\n                Flutter ha reconocido tu dispositivo Android conectado.\n            </li>\n        </ol>\n        <p>Por defecto, Flutter utiliza la versión SDK de Android donde se encuentren las\n            herramientas <code>adb</code>. Si quieres que Flutter utilice alguna instalación\n            diferente del SDK de Android, deberás configurar la variable de entorno <code>ANDROID_HOME</code>\n            en el directorio de instalación. </p>\n        <h3><span></span>Configurar el emulador de Android</h3>\n        <p>Prepare la ejecución y pruebas de app de Flutter en el emulador de Android, siguiendo\n            estos pasos: </p>\n        <ol>\n            <li>Habilita VM acceleration en tu equipo.</li>\n            <li>Abra <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> y selecciona\n                <strong>Create Virtual Device</strong>. (El submenú <strong>Android</strong> está\n                presente solo cuando se encuentra dentro de un proyecto de Android.)\n            </li>\n            <li>Elija un dispositivo y seleccione <strong>Next</strong>.</li>\n            <li>Selecciona una o más imágenes del sistema que quieres emular, y selecciona <strong>Next</strong>.\n                Una imagen <em>x86</em> o <em>x86_64</em> es recomendada.\n            </li>\n            <li>Dentro de Emulated Performance, selecciona <strong>Hardware - GLES 2.0</strong> para\n                habilitarlo aceleración de hardware.\n            </li>\n            <li><p>Verifica que la configuración de AVD es correcta, y selecciona\n                <strong>Finish</strong>.</p>\n                <p>Para mayor detalle de los pasos de arriba, vea Administrando AVDs.</p>\n            </li>\n            <li>En el Administrador de Dispositivos Virtuales de Android (AVD), da clic en la barra\n                de herramienta <strong>Run</strong>. El emulador iniciará el arranque y mostrara el\n                lienzo (canvas) por defecto para la versión del SO y dispositivo seleccionado.\n            </li>\n        </ol>\n        <h2><span></span>Siguiente paso</h2>\n        <p>Siguiente paso: Configura el editor</p>\n        <nav>\n            <ul>\n                <li>Configurar un editor</li>\n            </ul>\n        </nav>\n    </div>\n</main>"
    },
    {
        "title": "1.2 Instalación en Linux",
        "subtitle": "Introduccion",
        "content": "<div>\n    <h1>Instalación en macOS</h1>\n    <div>\n        <header>\n            Contenidos\n        </header>\n        <ul>\n            <li>Requerimiento del sistema</li>\n            <li>Obtener el SDK de Flutter\n                <ul>\n                    <li>Ejecuta flutter doctor</li>\n                    <li>Actualiza tu path</li>\n                </ul>\n            </li>\n            <li>Configurar plataforma</li>\n            <li>Configuración de iOS\n                <ul>\n                    <li>Instalar Xcode</li>\n                    <li>Configurar el simulador iOS</li>\n                    <li>Crea y ejecuta una app simple en Flutter</li>\n                    <li>Desplegar en dispositivos iOS</li>\n                </ul>\n            </li>\n            <li>Configuración de Android\n                <ul>\n                    <li>Instalar Android Studio</li>\n                    <li>Configurar tu dispositivo Android</li>\n                    <li>Configurar el emulador de Android</li>\n                </ul>\n            </li>\n            <li>Siguiente paso</li>\n        </ul>\n    </div>\n    <h2>Requerimiento del sistema</h2>\n    <p>Para instalar y ejecutar Flutter, tu entorno de trabajo debe cumplir los siguientes\n        requisitos mínimos:</p>\n    <ul>\n        <li>\n            <strong>Sistema Operativo</strong>: macOS (64-bit)\n        </li>\n        <li>\n            <strong>Espacio en disco</strong>: 700 MB (Esto no incluye el espacio en disco para\n            IDE/tools).\n        </li>\n        <li>\n            <strong>Herramientas</strong>: Flutter necesita que estas herramientas de línea de\n            comando estén disponibles en tu entorno.\n            <ul>\n                <li><code>bash</code></li>\n                <li><code>mkdir</code></li>\n                <li><code>rm</code></li>\n                <li><code>git</code></li>\n                <li><code>curl</code></li>\n                <li><code>unzip</code></li>\n                <li><code>which</code></li>\n            </ul>\n        </li>\n    </ul>\n    <h2>\n        Obtener el SDK de Flutter</h2>\n    <ol>\n        <li>\n            <p>Descarga el siguiente paquete de instalación para obtener la versión más reciente\n                stable release del\n                SDK Flutter:</p>\n            <p>flutter_macos_1.20.3-stable.zip</p>\n            <p>Para otros release channels, y compilaciones más viejas, mira la página SDK\n                archive.</p>\n        </li>\n        <li>\n            <p>Extraiga el archivo en la ubicación deseada, por ejemplo:</p>\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code> $ cd ~/development\n$ unzip ~/Downloads/flutter_macos_1.20.3-stable.zip\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Agrega la herramienta <code>flutter</code> a tu path:</p>\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div>\n                            <pre><code> $ export PATH=\"$PATH:`pwd`/flutter/bin\"</code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <p>Este comando configura tu variable <code>PATH</code> sólo\n                para la ventana <em>actual</em> de terminal.\n                Para agregar Flutter permanentemente a tu path, mira Actualiza<br>\n                el path.</p>\n        </li>\n        <li>\n            <p>Opcionalmente, pre-descarga binarios de desarrollo:</p>\n            <p>La herramienta <code>flutter</code> descarga binarios de\n                desarrollo específicos de plataforma según\n                los necesita. Para escenarios en los que pre-descargar estos artefactos es\n                preferible\n                (ej., entornos de compilación herméticos, disponibilidad de red intermitente), los\n                binarios iOS\n                y Android pueden ser descargados por anticipado ejecutando:</p>\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div>\n                            <pre><code> $ flutter precache</code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n            <p>Para opciones adicionales de descarga, mira <code>flutter\n                help precache</code>.</p>\n        </li>\n    </ol>\n    <p>¡Ahora estas preparado para ejecutar comandos de Flutter!</p>\n    <p><strong>Nota:</strong>\n        Para actualizar una versión existente de Flutter, mira\n        Actualizando Flutter.</p>\n    </aside>\n    <h3>Ejecuta flutter doctor</h3>\n    <p>Ejecuta el siguiente comando para verificar si existe alguna dependencia que se necesite para\n        completar la configuración (para una salida detallada, añade la etiqueta <code>-v</code>):\n    </p>\n    <div>\n        <div>\n            <div>\n                <button>content_copy</button>\n                <div><pre><code>$ flutter doctor\n    </code></pre>\n                </div>\n            </div>\n        </div>\n    </div>\n    <p>Este comando verifica tu entorno y muestra un reporte en la ventana del terminal.\n        El SDK de Dart esta empaquetado con Flutter, no es necesario instalar Dart por separado.\n        Verifica la salida con cuidado para otros programas que\n        pudieras necesitar o tareas a realizar (mostradas en texto en <strong>negrita</strong>).</p>\n    <p>Por ejemplo:</p>\n    <div>\n        <button>content_copy</button>\n        <div>\n            <pre>[-] Android toolchain - develop for Android devices\n• Android SDK at /Users/obiwan/Library/Android/sdk\n<strong>✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</strong>\n• Try re-installing or updating your Android SDK, visit https://flutter.io/setup/#android-setup for detailed instructions.\n    </pre>\n        </div>\n    </div>\n\n    <p>La siguiente sección describe cómo desempeñar estas tareas y finalizar el proceso de\n        configuración.</p>\n\n    <p>Una vez que tengaS instalado cualquiera de las dependencias faltantes, ejecuta el comando\n        <code>flutter doctor</code>\n        de nuevo para verificar que todo se ha configurado correctamente.</p>\n\n\n    <p>Las herramienta <code>flutter</code> usa Google Analytics para,\n        anónimamente, reportar estadísticas de\n        características de uso y reportes básicos de errores. Estos datos son utilizados para ayudar\n        a mejorar las herramientas de Flutter con el tiempo.\n        Analytics no envía cada ejecución o cualquier ejecución dentro del <code>flutter\n            config</code>,\n        por lo que puede optar por no participar en los análisis antes de enviar los datos. Para\n        deshabilitar los reportes,\n        teclee <code>flutter config --no-analytics</code> y para mostrar\n        la\n        configuración actual, teclee <code>flutter config</code>. Vea la\n        Privacy Policy de Google</p>\n\n    </aside>\n\n    <h3>\n        Actualiza tu path</h3>\n\n    <p>Se puede actualizar tu variable PATH para sólo para la sesión actual en la línea de comandos,\n        como se muestra en Obtener Flutter SDK. Probablemente necesitarás\n        actualizar esta variable permanentemente, de esta manera podrás ejecutar el comando <code>flutter</code>\n        en cualquier sesión de terminal.</p>\n\n    <p>Los pasos para modificar esta variable permanentemente para todas las sesiones de terminal\n        son específicas del equipo.\n        Típicamente se agrega una línea al archivo que se ejecuta cada que abres\n        una nueva ventana. Por ejemplo:</p>\n\n    <ol>\n        <li>Determine el directorio donde se encuentra el SDK de Flutter.\n            Necesitaras esto en el paso 3.\n        </li>\n        <li>Abre (o crea) <code>$HOME/.bash_profile</code>. La dirección\n            del archivo\n            puede estar en un lugar diferente en tu equipo.\n        </li>\n        <li>Agrega la siguiente línea y cambia <code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code>\n            para ser\n            la ruta donde has clonado el repositorio de Flutter:\n        </li>\n    </ol>\n\n    <p><code>terminal\n        $ export PATH=\"$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin\"\n    </code></p>\n\n    <ol>\n        <li>Ejecuta <code>source $HOME/.bash_profile</code> para refrescar\n            la ventana actual.\n        </li>\n        <li>\n            <p>Verifica que el directorio de <code>flutter/bin</code> esta\n                en tu PATH ejecutando el siguiente comando:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ echo $PATH\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n    </ol>\n\n    <p>Para más detalles, ver Estas preguntas en StackExchange.</p>\n\n    <h2>\n        Configurar plataforma</h2>\n\n    <p>macOS permite desarrollar apps con Fluter para ambos iOS y Android. Termina al menos\n        una de las configuraciones para las plataformas ahora, para poder ser capaz de crear y\n        ejecutar\n        su primera app en Flutter.</p>\n\n    <h2>\n        Configuración de iOS</h2>\n\n    <h3>\n        Instalar Xcode</h3>\n\n    <p>Para desarrollar apps con Flutter en iOS, necesitaras una Mac con Xcode 9.0 o más\n        reciente:</p>\n\n    <ol>\n        <li>Instalar Xcode 9.0 o más reciente (vía descarga web o\n            Mac App Store).\n        </li>\n        <li>\n            <p>Configurar la línea de comandos de Xcode para usar el recién versión recién instalada\n                de Xcode\n                ejecutando lo siguiente desde la línea de comandos:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n    </ol>\n\n    <p>Esta es el directorio correcto la mayoría de casos, cuando quiera hacer uso de la versión más\n        reciente de Xcode.\n        Si necesita usar una versión diferente, especifique esa dirección en su lugar.</p>\n    <ol>\n        <li>Asegúrese de firmar el acuerdo de licencia de Xcode abriendo por primera vez y\n            confirmando o\n            ejecutando <code>sudo xcodebuild -license</code> desde la\n            línea de comando.\n        </li>\n    </ol>\n\n    <p>Con Xcode, serás capaz de ejecutar apps de Flutter en un dispositivo o un simulador.</p>\n\n    <h3>\n        Configurar el simulador iOS</h3>\n\n    <p>Para preparar la ejecución y probar tu app de Flutter en el simulador de iOS, siga estos\n        pasos:</p>\n\n    <ol>\n        <li>\n            <p>En su Mac, encuentre el simulador vía Spotlight o utilizando el siguiente\n                comando:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ open -a Simulator</code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>Asegura que el simulador utilizado este utilizando un dispositivo de 64 bits (iPhone 5s\n            o superior) verificando la configuración\n            en el menú del simulador <strong>Hardware &gt; Device</strong>.\n        </li>\n        <li>Dependiendo del tamaño de la pantalla de la máquina de desarrollo, se simulará la\n            calidad en la pantalla de tu dispositivo iOS el cual\n            podría desbordar la pantalla, configura la escala del dispositivo en el menú <strong>Window\n                &gt; Scale</strong> en el simulador.\n        </li>\n    </ol>\n\n    <h3>\n        Crea y ejecuta una app simple en Flutter</h3>\n\n    <p>Para crear tu primera app Flutter y probar tu configuración, sigue los siguientes pasos:</p>\n\n    <ol>\n        <li>\n            <p>Crea una nueva app Flutter ejecutando lo siguiente en la línea de comandos:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ flutter create my_app\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Un directorio <code>my_app</code> se ha creado, conentiendo\n                la app de inicio de Flutter. Entra en este directorio:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ cd my_app\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Para lanzar la app en el Simulador, asegurate que el Simulador esta ejecutándose e\n                introduce:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ flutter run\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n    </ol>\n\n    <h3>\n        Desplegar en dispositivos iOS</h3>\n\n    <p>Para desplegar tu app de Flutter en un dispositivo físico de iOS, necesitarás algunas\n        herramientas extras y una cuenta de Apple. También necesitarás configurar el dispositivo\n        físico para despegarlo en Xcode.</p>\n\n    <ol>\n        <li>Instalar homebrew.</li>\n        <li>\n            <p>Asegúrate que homebrew esta actualizado:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ brew update\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </li>\n        <li>\n            <p>Instala las herramientas para desplegar las apps de Flutter en dispositivos iOS\n                ejecutando los siguientes comandos:</p>\n\n            <div>\n                <div>\n                    <div>\n                        <button>content_copy\n                        </button>\n                        <div><pre><code>$ brew install --HEAD usbmuxd\n    $ brew link usbmuxd\n    $ brew install --HEAD libimobiledevice\n    $ brew install ideviceinstaller ios-deploy cocoapods\n    $ pod setup\n    </code></pre>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n\n            <p><strong>Nota:</strong>\n                Los primeros dos comandos arriba son necesarios como un\n                arreglo temporal hasta que el nuevo lanzamiento de libusbmuxd, como se explica en\n                libusbmuxd issue #46 y\n                Flutter issue #22595.</p>\n\n            </aside>\n\n            <p>Si cualquiera de estos comandos falla con error, ejecuta <code>brew doctor</code> y\n                sigue las instrucciones\n                para resolver el problema.</p>\n        </li>\n        <li>\n            <p>Continua con el flujo de registro en Xcode para provisionar tu proyecto:</p>\n\n            <ol>\n                <li>Abre el espacio de trabajo por defecto en tu proyecto ejecutando <code>open\n                    ios/Runner.xcworkspace</code> en una ventana de terminal del directorio donde\n                    está el proyecto\n                    de Flutter.\n                </li>\n                <li>En Xcode, selecciona el proyecto <code>Runner</code>\n                    en el panel de navegación del lado izquierdo.\n                </li>\n                <li>\n                    <p>En la página de configuración de <code>Runner</code>, asegúrate que tu equipo\n                        de\n                        desarrollo esta seleccionado debajo de <strong>General &gt; Signing &gt;\n                            Team</strong>.\n                        Cuando seleccionas un equipo, Xcode crea y descarga un Certificado de\n                        Desarrollo, registra tu dispositivo a tu cuenta, y crea y descarga\n                        un perfil provisional (de necesitarse).</p>\n\n                    <ul>\n                        <li>\n                            <p>Para empezar tu primer proyecto de desarrollo en iOS, necesitarás\n                                registrarte en\n                                Xcode con tu ID de Apple.<img src=\"/images/setup/xcode-account.png\"\n                                                              alt=\"Xcode account add\"\n                                                              class=\"mw-100\">\n                                Hay soporte en desarrollo y pruebas para cualquier ID de Apple.\n                                Enrolarte en el\n                                programa de desarrolladores de Apple es necesario para distribuir tu\n                                app en el App\n                                Store. Ver la eligiendo un Membership.</p>\n                        </li>\n                        <li>\n                            <p>La primera ocasiones que utilices un dispositivo físico\n                                para desarrollo iOS, necesitarás autorizar ambas tu Mac y tu\n                                Certificado de\n                                Desarrollo en el dispositivo. Selecciona <code>Trust</code> en la\n                                ventana que te\n                                muestra la\n                                primera vez que es conectado tu dispositivo iOs a tu Mac.</p>\n\n                            <p><img src=\"/images/setup/trust-computer.png\" alt=\"Trust Mac\"\n                                    class=\"mw-100\"></p>\n\n                            <p>Ahora, ve a la configuración de la app en el dispositivo iOS,\n                                selecciona <strong>General &gt; Device Management</strong> y\n                                autoriza el Certificado.</p>\n                        </li>\n                        <li>\n                            <p>Si tu registro automático falla en Xcode, verifica que el valor del\n                                proyecto sea único\n                                <strong>General &gt; Identity &gt; Bundle Identifier</strong>.\n                                <br>\n                                <img src=\"/images/setup/xcode-unique-bundle-id.png\"\n                                     alt=\"Check the app's Bundle ID\" class=\"mw-100\"></p>\n                        </li>\n                    </ul>\n                </li>\n            </ol>\n        </li>\n        <li>Iniciatu app ejecutando el comando <code>flutter run</code>.\n        </li>\n    </ol>\n\n    <h2>\n        Configuración de Android</h2>\n\n\n    <p><strong>Nota:</strong>\n        Flutter requiere de una completa instalación de Android Studio para proveer\n        las dependencias de la plataforma de Android. De cualquier manera, puede desarrollar sus\n        apps de Flutter en diferentes editores; hablaremos de ello en un paso siguiente.</p>\n    </aside>\n\n    <h3>\n        Instalar Android Studio</h3>\n\n    <ol>\n        <li>Descarga e instala Android Studio.</li>\n        <li>Inicia Android Studio, y sigue todo el ‘Android Studio Setup Wizard’. Este\n            Instalará la versión más reciente de Android SDK, Android SDK Platform-Tools y\n            Android SDK Build-Tools, Las cuales son requeridas por Flutter cuando se desarrolla para\n            Android.\n        </li>\n    </ol>\n\n    <h3>\n        Configurar tu dispositivo Android</h3>\n\n    <p>Prepara la ejecución y pruebas de app de Flutter en un dispositivo de Android, necesitará\n        un dispositivo Android ejecutando Android 4.1 (API nivel 16) o superior.</p>\n\n    <ol>\n        <li>Habilita <strong>Opciones de desarrollador</strong> y <strong>Depurador por USB</strong>\n            en tu dispositivo. Instrucciones detalladas\n            están disponibles en la Documentación de Android.\n        </li>\n        <li>Solo en Windows: Instala Google USB Driver\n        </li>\n        <li>Utilizando el cable USB, conecta tu móvil de la computadora, de requerirse en tu\n            dispositivo, autoriza el acceso de la computadora a tu dispositivo.\n        </li>\n        <li>En terminal, ejecuta el comando <code>flutter devices</code>\n            para verificar que Flutter ha reconocido\n            tu dispositivo Android conectado.\n        </li>\n    </ol>\n\n    <p>Por defecto, Flutter utiliza la versión SDK de Android donde se encuentren las herramientas\n        <code>adb</code>. Si\n        quieres que Flutter utilice alguna instalación diferente del SDK de Android, deberás\n        configurar\n        la variable de entorno <code>ANDROID_HOME</code> en el directorio\n        de instalación.</p>\n\n    <h3>\n        Configurar el emulador de Android</h3>\n\n    <p>Prepare la ejecución y pruebas de app de Flutter en el emulador de Android, siguiendo estos\n        pasos:</p>\n\n    <ol>\n        <li>Habilita VM acceleration en tu equipo.</li>\n        <li>Abra <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> y selecciona\n            <strong>Create Virtual Device</strong>. (El submenú <strong>Android</strong> está\n            presente solo\n            cuando se encuentra dentro de un proyecto de Android.)\n        </li>\n        <li>Elija un dispositivo y seleccione <strong>Next</strong>.</li>\n        <li>Selecciona una o más imágenes del sistema que quieres emular,\n            y selecciona <strong>Next</strong>. Una imagen <em>x86</em> o <em>x86_64</em> es\n            recomendada.\n        </li>\n        <li>Dentro de Emulated Performance, selecciona <strong>Hardware - GLES 2.0</strong> para\n            habilitarlo\n            aceleración de hardware.\n        </li>\n        <li>\n            <p>Verifica que la configuración de AVD es correcta, y selecciona\n                <strong>Finish</strong>.</p>\n\n            <p>Para mayor detalle de los pasos de arriba, vea Administrando AVDs.</p>\n        </li>\n        <li>En el Administrador de Dispositivos Virtuales de Android (AVD), da clic en la barra de\n            herramienta <strong>Run</strong>.\n            El emulador iniciará el arranque y mostrara el lienzo (canvas) por defecto para la\n            versión del SO y dispositivo seleccionado.\n        </li>\n    </ol>\n</div>"
    },
    {
        "title": "1.3 Instalación en Mac",
        "subtitle": "Introduccion",
        "content": "<div>\n    <h1>Instalación en Linux</h1>\n    <div>\n        <header class=\"site-toc__title\">\n            Contenidos\n        </header>\n        <ul class=\"section-nav\">\n            <li>Requerimiento del Sistema</li>\n            <li>Obtener el SDK de Flutter\n                <ul>\n                    <li>Ejecuta flutter doctor</li>\n                    <li>Actualiza tu path</li>\n                </ul>\n            </li>\n            <li>Configuración de Android\n                <ul>\n                    <li>Instalar Android Studio</li>\n                    <li>Configurar tu dispositivo Android</li>\n                    <li>Configurar el emulador de Android</li>\n                </ul>\n            </li>\n            <li>Siguiente paso</li>\n        </ul>\n    </div>\n    <h2>\n        Requerimiento del Sistema</h2>\n\n    <p>Para instalar y ejecutar Flutter, el entorno de trabajo debe estos requisitos mínimos:</p>\n\n    <ul>\n        <li>\n            <strong>Sistema Operativo</strong>: Linux (64-bit)</li>\n        <li>\n            <strong>Espacio en Disco</strong>: 600 MB (no incluye espacio en disco para IDE/herramientas).</li>\n        <li>\n            <strong>Herramientas</strong>: Flutter  depende de que estas herramientas estén disponibles en tu entorno.\n            <ul>\n                <li><code>bash</code></li>\n                <li><code>curl</code></li>\n                <li>\n                    <code>git</code> 2.x</li>\n                <li><code>mkdir</code></li>\n                <li><code>rm</code></li>\n                <li><code>unzip</code></li>\n                <li><code>which</code></li>\n                <li><code>xz-utils</code></li>\n            </ul>\n        </li>\n        <li>\n            <strong>Bibliotecas Compartidas</strong>: El comando <code>test</code> en Flutter  depende de que estas bibliotecas estén disponibles en tu entorno.\n            <ul>\n                <li>\n                    <code>libGLU.so.1</code> -  suministrada por mesa packages ej. <code>libglu1-mesa</code> en Ubuntu/Debian</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>\n        Obtener el SDK de Flutter</h2>\n\n    <ol>\n        <li>\n            <p>Descarga el siguiente paquete de instalación para obtener la versión más reciente stable release del\n                SDK Flutter:</p>\n\n            <p>flutter_linux_1.20.3-stable.tar.xz</p>\n\n            <p>Para otros release channels, y compilaciones más viejas, mira la página SDK\n                archive.</p>\n        </li>\n        <li>\n            <p>Extraiga el archivo en la ubicación deseada, por ejemplo:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code> $ cd ~/development\n $ tar xf ~/Downloads/flutter_linux_1.20.3-stable.tar.xz\n</code></pre></div></div></div>    </div>\n        </li>\n        <li>\n            <p>Agrega la herramienta <code>flutter</code> a tu path:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code> $ export PATH=\"$PATH:`pwd`/flutter/bin\"\n</code></pre></div></div></div>    </div>\n\n            <p>Este comando configura tu variable <code>PATH</code> sólo para la ventana <em>actual</em> de terminal.\n                Para agregar Flutter permanentemente a tu path, mira Actualiza<br>\n                    el path.</p>\n        </li>\n        <li>\n            <p>Opcionalmente, pre-descarga binarios de desarrollo:</p>\n\n            <p>La herramienta <code>flutter</code> descarga binarios de desarrollo específicos de plataforma según\n                los necesita. Para escenarios en los que pre-descargar estos artefactos es preferible\n                (ej., entornos de compilación herméticos, disponibilidad de red intermitente), los binarios iOS\n                y Android pueden ser descargados por anticipado ejecutando:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code> $ flutter precache\n</code></pre></div></div></div>    </div>\n\n            <p>Para opciones adicionales de descarga, mira <code>flutter help precache</code>.</p>\n        </li>\n    </ol>\n\n    <p>¡Ahora estas preparado para ejecutar comandos de Flutter!</p>    \n        <p><i class=\"fas fa-info-circle\"></i> <strong>Nota:</strong>\n            Para actualizar una versión existente de Flutter, mira\n            Actualizando Flutter.</p>\n    </aside>\n\n    <h3 id=\"ejecuta-flutter-doctor\">\n        Ejecuta flutter doctor</h3>\n\n    <p>Ejecuta el siguiente comando para verificar si existe alguna dependencia que se necesite para\n        completar la configuración (para una salida detallada, añade la etiqueta <code>-v</code>):</p>\n\n    <div><div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code>$ flutter doctor\n</code></pre></div></div></div></div>\n\n    <p>Este comando verifica tu entorno y muestra un reporte en la ventana del terminal.\n        El SDK de Dart esta empaquetado con Flutter, no es necesario instalar Dart por separado.\n        Verifica la salida con cuidado para otros programas que\n        pudieras necesitar o tareas a realizar (mostradas en texto en <strong>negrita</strong>).</p>\n\n    <p>Por ejemplo:</p>\n    <div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre>[-] Android toolchain - develop for Android devices\n    • Android SDK at /Users/obiwan/Library/Android/sdk\n    <strong>✗ Android SDK is missing command line tools; download from https://goo.gl/XxQghQ</strong>\n    • Try re-installing or updating your Android SDK,\n      visit https://flutter.io/setup/#android-setup for detailed instructions.\n</pre></div></div>\n\n    <p>La siguiente sección describe cómo desempeñar estas tareas y finalizar el proceso de configuración.</p>\n\n    <p>Una vez que tengaS instalado cualquiera de las dependencias faltantes, ejecuta el comando <code>flutter doctor</code>\n        de nuevo para verificar que todo se ha configurado correctamente.</p>    \n        <p>Las herramienta <code>flutter</code> usa Google Analytics para, anónimamente, reportar estadísticas de\n            características de uso y reportes básicos de errores. Estos datos son utilizados para ayudar a mejorar las herramientas de Flutter con el tiempo.\n            Analytics no envía cada ejecución o cualquier ejecución dentro del <code>flutter config</code>,\n            por lo que puede optar por no participar en los análisis antes de enviar los datos. Para deshabilitar los reportes,\n            teclee <code>flutter config --no-analytics</code> y para mostrar la\n            configuración actual, teclee <code>flutter config</code>. Vea la Privacy Policy de Google</p>\n\n    </aside>\n\n    <h3 id=\"actualiza-tu-path\">\n        Actualiza tu path</h3>\n\n    <p>Se puede actualizar tu variable PATH para sólo para la sesión actual en la línea de comandos,\n        como se muestra en Obtener Flutter SDK. Probablemente necesitarás\n        actualizar esta variable permanentemente, de esta manera podrás ejecutar el comando <code>flutter</code> en cualquier sesión de terminal.</p>\n\n    <p>Los pasos para modificar esta variable permanentemente para todas las sesiones de terminal son específicas del equipo.\n        Típicamente se agrega una línea al archivo que se ejecuta cada que abres\n        una nueva ventana. Por ejemplo:</p>\n\n    <ol>\n        <li>Determine el directorio donde se encuentra el SDK de Flutter.\n            Necesitaras esto en el paso 3.</li>\n        <li>Abre (o crea) <code>$HOME/.bash_profile</code>. La dirección del archivo\n            puede estar en un lugar diferente en tu equipo.</li>\n        <li>Agrega la siguiente línea y cambia <code>[PATH_TO_FLUTTER_GIT_DIRECTORY]</code> para ser\n            la ruta donde has clonado el repositorio de Flutter:</li>\n    </ol>\n\n    <p><code>terminal\n        $ export PATH=\"$PATH:[PATH_TO_FLUTTER_GIT_DIRECTORY]/flutter/bin\"\n    </code></p>\n\n    <ol>\n        <li>Ejecuta <code>source $HOME/.bash_profile</code> para refrescar la ventana actual.</li>\n        <li>\n            <p>Verifica que el directorio de <code>flutter/bin</code> esta en tu PATH ejecutando el siguiente comando:</p>\n\n            <div>\n                <div><div><button>  <i class=\"material-icons\">content_copy</i></button><div><pre><code>$ echo $PATH\n</code></pre></div></div></div>    </div>\n        </li>\n    </ol>\n\n    <p>Para más detalles, ver Estas preguntas en StackExchange.</p>\n\n    <h2>\n        Configuración de Android</h2>\n\n    \n        <p><i class=\"fas fa-info-circle\"></i> <strong>Nota:</strong>\n            Flutter requiere de una completa instalación de Android Studio para proveer\n            las dependencias de la plataforma de Android. De cualquier manera, puede desarrollar sus\n            apps de Flutter en diferentes editores; hablaremos de ello en un paso siguiente.</p>\n    </aside>\n\n    <h3 id=\"instalar-android-studio\">\n        Instalar Android Studio</h3>\n\n    <ol>\n        <li>Descarga e instala Android Studio.</li>\n        <li>Inicia Android Studio, y sigue todo el ‘Android Studio Setup Wizard’. Este\n            Instalará la versión más reciente de Android SDK, Android SDK Platform-Tools y\n            Android SDK Build-Tools, Las cuales son requeridas por Flutter cuando se desarrolla para Android.</li>\n    </ol>\n\n    <h3 id=\"configurar-tu-dispositivo-android\">\n        Configurar tu dispositivo Android</h3>\n\n    <p>Prepara la ejecución y pruebas de app de Flutter en un dispositivo de Android, necesitará\n        un dispositivo Android ejecutando Android 4.1 (API nivel 16) o superior.</p>\n\n    <ol>\n        <li>Habilita <strong>Opciones de desarrollador</strong> y <strong>Depurador por USB</strong> en tu dispositivo. Instrucciones detalladas\n            están disponibles en la Documentación de Android.</li>\n        <li>Solo en Windows: Instala Google USB Driver\n        </li>\n        <li>Utilizando el cable USB, conecta tu móvil de la computadora, de requerirse en tu\n            dispositivo, autoriza el acceso de la computadora a tu dispositivo.</li>\n        <li>En terminal, ejecuta el comando <code>flutter devices</code>  para verificar que Flutter ha reconocido\n            tu dispositivo Android conectado.</li>\n    </ol>\n\n    <p>Por defecto, Flutter utiliza la versión SDK de Android donde se encuentren las herramientas <code>adb</code>. Si\n        quieres que Flutter utilice alguna instalación diferente del SDK de Android, deberás configurar\n        la variable de entorno <code>ANDROID_HOME</code> en el directorio de instalación.</p>\n\n    <h3 id=\"configurar-el-emulador-de-android\">\n        Configurar el emulador de Android</h3>\n\n    <p>Prepare la ejecución y pruebas de app de Flutter en el emulador de Android, siguiendo estos pasos:</p>\n\n    <ol>\n        <li>Habilita VM acceleration en tu equipo.</li>\n        <li>Abra <strong>Android Studio&gt;Tools&gt;Android&gt;AVD Manager</strong> y selecciona\n            <strong>Create Virtual Device</strong>. (El submenú <strong>Android</strong> está presente solo\n            cuando se encuentra dentro de un proyecto de Android.)</li>\n        <li>Elija un dispositivo y seleccione <strong>Next</strong>.</li>\n        <li>Selecciona una o más imágenes del sistema que quieres emular,\n            y selecciona <strong>Next</strong>. Una imagen <em>x86</em> o <em>x86_64</em> es recomendada.</li>\n        <li>Dentro de Emulated Performance, selecciona <strong>Hardware - GLES 2.0</strong> para habilitarlo\n            aceleración de hardware.</li>\n        <li>\n            <p>Verifica que la configuración de AVD es correcta, y selecciona <strong>Finish</strong>.</p>\n\n            <p>Para mayor detalle de los pasos de arriba, vea Administrando AVDs.</p>\n        </li>\n        <li>En el Administrador de Dispositivos Virtuales de Android (AVD), da clic en la barra de herramienta <strong>Run</strong>.\n            El emulador iniciará el arranque y mostrara el lienzo (canvas) por defecto para la versión del SO y dispositivo seleccionado.</li>\n    </ol>\n</div>"
    },
    {
        "title": "2. Configura un editor",
        "subtitle": "Introduccion",
        "content":  "<div class=\"container\">\n    <h1>Configurar un Editor</h1>\n    <p>Puedes construir apps con Flutter utilizando cualquier editor de texto combinado con nuestras\n        herramientas en línea de comando. De cualquier manera, recomendamos utilizar alguno de nuestros\n        plugin para una mejor experiencia. Con nuestros plugins de edición, podrás auto completar código,\n        sintaxis resaltada, asistencia al editar widgets, apoyo para ejecutar &amp; depurar, y más.</p>\n\n    <p>Siga los siguientes pasos para agregar un complemento al editor para Android Studio, IntelliJ\n        o VS Code. Si quiere utilizar un editor diferente, está bien, simplemente salte al\n        siguiente paso: crear y ejecutar tu primer app.</p>\n\n    <ul class=\"nav nav-tabs\" id=\"editor-setup\" role=\"tablist\">\n        <li class=\"nav-item\">\n            Android Studio / IntelliJ\n        </li>\n        <li class=\"nav-item\">\n            Visual Studio Code\n        </li>\n    </ul>\n\n    <div class=\"tab-content\">\n\n        <div class=\"tab-pane active\" id=\"androidstudio\" role=\"tabpanel\" aria-labelledby=\"androidstudio-tab\">\n\n            <h3 id=\"instalar-android-studio\">Instalar Android Studio</h3>\n\n            <p>Android Studio ofrece una experiencia completa e integrada del IDE para Flutter.</p>\n\n            <ul>\n                <li>Android Studio, versión 3.0 o superior.</li>\n            </ul>\n\n            <p>Otra opción puede ser utilizar IntelliJ:</p>\n\n            <ul>\n                <li>IntelliJ IDEA Community, versión 2017.1 o superior.</li>\n                <li>IntelliJ IDEA Ultimate, versión 2017.1 o superior.</li>\n            </ul>\n\n            <h3 id=\"instalar-los-plugins-de-flutter-y-dart\">Instalar los plugins de Flutter y Dart</h3>\n\n            <p>Para instalar estos:</p>\n\n            <ol>\n                <li>Inicie Android Studio.</li>\n                <li>Abra preferencias de complementos (<strong>Preferences&gt;Plugins</strong> en macOS,\n                    <strong>File&gt;Settings&gt;Plugins</strong> en Windows &amp; Linux).</li>\n                <li>Seleccione <strong>Browse repositories…</strong>,  elige el complemento de Flutter y presione\n                    <code>install</code>.</li>\n                <li>Presione <code>Yes</code> cuando aparezca para instalar el complemento de Dart.</li>\n                <li>Presione <code>Restart</code> cuando aparezca.</li>\n            </ol>\n\n        </div>\n        <div class=\"tab-pane\" id=\"vscode\" role=\"tabpanel\" aria-labelledby=\"vscode-tab\">\n\n            <h3 id=\"instalar-vs-code\">Instalar VS Code</h3>\n\n            <p>VS Code es un editor ligero con Flutter, asistencia al ejecutar y depurar.</p>\n\n            <ul>\n                <li>VS Code, La versión estable más reciente.</li>\n            </ul>\n\n            <h3 id=\"instalar-el-complemento-de-flutter\">Instalar el complemento de Flutter</h3>\n\n            <ol>\n                <li>Inicie VS Code</li>\n                <li>Llame <strong>View&gt;Command Palette…</strong></li>\n                <li>Teclee ‘install’, y seleccione la acción <strong>‘Extensions: Install Extension’</strong></li>\n                <li>Introduzca <code>flutter</code> en el campo de búsqueda, seleccione ‘Flutter’ en la lista,\n                    y presione <strong>Install</strong></li>\n            </ol>\n\n            <h2 id=\"valida-tu-configuracin-con-flutter-doctor\">Valida tu configuración con Flutter Doctor</h2>\n\n            <ol>\n                <li>Llame a <strong>View&gt;Command Palette…</strong></li>\n                <li>Teclee ‘doctor’, y seleccione la acción <strong>‘Flutter: Run Flutter Doctor’</strong></li>\n                <li>Revise la salida en el panel ‘OUTPUT’ para cualquier inconveniente.</li>\n            </ol>\n\n        </div>\n\n    </div>\n</div>"
    },    
    {
        "title": "3. Test inicial",
        "subtitle": "Introduccion",
        "content":  "<div>\n    <h2 id=\"create-app\">Crea la app</h2>\n    <ol>\n        <li>Seleccionar <strong>File &gt; New Flutter Project</strong></li>\n        <li>Seleccionar <strong>Flutter application</strong> como tipo de proyecto, y presionar <strong>Next</strong>.</li>\n        <li>Asegúrate que el campo <strong>Flutter SDK Path</strong> especifica la localización\n            del SDK. Instala el SKD si no lo has hecho ya.</li>\n        <li>Introducir nombre de proyecto (ej. <code>myapp</code>), y presionar siguiente.</li>\n        <li>Clic en <strong>Finish</strong>.</li>\n        <li>Espera mientras Android Studio instala el SDK, y crear el proyecto.</li>\n    </ol>\n\n    <p>Los comandos de arriba crean un directorio para el proyecto llamado <code>myapp</code>\n        el cual contiene una app demo sencilla que utiliza Material Components.</p>\n\n    <aside class=\"alert alert-success\" role=\"alert\">\n        <p> <strong>Consejo:</strong>\n            El código de tu app está en <code>lib/main.dart</code>.\n            Para una descripción más avanzada de que hace cada bloque de código, mira los\n            comentarios al princpio de este fichero.</p>\n    </aside>\n\n    <h2 id=\"ejecutar-app\">Ejecutar app</h2>\n\n    <ol>\n        <li>Localiza la barra de herramientas principal de Android Studio:<br>\n            <img src=\"asset:assets/img/3_main-toolbar-857fe8c36d38020e27b502ec643ea8b1716edbe150cc6e39e3560f8fb7bda5b2.png\" alt=\"Main IntelliJ toolbar\" class=\"mw-100\"></li>\n        <li>En el <strong>target selector</strong>, selecciona un dispositivo android para ejecutar la app.\n            Si ninguno esta en la lista como disponible, selecciona <strong>Tools&gt; Android &gt; AVD Manager</strong> y\n            crea uno ahí mismo. Para más detalle, vea [Administrando AVDs].</li>\n        <li>Clic en el <strong>Run icon</strong> en la barra de herramientas, seleccionar <strong>Run &gt; Run</strong> del menú.</li>\n    </ol>\n\n    <p>Después de que el compilado de la app se complete, verás la app inicial en tu dispositivo.</p>\n\n    <figure class=\"site-figure \">\n        <div class=\"site-figure-container\">\n            <img src=\"asset:assets/img/3_starter-app-5e284e57b8dce587ea1dfdac7da616e6ec9dc263a409a9a8f99cf836340f47b8.png\">\n            <figcaption class=\"figure-caption\">Starter app</figcaption>\n        </div>\n    </figure>\n\n    <h2 id=\"probando-el-hot-reload\">Probando el hot reload</h2>\n\n    <p>Flutter ofrece un ciclo de desarrollo rápido con <em>hot reload</em>, la habilidad de recargar\n        el código en una app ejecutando en vivo sin reiniciar o perder el estado de la app. simplemente\n        hace un cambio a tu código fuente, diciéndole a tu IDE o herramienta de línea de comandos que\n        quieres recargar, y ver los cambio en tu simulador, emulador, o dispositivo.</p>\n\n    <ol>\n        <li>Open <code>lib/main.dart</code>.</li>\n        <li>Cambia el texto\n            <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-0\" data-original-title=\"Copy code\"></button><div id=\"code-excerpt-0\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\"><span class=\"str\">'You have </span><span class=\"strike\"><span class=\"str\">pushed</span></span><span class=\"str\"> the button this many times'</span></pre></div></div>\n            <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-1\" data-original-title=\"Copy code\"></button><div id=\"code-excerpt-1\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\"><span class=\"str\">'You have </span><span class=\"highlight\"><span class=\"str\">clicked</span></span><span class=\"str\"> the button this many times'</span></pre></div></div>\n            <aside class=\"alert alert-warning\" role=\"alert\">\n                <p> <strong>Importante:</strong>\n                    Do <em>not</em> stop your app. Let your app run.</p>\n            </aside>\n        </li>\n        <li>Guarda tus cambios: invoca <strong>Save All</strong>, o haz clic en <strong>Hot Reload</strong></li>\n    </ol>\n    <p>Verás el texto actualizado en la app en ejecución casí inmediatamante.</p>\n    <h2 id=\"ejecutar-en-modo-profile\">Ejecutar en modo Profile</h2>\n    <aside class=\"alert alert-warning\" role=\"alert\">\n        <p><strong>Importante:</strong>\n            <em>No</em> pruebes el rendimiento de tu app con el modo depuración y hot reload habilitados.</p>\n    </aside>\n    <p>La app que has ejecutado hasta ahora esta en modo depuración que permite un desarrollo más rapido (ej., hot reload) con una gran sobrecarga de rendimiento. Por tanto, puedes esperar animaciones lentas en este modo. Para ver como rinden las apps en modo release,  prueba invocar el menu <strong>Run &gt; Profile</strong> en el IDE, o\n        el siguiente comando en la terminal.</p>\n    <div class=\"language-terminal highlighter-rouge\"><div class=\"highlight\"><div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-2\" data-original-title=\"Copy code\"></button><div id=\"code-excerpt-2\"><pre class=\"highlight\"><code><span class=\"gp\">$</span> flutter run <span class=\"nt\">--profile</span>\n</code></pre></div></div></div>    </div>\n    <p>Las animaciones deben ser mucho mas suaves comparadas con el modo depuración.</p>\n</div>"
    },
    {
        "title": "4. Escribe tu primera app",
        "subtitle": "Introduccion",
        "content":  "<div class=\"container\">\n    <h1>Escribe tu primera app en Flutter, parte 1</h1>\n    <p><img src=\"asset:assets/img/4_startup-namer-part-1-9db323d8383da0000c8be4e1a12e3d9ff6ab3a0eb8b86984451b329f1f3b4196.JPG\"><style>pre .highlight { background-color: #dfd; }</style></p>\n    <p>Esta es una guía para crear tu primera app en Flutter. Si estás familiarizado con la\n        programación orientada a objetos y con conceptos básicos de programación como\n        variables, bucles y condicionales podrás completar este tutorial.\n        No se necesita experiencia previa con Dart o programación móvil.</p>\n    <p>Esta guía es la parte 1 de un codelab de dos partes. Puedes encontrar la\n        parte 2\n        en Google Developers.\n        La Parte 1\n        también se puede encontrar en Google Developers.</p>\n\n    <h2 class=\"no_toc\" id=\"lo-que-haremos-en-la-parte-1\">\n        Lo que haremos en la parte 1</h2>\n\n    <p>Se implementará una app móvil sencilla que generará nombres propuestos para un\n        startup. El usuario puede seleccionar o deseleccionar nombres,\n        almacenando los mejores. El código genera nombres de forma “vaga”.\n        A medida que el usuario se desplaza por la pantalla, nuevos nombres son generados.\n        No hay límite a cuán lejos puede un usuario hacer scroll.</p>\n\n    <p>El GIF animado muestra como trabaja la app al completar la parte 1.</p>\n\n    <aside class=\"alert alert-secondary\" role=\"alert\">\n        <h4 class=\"no_toc\">\n            Lo que aprenderemos en la parte 1</h4>\n\n        <ul>\n            <li>Como escribir una apliación Flutter que se vea natural en iOS y Android</li>\n            <li>Estructura básica de una app en Flutter.</li>\n            <li>Encontrar y utilizar paquetes para extender funcionalidades.</li>\n            <li>Usar hot reload para un ciclo de desarrollo más rápido.</li>\n            <li>Cómo implementar un “stateful widget”.</li>\n            <li>Cómo crear una lista de carga “vaga” e infinita.</li>\n        </ul>\n\n        <p>En la parte 2\n            de este codelab, añadirás interactividad, modificarás el theme de la app, y\n            añadirás la habilidad de navegar a una nueva pantala (llamada una <em>ruta</em> en Flutter).</p>\n    </aside>\n\n    <aside class=\"alert alert-secondary\" role=\"alert\">\n        <h4 class=\"no_toc\">\n            Lo que vamos a usar</h4>\n\n        <p>Necesitas dos piezas de software para completar este “lab”: el\n            SDK de Flutter y un editor.\n            Este codelab presupone Android Studio, pero puedes usar el editor que\n            prefieras.</p>\n\n        <p>Puedes ejecutar este codelab usando cualquiera de los siguientes dispositivos:</p>\n\n        <ul>\n            <li>Un dispositivo físico (Android\n                o iOS) conectado a tu ordenador\n                y configurado en modo desarrollo.</li>\n            <li>El simulador de iOS.</li>\n            <li>El emulador de Android.</li>\n        </ul>\n    </aside>\n\n    <h1 id=\"paso-1-crear-la-app-inicial-de-flutter\">Paso 1: Crear la app inicial de Flutter</h1>\n\n    <p>Crear un app sencilla desde una plantilla de Flutter, utilizando las instrucciones en\n        Iniciando con tu primer app de\n            Flutter.\n        Nombre del proyecto <strong>startup_namer</strong> (en lugar de <em>myapp</em>).</p>\n\n    <aside class=\"alert alert-success\" role=\"alert\">\n        <p> <strong>Consejo:</strong>\n            Si no ves “New Flutter Project” como opción en tu IDE, asegúrate\n            que tienes instalados los plugins para Flutter y\n                Dart</p>\n    </aside>\n\n    <p>En este codelab, en su mayoría editarás <strong>lib/main.dart</strong>,\n        donde se encuentra el código Dart.</p>\n\n    <ol>\n        <li>\n            <p>Reemplaza el contenido de <code class=\"highlighter-rouge\">lib/main.dart</code>.<br>\n                Borra todo el código de <strong>lib/main.dart</strong>.\n                Reemplaza con el siguiente código, el cual muestra “Hello World” en el centro\n                de la pantalla.</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-0\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-0\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">import 'package:flutter/material.dart';\n\nvoid main() =&gt; runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Welcome to Flutter',\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Welcome to Flutter'),\n        ),\n        body: Center(\n          child: Text('Hello World'),\n        ),\n      ),\n    );\n  }\n}</pre></div></div>\n            </div>\n\n            <aside class=\"alert alert-success\" role=\"alert\">\n                <p> <strong>Consejo:</strong>\n                    Cuando copias código en tu app, la identación puede romperse.\n                    Puedes corregirla automáticamente con las herramientas de Flutter:</p>\n\n                <ul>\n                    <li>Android Studio / IntelliJ IDEA: Clic derecho sobre el código y elige\n                        <strong>Reformat Code with dartfmt</strong>.</li>\n                    <li>VS Code: Clic derecho y elige <strong>Format Document</strong>.</li>\n                    <li>Terminal: Ejecuta <code class=\"highlighter-rouge\">flutter format &lt;filename&gt;</code>.</li>\n                </ul>\n            </aside>\n        </li>\n        <li>\n            <p>Ejecuta la app de la forma que describe tu IDE.\n                Deberías ver la salida Android o iOS, dependiendo de tu dispositivo.</p>\n\n            <figure class=\"site-figure\">\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_hello-world-fadb9765c01d33f0fea92d7ac767e036ea90e9159335ea1841277bc6bef3a10a.png\">\n                    <figcaption class=\"figure-caption\">Android</figcaption>\n                </div>\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png\">\n                    <figcaption class=\"figure-caption\">iOS</figcaption>\n                </div>\n            </figure>\n\n            <aside class=\"alert alert-success\" role=\"alert\">\n                <p> <strong>Consejo:</strong>\n                    La primera vez que ejecutas en un dispositivo físico, tomará un poco la carga.\n                    Después de esto, puedes usar hot reload para actualizaciones rápidas. <strong>Save</strong> también\n                    realiza un hot reload si la app esta en ejecución.</p>\n            </aside>\n        </li>\n    </ol>\n\n    <h2 class=\"no_toc\" id=\"observaciones\">\n        Observaciones</h2>\n\n    <ul>\n        <li>Este ejemplo crea una “Material app”.\n            Material es un lenguaje de diseño visual\n            el cual es un estándar en web y móvil. Flutter ofrece un gran conjunto\n            de “Material widgets”.</li>\n        <li>El método main usa la anotación fat arrow (<code class=\"highlighter-rouge\">=&gt;</code>).\n            Usa anotación fat arrow para funciones o métodos de una sola linea.</li>\n        <li>La app hereda de <code class=\"highlighter-rouge\">StatelessWidget</code> el cual hace la app un widget en sí misma.\n            En Flutter, casi todo es un widget, incluido alineaciónes,\n            padding y layouts.</li>\n        <li>El widget <code class=\"highlighter-rouge\">Scaffold</code>, de la librería de Material,\n            provee una AppBar por defecto, “title”, y una propiedad “body” el cual\n            soporta el árbol de widget para la pantalla de inicio. El subárbol de widget\n            puede ser bastante complejo.</li>\n        <li>El trabajo principal de un widget es proporcionar un método build()\n            que describa cómo mostrar el widget en términos de otros widgets\n            de nivel inferior.</li>\n        <li>El body en este ejemplo consiste en un widget <code class=\"highlighter-rouge\">Center</code> conteniendo un\n            widget <code class=\"highlighter-rouge\">Text</code> hijo. El widget Center alinea su sub-árbol de wigets\n            en el centro de la pantalla.</li>\n    </ul>\n\n    <h1 id=\"paso-2-usar-un-paquete-externo\">Paso 2: Usar un paquete externo</h1>\n\n    <p>En este paso, empezarás utilizando un paquete de código libre llamado\n        english_words,\n        el cual contiene unos cuantos de miles de las palabras\n        en Inglés más utilizadas, además de otras funciones de utilidad.</p>\n\n    <p>Puedes encontrar el paquete <code class=\"highlighter-rouge\">english_words</code> package, así como muchos otros paquetes\n        open source, en pub.dartlang.org.</p>\n\n    <ol>\n        <li>\n            <p>El archivo pubspec gestiona los assets y dependencias para una app Flutter.\n                En <code class=\"highlighter-rouge\">pubspec.yaml</code>, agrega <code class=\"highlighter-rouge\">english_words</code> (3.1.0 o mayor)\n                a las lista de dependencias.\n                Añade la línea resaltada abajo:</p>\n\n        </li>\n        <li>\n            <p>Mientras vez el pubspec en el editor de Android Studio,\n                clic <strong>Packages get</strong>. Esto trae los paquetes dentro\n                del proyecto. Se deberá ver lo siguiente en la consola:</p>\n\n            <div class=\"language-terminal highlighter-rouge\">\n                <div class=\"highlight\"><div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-1\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-1\"><pre class=\"highlight\"><code>$ flutter pub get\nRunning \"flutter pub get\" in startup_namer...\nProcess finished with exit code 0\n</code></pre></div></div></div>    </div>\n\n            <p>Realizando <code class=\"highlighter-rouge\">Packages get</code> también auto-generas el fichero <code class=\"highlighter-rouge\">pubspec.lock</code>\n                con una lista de todos los paquetes añadidos al proyecto y\n                sus números de version.</p>\n        </li>\n        <li>\n            <p>En <code class=\"highlighter-rouge\">lib/main.dart</code>, importa el nuevo paquete:</p>\n\n            <!-- skip -->\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-2\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-2\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">import 'package:flutter/material.dart';\nimport 'package:english_words/english_words.dart';</pre></div></div>\n            </div>\n\n            <p>Mientras tecleas, Android Studio da sugerencias para las bibliotecas a\n                importar. Entonces renderiza el texto de “import” en gris, haciéndote\n                saber que la librería importada no ha sido utilizada (hasta el momento).</p>\n        </li>\n        <li>\n            <p>Usa el paquete de palabras en inglés para generar texto en lugar de\n                utilizar el texto “Hello World”.</p>\n            <aside class=\"alert alert-info\" role=\"alert\">\n                <p> <strong>Nota:</strong>\n                    “Pascal case” (también conocido como “upper camel case”),\n                    significa que cada palabra en el texto, incluyendo la primera,\n                    empezará con letra mayúscula. Entonces, “uppercamelcase” se convierte\n                    “UpperCamelCase”.</p>\n            </aside>\n        </li>\n        <li>\n            <p>Si la app esta ejecutándose, haz hot reload\n                para actualizar la app. Cada vez que se presione hot reload\n                o se guarde el proyecto, deberá verse una palabra diferente,\n                elegida aleatoriamente, en la app.\n                Esto es debido a que las palabras generadas dentro del método “build”,\n                el cual se ejecuta cada vez que la MaterialApp requiere renderizar\n                o al alternar la plataforma en el inspector de Flutter .</p>\n\n            <figure class=\"site-figure\">\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step2-45e5a16e59926599e09b25b1c6d37372f77b69151cbebd070d2f94f657b1abde.png\">\n                    <figcaption class=\"figure-caption\">Android</figcaption>\n                </div>\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step2-de9da90d2a90351c8d651c50f345c822472dbcd93cd8bad099e4edf2aa499c43.png\">\n                    <figcaption class=\"figure-caption\">iOS</figcaption>\n                </div>\n            </figure>\n        </li>\n    </ol>\n\n    <h2 class=\"no_toc\" id=\"problemas\">\n        ¿Problemas?</h2>\n\n    <p>Si tu app no esta ejecutando correctamente, busca por errores al teclear. De ser necesario,\n        usa el código en el siguiente enlace y continuar.</p>\n\n    <ul>\n        <li>pubspec.yaml</li>\n        <li>lib/main.dart</li>\n    </ul>\n\n    <h1 id=\"paso-3-agregar-un-stateful-widget\">Paso 3: Agregar un Stateful widget</h1>\n\n    <p>Los widgets State<em>less</em> son inmutables, esto quiere decir que\n        sus propiedades no puedes cambiar—todos sus valores son finales.</p>\n\n    <p>Con widgets State<em>ful</em> mantienes un estado que puede cambiar\n        durante el tiempo de vida del widget. Implementar un stateful\n        widget requerirá al menos dos clases: 1) una clase StatefulWidget\n        la cual crea la instancia 2) una clase State. La clase StatefulWidget es,\n        a si misma, inmutable, pero la clase State persiste sobre el tiempo de\n        vida de el widget.</p>\n\n    <p>En este paso, agregaras un stateful widget, <code class=\"highlighter-rouge\">RandomWords</code>, el cual crea su clase\n        <code class=\"highlighter-rouge\">State</code>, <code class=\"highlighter-rouge\">RandomWordsState</code>. Entonces usarás <code class=\"highlighter-rouge\">RandomWords</code> como\n        un hijo dentro del existentea stateless widget <code class=\"highlighter-rouge\">MyApp</code>.</p>\n\n    <ol>\n        <li>\n            <p>Crea una state class mínima. Añade lo siguiente al final\n                de <code class=\"highlighter-rouge\">main.dart</code>:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (RandomWordsState)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-3\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-3\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWordsState extends State&lt;RandomWords&gt; {\n  // TODO Add build() method\n}</pre></div></div>\n            </div>\n\n            <p>Nota la declaración <code class=\"highlighter-rouge\">State&lt;RandomWords&gt;</code>. Esto indica que estamos\n                usando una clase\n                State\n                genérica especializada para usar <code class=\"highlighter-rouge\">RandomWords</code>. La mayoría de la lógica y el estado\n                de la app residen aquí—esto mantiene el estado para el widget <code class=\"highlighter-rouge\">RandomWords</code>.\n                Esta clase guarda el par de palabras generados, que crecen infinitamente cuando el\n                usuario hace scrolls, y los pares de palabras favoritos (en la\n                parte 2),\n                que el usuario añado o elimina de la lista alternando con el icon del corazón.</p>\n\n            <p><code class=\"highlighter-rouge\">RandomWordsState</code> depende de la clase <code class=\"highlighter-rouge\">RandomWords</code>. La añadirás a continuación.</p>\n        </li>\n        <li>\n            <p>Añade el widget stateful <code class=\"highlighter-rouge\">RandomWords</code> a <code class=\"highlighter-rouge\">main.dart</code>.\n                El widget <code class=\"highlighter-rouge\">RandomWords</code> hace poco más aparte de crear su clase State:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (RandomWords)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-4\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-4\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWords extends StatefulWidget {\n  @override\n  RandomWordsState createState() =&gt; new RandomWordsState();\n}</pre></div></div>\n            </div>\n\n            <p>Después de agregar esta clase de estado, el IDE se quejara que\n                a la clase le hace falta el método build. Siguiente, agregar un método\n                build básico que genera el juego de palabras moviendo la\n                generación de código de <code class=\"highlighter-rouge\">MyApp</code> a <code class=\"highlighter-rouge\">RandomWordsState</code>.</p>\n        </li>\n        <li>\n            <p>Añade el método <code class=\"highlighter-rouge\">build()</code> a <code class=\"highlighter-rouge\">RandomWordsState</code>:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (RandomWordsState)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-5\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-5\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWordsState extends State&lt;RandomWords&gt; {\n  @override\n  Widget build(BuildContext context) {\n    final wordPair = WordPair.random();\n    return Text(wordPair.asPascalCase);\n  }\n}</pre></div></div>\n            </div>\n        </li>\n        <li>\n            <p>Elimina el código de generación de palabras de <code class=\"highlighter-rouge\">MyApp</code> haciendo los cambios que se muestran en el siguiente diff:</p>\n        </li>\n        <li>\n            <p>Reinicia la app.\n                La app debería comportarse como antes, mostrando una palabra\n                emparejada cada vez que haces hot reload o guardas la app.</p>\n        </li>\n    </ol>\n\n    <aside class=\"alert alert-success\" role=\"alert\">\n        <p> <strong>Consejo:</strong>\n            Si ves la siguiente advertencia en el hot reload, considera reiniciar la app:\n            **Reloading…<br></p>\n\n        <p>Some program elements were changed during reload but did not run when\n            the view was reassembled; you may need to restart the app (by pressing “R”)\n            for the changes to have an effect.**</p>\n\n        <p>Podría ser un falso positivo, pero considere reiniciar en orden de asegurar estos\n            cambios sean reflejados en la UI de la app.</p>\n\n    </aside>\n\n    <h2 class=\"no_toc\" id=\"problemas-1\">\n        ¿Problemas?</h2>\n\n    <p>Si tu app no esta corriendo correctamente, puedes utilizar este código\n        del siguiente enlace y continuar.</p>\n\n    <ul>\n        <li>lib/main.dart</li>\n    </ul>\n\n    <h1 id=\"paso-4-crear-un-listview-de-scroll-infinito\">Paso 4: Crear un ListView de scroll infinito</h1>\n\n    <p>En este paso, extenderemos la clase <code class=\"highlighter-rouge\">RandomWordsState</code> para generar\n        y desplegar una lista de palabras. Mientras el usuario se desplaza, la lista\n        lo desplegara en un widget <code class=\"highlighter-rouge\">ListView</code>, que crecerá infinitamente. El <code class=\"highlighter-rouge\">builder</code> factory\n        constructor del  <code class=\"highlighter-rouge\">ListView</code> permite construir una lista de carga\n        retrasada, a petición.</p>\n\n    <ol>\n        <li>\n            <p>Añade una lista <code class=\"highlighter-rouge\">_suggestions</code> a la clase <code class=\"highlighter-rouge\">RandomWordsState</code>\n                para guardar pares de palabras sugeridas.\n                También, agrega una variable <code class=\"highlighter-rouge\">_biggerFont</code> para hacer el tamaño de la fuente más grande.</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-6\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-6\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">class RandomWordsState extends State&lt;RandomWords&gt; {\n  final _suggestions = &lt;WordPair&gt;[];\n  final _biggerFont = const TextStyle(fontSize: 18.0);\n  // ···\n}</pre></div></div>\n            </div>\n\n            <aside class=\"alert alert-info\" role=\"alert\">\n                <p> <strong>Nota:</strong>\n                    Prefijar un identificador con guion bajo lo fuerza a ser\n                        privado\n                    in the Dart language.</p>\n            </aside>\n\n            <p>A continuación añade una función <code class=\"highlighter-rouge\">_buildSuggestions()</code> a la clase <code class=\"highlighter-rouge\">RandomwordsState</code>.\n                Este método construirá el <code class=\"highlighter-rouge\">ListView</code> que muestra las\n                palabras sugeridas.</p>\n\n            <p>La clase <code class=\"highlighter-rouge\">ListView</code> provee una propiedad builder, <code class=\"highlighter-rouge\">itemBuilder</code>,\n                un factory builder y un función callback especificada como función anónima,\n                dos parámetros se pasan a la función—el <code class=\"highlighter-rouge\">BuildContext</code>,\n                y un fila de iteración , <code class=\"highlighter-rouge\">i</code>. El iterador empieza desde 0 e incrementa\n                cada vez que la función es llamada. Este incrementa dos veces por cada pareja de palabras sugeridas:\n                una para el ListTile, y una para el Divider. Este modelo permie a la lista de sugerencias crecer infinitamente cuando el usuario hace scroll.</p>\n        </li>\n        <li>\n            <p>Añade una función <code class=\"highlighter-rouge\">_buildSuggestions()</code>, mostrada\n                abajo, a la clase <code class=\"highlighter-rouge\">RandomWordsState</code> (borra los comentarios, si lo prefieres).</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (_buildSuggestions)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-7\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-7\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">Widget _buildSuggestions() {\n  return ListView.builder(\n      padding: const EdgeInsets.all(16.0),\n      itemBuilder: /*1*/ (context, i) {\n        if (i.isOdd) return Divider(); /*2*/\n\n        final index = i ~/ 2; /*3*/\n        if (index &gt;= _suggestions.length) {\n          _suggestions.addAll(generateWordPairs().take(10)); /*4*/\n        }\n        return _buildRow(_suggestions[index]);\n      });\n}</pre></div></div>\n            </div>\n\n            <ol class=\"numbered-code-notes\">\n                <li>El callback <code class=\"highlighter-rouge\">itemBuilder</code> es llamado una vez por cada par de palabras sugeridas,\n                    y coloca cada sugerencia en una fila <code class=\"highlighter-rouge\">ListTile</code>. Por cada fila, la\n                    función añade una fila <code class=\"highlighter-rouge\">ListTile</code> para las parejas de\n                    palabras. Para las filas impares, la\n                    función añade un widget <code class=\"highlighter-rouge\">Divider</code> para separar visualmente\n                    las entradas. Nota\n                    que este divisor puede ver ser dificil de ver en los\n                    dispositivos más pequeños.</li>\n                <li>Añade un widget divisor de un pixel de altura antes de\n                    cada fila en el <code class=\"highlighter-rouge\">ListView</code>.</li>\n                <li>La expresión <code class=\"highlighter-rouge\">i ~/ 2</code> divide <code class=\"highlighter-rouge\">i</code> entre 2 y devuelve un\n                    resultado entero.\n                    Por ejemplo: 1, 2, 3, 4, 5 dan como resultado 0, 1, 1, 2, 2. Esto calcula el actual numero de palbras emparejadas en el <code class=\"highlighter-rouge\">ListView</code>, menos los widgests\n                    divisores.</li>\n                <li>Si has alcanzado el final de los pares de palabras dispobibles, entonces genera\n                    10 más y añade estos a la lista de sugerencias.</li>\n            </ol>\n\n            <p>La función <code class=\"highlighter-rouge\">_buildSuggestions()</code> llama a <code class=\"highlighter-rouge\">_buildRow()</code> una vez por\n                cada pareja de palabras. Esta función muestra cada pareja en un <code class=\"highlighter-rouge\">ListTile</code>,\n                que te permite hacer las filas más atractivas en el siguiente paso.</p>\n        </li>\n        <li>\n            <p>Añade una función <code class=\"highlighter-rouge\">_buildRow()</code> a <code class=\"highlighter-rouge\">RandomWordsState</code>:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (_buildRow)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-8\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-8\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">Widget _buildRow(WordPair pair) {\n  return ListTile(\n    title: Text(\n      pair.asPascalCase,\n      style: _biggerFont,\n    ),\n  );\n}</pre></div></div>\n            </div>\n        </li>\n        <li>\n            <p>En la clase <code class=\"highlighter-rouge\">RandomWordsState</code>, actualiza el método <code class=\"highlighter-rouge\">build</code>\n                para usar <code class=\"highlighter-rouge\">_buildSuggestions()</code>, mejor que llamar directamente a la\n                biblioteca de generación de palabras.\n                (Scaffold\n                implementa el layout visual básico de Material Design.)</p>\n\n            <p>Reemplaza el cuerpo del método con el código marcado:</p>\n\n            <div class=\"code-excerpt\">\n                <div class=\"code-excerpt__header\">lib/main.dart (build)</div>\n                <div class=\"code-excerpt__code\"><button class=\"code-excerpt__copy-btn\" type=\"button\" data-toggle=\"tooltip\" title=\"\" data-clipboard-target=\"#code-excerpt-9\" data-original-title=\"Copy code\">  content_copy</button><div id=\"code-excerpt-9\"><pre class=\"prettyprint lang-dart prettyprinted\" style=\"\">@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text('Startup Name Generator'),\n    ),\n    body: _buildSuggestions(),\n  );\n}</pre></div></div>\n            </div>\n        </li>\n        <li>\n            <p>Actualiza el método <code class=\"highlighter-rouge\">build</code> de <code class=\"highlighter-rouge\">MyApp</code>, cambiando el title,\n                y cambiando home para ser el widget <code class=\"highlighter-rouge\">RandomWords</code>.</p>\n            <p>Reemplaza el método original con el método <code class=\"highlighter-rouge\">build</code> remarcado abajo:</p>\n        </li>\n        <li>\n            <p>Reinicia la app. Deberías ver una lista de palabras emparejadas no importa lo lejos\n                que hagas scroll.</p>\n\n            <figure class=\"site-figure\">\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step4-infinite-list-69f7c62bf16f67eaade07551db4b18b065d6c7a81e042a10cd34d31ecb7f2514.png\">\n                    <figcaption class=\"figure-caption\">Android</figcaption>\n                </div>\n                <div class=\"site-figure-container\">\n                    <img src=\"asset:assets/img/4_step4-infinite-list-70ea9d8fd7191fb3726f1743bb03499815f93df4f42b687cfd7916052c35eb07.png\">\n                    <figcaption class=\"figure-caption\">iOS</figcaption>\n                </div>\n            </figure>\n        </li>\n    </ol>\n\n    <h2>¿Problemas?</h2>\n    <p>Si tu app no esta funcionando correctamente, puedes ver el código\n        en el siguiente enlace y continuar.</p>\n    <ul>\n        <li>lib/main.dart</li>\n    </ul>\n\n    <h1 class=\"no_toc\" id=\"siguientes-pasos\">Siguientes pasos</h1>\n\n    <figure class=\"site-figure site-image-right\">\n        <div class=\"site-figure-container\">\n            <img src=\"asset:assets/img/4_startup-namer-b85740ef920a57e28524f84e9c06cfb380128d10780e91eaf2c7613a56f3f511.gif\">\n            <figcaption class=\"figure-caption\">The app from part 2</figcaption>\n        </div>\n    </figure>\n\n    <p>Enhorabuena!</p>\n\n    <p>Has escrito una app interactiva en Flutter que se ejecuta en ambos iOS y Android\n        En este laboratorio, tu has:</p>\n\n    <ul>\n        <li>Creado una app de Flutter desde cero.</li>\n        <li>Escrito código Dart.</li>\n        <li>Utilizado una libreía externa de terceros.</li>\n        <li>Usado hot reload para un ciclo de desarrollo más rápido.</li>\n        <li>Impementado un widget stateful.</li>\n        <li>Creado una lista de scroll infinito, de carga retrasada.</li>\n    </ul>\n\n    <p>Si deseas extender esta app, procede con la\n        parte 2\n        en el sitio\n        Google Developers Codelabs,\n        donde añadiras la siguiente funcionalidad:</p>\n    <ul>\n        <li>Implementar interactividad añadiendo un icono corazón pulsable para guardar\n            tus parejas de palabras favoritas.</li>\n        <li>Implementar navegación a una nueva ruta añadiendo una nueva pantalla\n            conteniendo los favoritos guardados.</li>\n        <li>Modificar el color del tema, fabricando una app todo-blanco.</li>\n    </ul>\n</div>"
    },
    {
        "title": "5.1. Flutter para Android devs",
        "subtitle": "Introduccion",
        "content":  "<div>\n  <h1>Flutter para Desarrolladores Android</h1>\n  <div>\n      Contenidos\n    <ul>\n      <li>¿Cuál es el equivalente de una View en Flutter?</li>\n      <li>¿Cómo actualizo Widgets?</li>\n      <li>¿Cómo puedo diseñar mis widgets? ¿Dónde está mi archivo de layout XML?</li>\n      <li>¿Cómo agrego o elimino un componente de mi layout?</li>\n      <li>¿Cómo puedo animar un widget?</li>\n      <li>¿Cómo puedo usar un Canvas para dibujar/pintar?</li>\n      <li>¿Cómo construyo widgets personalizados?</li>\n      <li>¿Cuál es el equivalente a una intent en Flutter?</li>\n      <li>¿Cómo manejo los intents entrantes desde aplicaciones externas en Flutter?</li>\n      <li>¿Cuál es el equivalente de startActivityForResult()?</li>\n      <li>¿Cuál es el equivalente de runOnUiThread() en Flutter?</li>\n      <li>¿Cómo se mueve el trabajo a un background thread?</li>\n      <li>¿Cuál es el equivalente de OkHttp en Flutter?</li>\n      <li>¿Cómo puedo mostrar el progreso de una tarea de larga duración?</li>\n      <li>¿Dónde guardo mis archivos de imagen dependientes de la resolución?</li>\n      <li>¿Dónde guardo los strings? ¿Cómo gestiono la localización?</li>\n      <li>¿Cuál es el equivalente a un archivo Gradle? ¿Cómo puedo añadir dependencias?</li>\n      <li>¿Cuál es el equivalente de actividades y fragmentos en Flutter?</li>\n      <li>¿Cómo escucho los eventos del ciclo de vida de las actividades Android?</li>\n      <li>¿Cuál es el equivalente de un LinearLayout?</li>\n      <li>¿Cuál es el equivalente de un RelativeLayout?</li>\n      <li>¿Cuál es el equivalente de un ScrollView?</li>\n      <li>¿Cómo manejo la transición a landscape en Flutter?</li>\n      <li>¿Cómo puedo añadir un listener onClick a un widget en Flutter?</li>\n      <li>¿Cómo puedo manejar otros gestos en los widgets?</li>\n      <li>¿Cuál es la alternativa a un ListView en Flutter?</li>\n      <li>¿Cómo sé en cuál elemento de la lista se hace clic?</li>\n      <li>¿Cómo actualizo ListView dinámicamente?</li>\n      <li>¿Cómo configuro fuentes personalizadas en mis widgets Text?</li>\n      <li>¿Cómo puedo cambiar el estilo de mis widgets Text?</li>\n      <li>¿Cuál es el equivalente a un “hint” sobre un Input?</li>\n      <li>¿Cómo puedo mostrar los errores de validación?</li>\n      <li>¿Cómo accedo al sensor de GPS?</li>\n      <li>¿Cómo accedo a la cámara?</li>\n      <li>¿Cómo me autentico con Facebook?</li>\n      <li>¿Cómo uso las características de Firebase?</li>\n      <li>¿Cómo puedo crear mis propias integraciones nativas personalizadas?</li>\n      <li>¿Cómo utilizo el NDK en mi aplicación Flutter?</li>\n      <li>¿Cómo puedo ponerle un theme a mi aplicación?</li>\n      <li>¿Cómo puedo acceder a las Preferencias Compartidas?</li>\n      <li>¿Cómo accedo a SQLite en Flutter?</li>\n      <li>¿Cómo configuro las notificaciones push?</li>\n    </ul>\n  </div>\n  <p>Este documento está dirigido a desarrolladores de Android que deseen aplicar sus conocimientos\n    existentes sobre Android para crear aplicaciones móviles con Flutter. Si entiendes los fundamentos\n    del framework de Android entonces puedes usar este documento como un inicio para el desarrollo de\n    Flutter.</p>\n\n  <p>Tus conocimientos y habilidades sobre Android son muy valiosos a la hora de construir con Flutter,\n    ya que Flutter depende del sistema operativo móvil para numerosas\n    funcionalidades y configuraciones. Flutter es una nueva forma de crear UI para móviles,\n    pero tiene un sistema de plugin para comunicarse con Android (e iOS) para tareas\n    que no son de UI. Si eres un experto con Android, no tienes que volver a aprender todo\n    para usar Flutter.</p>\n\n  <p>Este documento puede ser usado como un cookbook en el que se tratan las siguientes\n    cuestiones que son más relevantes para tus necesidades.</p>\n\n  <h1>Views</h1>\n\n  <h2>\n    ¿Cuál es el equivalente de una <code>View</code> en Flutter?</h2>\n\n  <aside>\n    <p>¿Como de diferente son el estilo reactivo, o declarativo, que\n      el estilo tradicional imperativo?\n      Para una comparación, mira Introducción a UI\n        declarativo.</p>\n  </aside>\n\n  <p>En Android, el <code>View</code> es la base de todo lo que aparece en la pantalla.\n    Botones, toolbars, e inputs, todo es un View. En Flutter, el equivalente\n    aproximado a un <code>View</code> es un <code>Widget</code>. Los widgets no se asimilan exactamente\n    a las vistas de Android, pero mientras te familiarizas con el\n    funcionamiento de Flutter, puedes pensar en ellos como “la forma en que declaras\n    y construyes la UI”.</p>\n\n  <p>Sin embargo, estos tienen algunas diferencias con un <code>View</code>. Para empezar, los widgets tienen una\n    vida útil diferente: son inmutables y sólo existen hasta que necesitan ser cambiados. Cada vez que\n    los widgets o su estado cambian, el framework de Flutter crea un nuevo árbol de instancias de\n    widgets. En comparación, una view de Android se dibuja una vez y no se vuelve a dibujar\n    hasta que <code>invalidate</code> es llamado.</p>\n\n  <p>Los widgets de Flutter son ligeros, en parte debido a su inmutabilidad.\n    Porque no son vistas en sí mismas, y no están dibujando nada directamente,\n    sino más bien una descripción de la UI y su semántica que son “inflated”\n    en la vista de objetos actual.</p>\n\n  <p>Flutter incluye la biblioteca Material Components.\n    Estos son los widgets que implementan las\n    Guías de Material Design. Material Design es un\n    sistema de layout flexible optimizado para todas las\n      plataformas,\n    incluyendo iOS.</p>\n\n  <p>Pero Flutter es lo suficientemente flexible y expresivo como para implementar cualquier lenguaje de diseño.\n    Por ejemplo, en iOS, puedes utilizar los widgets\n      Cupertino\n    para producir una interfaz que se parezca al\n    Lenguaje de diseño iOS de Apple.</p>\n\n  <h2>¿Cómo actualizo <code>Widgets</code>?</h2>\n\n  <p>En Android, puedes actualizar tus vistas mutándolas directamente. Sin embargo,\n    en Flutter, los <code>Widgets</code> son inmutables y no se actualizan directamente, en su lugar\n    tienes que trabajar con el estado del widget.</p>\n\n  <p>De ahí el concepto de los widgets Stateful y Stateless. Un\n    <code>StatelessWidget</code> es justo lo que parece, un widget sin información de\n    estado.</p>\n\n  <p>Los <code>StatelessWidgets</code> son útiles cuando la parte de la interfaz de usuario que está\n    describiendo no depende de nada más que de la configuración\n    en el objeto.</p>\n\n  <p>Por ejemplo, en Android, esto es similar a colocar un “ImageView” con su logo.\n    El logo no va a cambiar durante el tiempo de ejecución, así que\n    usa un <code>StatelessWidget</code> en Flutter.</p>\n\n  <p>Si deseas cambiar dinámicamente la UI basándote en los datos recibidos después\n    de realizar una llamada HTTP o una interacción con el usuario, entonces tienes\n    que trabajar con <code>StatefulWidget</code> y decirle al framework Flutter que el <code>State</code> del widget\n    ha sido actualizado para que pueda actualizarlo.</p>\n\n  <p>Lo importante a tener en cuenta aquí es que tanto los widgets stateless como los\n    stateful se comportan de la misma manera. Reconstruyen cada frame, la diferencia\n    es que el <code>StatefulWidget</code> tiene un objeto <code>State</code> que almacena datos de\n    estado a través de los frames y los restaura.</p>\n\n  <p>Si tienes dudas, recuerda siempre esta regla: si un widget cambia (debido a las\n    interacciones del usuario, por ejemplo), es stateful. Sin embargo, si un widget\n    reacciona al cambio, el widget padre que lo contiene puede seguir siendo stateless\n    si él mismo no reacciona al cambio.</p>\n\n  <p>El siguiente ejemplo muestra cómo usar un <code>StatelessWidget</code>. Un\n    <code>StatelessWidget</code> común es el widget <code>Text</code>. Si observamos la implementación\n    del widget <code>Text</code> lo encontrarás en las subclases <code>StatelessWidget</code>.</p>\n\n  <div>  <div><pre>Text(\n  'I like Flutter!',\n  style: TextStyle(fontWeight: FontWeight.bold),\n);</pre></div></div>\n\n  <p>Como puedes ver, el Widget “Text” no tiene ninguna información de estado asociada a él,\n    muestra lo que se le pasa a sus constructores y nada más.</p>\n\n  <p>Pero ¿qué pasa si quieres hacer que “I Like Flutter” cambie dinámicamente, por\n    ejemplo al hacer clic en un <code>FloatingActionButton</code>?</p>\n\n  <p>Para lograr esto, envuelve el widget <code>Text</code> en un <code>StatefulWidget</code> y actualízalo\n    cuando el usuario haga clic en el botón.</p>\n\n  <p>Por ejemplo:</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  // Texto placeholder predeterminado\n  String textToShow = \"I Like Flutter\";\n\n  void _updateText() {\n    setState(() {\n      // update the text\n      textToShow = \"Flutter is Awesome!\";\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(child: Text(textToShow)),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _updateText,\n        tooltip: 'Update Text',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo diseñar mis widgets? ¿Dónde está mi archivo de layout XML?</h2>\n\n  <p>En Android, los layouts se escriben en XML, pero en Flutter se escriben\n    con un árbol de widgets.</p>\n\n  <p>El siguiente ejemplo muestra cómo desplegar un widget simple con padding:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: MaterialButton(\n        onPressed: () {},\n        child: Text('Hello'),\n        padding: EdgeInsets.only(left: 10.0, right: 10.0),\n      ),\n    ),\n  );\n}</pre></div></div>\n\n  <p>Puedes ver los layouts que Flutter tiene para ofrecer en el Catálogo\n    de Widgets.</p>\n\n  <h2>\n    ¿Cómo agrego o elimino un componente de mi layout?</h2>\n\n  <p>En Android, puedes llamar a <code>addChild()</code> o <code>removeChild()</code> en un padre para\n    añadir o eliminar dinámicamente las vistas hijas. En Flutter, dado que los widgets\n    son inmutables no hay equivalente directo a <code>addChild()</code>.\n    En su lugar, puedes pasar una función al padre que devuelva un widget, y\n    controlar la creación de ese hijo con una etiqueta booleana.</p>\n\n  <p>Por ejemplo, aquí está cómo puedes alternar entre dos widgets cuando haces clic en un\n    <code>FloatingActionButton</code>:</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  // Valor por defecto para conmutar\n  bool toggle = true;\n  void _toggle() {\n    setState(() {\n      toggle = !toggle;\n    });\n  }\n\n  _getToggleChild() {\n    if (toggle) {\n      return Text('Toggle One');\n    } else {\n      return MaterialButton(onPressed: () {}, child: Text('Toggle Two'));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: _getToggleChild(),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _toggle,\n        tooltip: 'Update Text',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo animar un widget?</h2>\n\n  <p>En Android, puedes crear animaciones usando XML, o llamar al método <code>animate()</code>\n    en una vista. En Flutter, anima los widgets usando la biblioteca de animaciones,\n    envolviendo los widgets dentro de un widget animate.</p>\n\n  <p>En Flutter, utiliza un <code>AnimationController</code> que es un <code>Animation&lt;double&gt;</code>\n    que puede pausar, buscar, detener e invertir la animación. Requiere un <code>Ticker</code>\n    que señala cuando se produce la sincronización, y produce una interpolación lineal\n    entre 0 y 1 en cada frame mientras está en ejecución. Luego creas una\n    o más <code>Animations</code> y las vinculas al controlador.</p>\n\n  <p>Por ejemplo, puedes usar <code>CurvedAnimation</code> para implementar una animación a lo\n    largo de una curva interpolada. En este sentido, el controlador es la fuente “maestra”\n    del progreso de la animación y la <code>AnimaciónCurvada</code> calcula la curva que reemplaza el\n    movimiento lineal predeterminado del controlador. Al igual que los widgets,\n    las animaciones de Flutter trabajan con la composición.</p>\n\n  <p>Cuando construyas el árbol de widgets, asigna la <code>Animation</code> a una propiedad animada\n    de un widget, como la opacidad de un <code>FadeTransition</code>, y le dices al controlador\n    que inicie la animación.</p>\n\n  <p>El siguiente ejemplo muestra cómo escribir un <code>FadeTransition</code> que desvanece\n    el widget en un logotipo al pulsar el <code>FloatingActionButton</code>:</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(FadeAppTest());\n}\n\nclass FadeAppTest extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Fade Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyFadeTest(title: 'Fade Demo'),\n    );\n  }\n}\n\nclass MyFadeTest extends StatefulWidget {\n  MyFadeTest({Key key, this.title}) : super(key: key);\n  final String title;\n  @override\n  _MyFadeTest createState() =&gt; _MyFadeTest();\n}\n\nclass _MyFadeTest extends State&lt;MyFadeTest&gt; with TickerProviderStateMixin {\n  AnimationController controller;\n  CurvedAnimation curve;\n\n  @override\n  void initState() {\n    super.initState();\n    controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n    curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n          child: Container(\n              child: FadeTransition(\n                  opacity: curve,\n                  child: FlutterLogo(\n                    size: 100.0,\n                  )))),\n      floatingActionButton: FloatingActionButton(\n        tooltip: 'Fade',\n        child: Icon(Icons.brush),\n        onPressed: () {\n          controller.forward();\n        },\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <p>Para más información, consulta\n    Wigets de animación y movimiento,\n    el Tutorial de Animaciones ,\n    y Animaciones.</p>\n\n  <h2>\n    ¿Cómo puedo usar un <code>Canvas</code> para dibujar/pintar?</h2>\n\n  <p>En Android, usarías <code>Canvas</code> y <code>Drawable</code> para dibujar imágenes y formas\n    en la pantalla. Flutter tiene una API similar a la de <code>Canvas</code>, puesto que\n    se basa en el mismo motor de renderizado de bajo nivel, Skia. Como resultado,\n    pintar en un canvas en Flutter es una tarea muy familiar para los desarrolladores de Android.</p>\n\n  <p>Flutter tiene dos clases que te ayudan a dibujar en el canvas: <code>CustomPaint</code> y\n    <code>CustomPainter</code>, el último de los cuales implementa su algoritmo para\n    dibujar en el canvas.</p>\n\n  <p>Para aprender cómo implementar un signature painter en Flutter, consulta la respuesta de Collin en\n    StackOverflow.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() =&gt; runApp(MaterialApp(home: DemoApp()));\n\nclass DemoApp extends StatelessWidget {\n  Widget build(BuildContext context) =&gt; Scaffold(body: Signature());\n}\n\nclass Signature extends StatefulWidget {\n  SignatureState createState() =&gt; SignatureState();\n}\n\nclass SignatureState extends State&lt;Signature&gt; {\n  List&lt;Offset&gt; _points = &lt;Offset&gt;[];\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onPanUpdate: (DragUpdateDetails details) {\n        setState(() {\n          RenderBox referenceBox = context.findRenderObject();\n          Offset localPosition =\n          referenceBox.globalToLocal(details.globalPosition);\n          _points = List.from(_points)..add(localPosition);\n        });\n      },\n      onPanEnd: (DragEndDetails details) =&gt; _points.add(null),\n      child: CustomPaint(painter: SignaturePainter(_points), size: Size.infinite),\n    );\n  }\n}\n\nclass SignaturePainter extends CustomPainter {\n  SignaturePainter(this.points);\n  final List&lt;Offset&gt; points;\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 5.0;\n    for (int i = 0; i &lt; points.length - 1; i++) {\n      if (points[i] != null &amp;&amp; points[i + 1] != null)\n        canvas.drawLine(points[i], points[i + 1], paint);\n    }\n  }\n  bool shouldRepaint(SignaturePainter other) =&gt; other.points != points;\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo construyo widgets personalizados?</h2>\n\n  <p>En Android, normalmente se crea una subclase de <code>View</code>, o se utiliza una vista preexistente, para sobrescribir e implementar métodos que logren el comportamiento deseado.</p>\n\n  <p>En Flutter, construyes un widget personalizado componiendo widgets más pequeños\n    composing\n    (en lugar de heredar de estos).\n    Es algo similar a la implementación de un\n    <code>ViewGroup</code> personalizado en Android, donde todos los bloques de\n    construcción ya existen, pero proporcionas un comportamiento diferente,\n    por ejemplo, una lógica de layout personalizada.</p>\n\n  <p>Por ejemplo, ¿cómo se construye un <code>CustomButton</code> que toma una etiqueta en\n    el constructor? Crea un CustomButton que componga un <code>RaisedButton</code> con una etiqueta,\n    en lugar de heredar de <code>RaisedButton</code>:</p>\n\n  <div>  <div><pre>class CustomButton extends StatelessWidget {\n  final String label;\n\n  CustomButton(this.label);\n\n  @override\n  Widget build(BuildContext context) {\n    return RaisedButton(onPressed: () {}, child: Text(label));\n  }\n}</pre></div></div>\n\n  <p>Entonces usa <code>CustomButton</code>, tal como lo harías con cualquier otro widget de Flutter:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Center(\n    child: CustomButton(\"Hello\"),\n  );\n}</pre></div></div>\n\n  <h1>Intents</h1>\n\n  <h2>\n    ¿Cuál es el equivalente a una <code>intent</code> en Flutter?</h2>\n\n  <p>En Android, existen dos casos de uso principales para <code>Intent</code>: navegar entre\n    Activities, y comunicarse con los componentes. Flutter, por otro lado, no tiene\n    el concepto de intents, aunque todavía se pueden iniciar intents a\n    través de integraciones nativas.\n    (usando un plugin).</p>\n\n  <p>Flutter no tiene realmente un equivalente directo a actividades y fragmentos;\n    más bien, en Flutter se navega entre pantallas, usando un <code>Navigator</code> y <code>Route</code>,\n    todo dentro de la misma <code>Activity</code>.</p>\n\n  <p>Un <code>Route</code> es una abstracción para un “screen” o “page” de una aplicación, y un\n    <code>Navigator</code> es un widget que gestiona rutas. Un route se asimila a un <code>Activity</code>,\n    pero no tiene el mismo significado. Un navigator puede hacer push y pop de\n    routes para moverse de pantalla en pantalla. Los navegadores funcionan\n    como una pila en la que puedes hacer <code>push()</code> a nuevas rutas hacia las que\n    quieres navegar, y desde la que puedes hacer <code>pop()</code> a las rutas en las que quieres “volver atrás”.</p>\n\n  <p>En Android, declaras tus actividades dentro de la aplicación <code>AndroidManifest.xml</code>.</p>\n\n  <p>En Flutter, tienes un par de opciones para navegar entre páginas:</p>\n\n  <ul>\n    <li>Especifica un <code>Map</code> de nombres de ruta. (MaterialApp)</li>\n    <li>Navega directamente a una ruta. (WidgetApp)</li>\n  </ul>\n\n  <p>El siguiente ejemplo construye un Map.</p>\n\n  <div>  <div><pre>void main() {\n  runApp(MaterialApp(\n    home: MyAppHome(), // se convierte en la ruta nombrada '/'\n    routes: &lt;String, WidgetBuilder&gt; {\n      '/a': (BuildContext context) =&gt; MyPage(title: 'page A'),\n      '/b': (BuildContext context) =&gt; MyPage(title: 'page B'),\n      '/c': (BuildContext context) =&gt; MyPage(title: 'page C'),\n    },\n  ));\n}</pre></div></div>\n\n  <p>Navega a una ruta mediante <code>push</code> a su nombre en el <code>Navigator</code>.</p>\n\n  <div>  <div><pre>Navigator.of(context).pushNamed('/b');</pre></div></div>\n\n  <p>El otro caso de uso popular para <code>Intent</code> es llamar a componentes externos como una cámara o un\n    selector de archivos. Para ello, necesitarías crear una integración de plataforma nativa\n    (o usar un plugin existente).</p>\n\n  <p>Para obtener más información sobre cómo crear una integración de plataforma nativa, consulta\n    Desarrollando Paquetes y Plugins.</p>\n\n  <h2>\n    ¿Cómo manejo los intents entrantes desde aplicaciones externas en Flutter?</h2>\n\n  <p>Flutter puede manejar los intents entrantes de Android hablando directamente con la capa de\n    Android y solicitando los datos que se compartieron.</p>\n\n  <p>El siguiente ejemplo registra un filtro de intent para compartir texto en la actividad nativa\n    que ejecuta nuestro código Flutter, para que otras aplicaciones puedan compartir texto\n    con nuestra aplicación Flutter.</p>\n\n  <p>El flujo básico implica que primero manejemos los datos de texto compartidos en el lado\n    nativo de Android (en nuestra <code>Activity</code>), y luego esperar hasta que Flutter solicite\n    los datos para proporcionarlos usando un <code>MethodChannel</code>.</p>\n\n  <p>Primero, registra el filtro intent para todos los intents en <code>AndroidManifest.xml</code>:</p>\n\n  <div>  <div><pre>&lt;activity\n  android:name=\".MainActivity\"\n  android:launchMode=\"singleTop\"\n  android:theme=\"@style/LaunchTheme\"\n  android:configChanges=\"orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection\"\n  android:hardwareAccelerated=\"true\"\n  android:windowSoftInputMode=\"adjustResize\"&gt;\n  &lt;!-- ... --&gt;\n  &lt;intent-filter&gt;\n    &lt;action android:name=\"android.intent.action.SEND\" /&gt;\n    &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n    &lt;data android:mimeType=\"text/plain\" /&gt;\n  &lt;/intent-filter&gt;\n&lt;/activity&gt;</pre></div></div>\n\n  <p>Luego, en <code>MainActivity</code>, maneja el intent, extrae el texto que fue\n    compartido desde el intent, y consérvalo. Cuando Flutter está listo\n    para procesar, solicita los datos utilizando un canal de la plataforma\n    y su envío desde el lado nativo:</p>\n\n  <div>  <div><pre>package com.example.shared;\n\nimport android.content.Intent;\nimport android.os.Bundle;\n\nimport java.nio.ByteBuffer;\n\nimport io.flutter.app.FlutterActivity;\nimport io.flutter.plugin.common.ActivityLifecycleListener;\nimport io.flutter.plugin.common.MethodCall;\nimport io.flutter.plugin.common.MethodChannel;\nimport io.flutter.plugin.common.MethodChannel.MethodCallHandler;\nimport io.flutter.plugins.GeneratedPluginRegistrant;\n\npublic class MainActivity extends FlutterActivity {\n\n  private String sharedText;\n\n  @Override\n  protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    GeneratedPluginRegistrant.registerWith(this);\n    Intent intent = getIntent();\n    String action = intent.getAction();\n    String type = intent.getType();\n\n    if (Intent.ACTION_SEND.equals(action) &amp;&amp; type != null) {\n      if (\"text/plain\".equals(type)) {\n        handleSendText(intent); // Manejar el texto que se envía\n      }\n    }\n\n    MethodChannel(getFlutterView(), \"app.channel.shared.data\")\n      .setMethodCallHandler(MethodChannel.MethodCallHandler() {\n        @Override\n        public void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {\n          if (methodCall.method.contentEquals(\"getSharedText\")) {\n            result.success(sharedText);\n            sharedText = null;\n          }\n        }\n      });\n  }\n\n  void handleSendText(Intent intent) {\n    sharedText = intent.getStringExtra(Intent.EXTRA_TEXT);\n  }\n}</pre></div></div>\n\n  <p>Por último, solicita los datos desde el lado Flutter cuando se muestre el widget:</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample Shared App Handler',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  static const platform = const MethodChannel('app.channel.shared.data');\n  String dataShared = \"No data\";\n\n  @override\n  void initState() {\n    super.initState();\n    getSharedText();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(body: Center(child: Text(dataShared)));\n  }\n\n  getSharedText() async {\n    var sharedData = await platform.invokeMethod(\"getSharedText\");\n    if (sharedData != null) {\n      setState(() {\n        dataShared = sharedData;\n      });\n    }\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cuál es el equivalente de <code>startActivityForResult()</code>?</h2>\n\n  <p>La clase <code>Navigator</code> maneja el enrutamiento en Flutter y se utiliza para obtener un resultado de una\n    ruta a la que le hiciste push en la pila. Esto se hace mediante <code>await</code> en el <code>Future</code>\n    devuelto por <code>push()</code>.</p>\n\n  <p>Por ejemplo, para iniciar una location route que permita al usuario seleccionar su ubicación,\n    puedes hacer lo siguiente:</p>\n\n  <div>  <div><pre>Map coordinates = await Navigator.of(context).pushNamed('/location');</pre></div></div>\n\n  <p>Y luego, dentro de la  location route, una vez que el usuario haya seleccionado su\n    ubicación puedes hacer <code>pop</code> en la pila con el resultado:</p>\n\n  <div>  <div><pre>Navigator.of(context).pop({\"lat\":43.821757,\"long\":-79.226392});</pre></div></div>\n\n  <h1>UI Asíncrono</h1>\n\n  <h2>\n    ¿Cuál es el equivalente de <code>runOnUiThread()</code> en Flutter?</h2>\n\n  <p>Dart tiene un modelo de ejecución de un solo hilo, con soporte para <code>Isolate</code>\n    (una forma de ejecutar código de Dart en otro hilo), un bucle de eventos y programación asíncrona.\n    A menos que se genere un <code>Isolate</code>, el código de Dart se ejecuta en el hilo principal de la\n    UI y es controlado por un bucle de eventos. El bucle de eventos de Flutter es\n    equivalente al principal <code>Looper</code>, es decir, el <code>Looper</code> que está conectado\n    al hilo principal.</p>\n\n  <p>El modelo de un solo hilo de Dart no significa que necesites ejecutarlo todo como una\n    operación de bloqueo que hace que la UI se congele. A diferencia de Android,\n    que requiere que mantengas el hilo principal libre en todo momento, en Flutter,\n    utiliza las funciones asíncronas que proporciona el lenguaje Dart, como “async”/”await”,\n    para realizar el trabajo asíncrono. Puedes estar familiarizado con el paradigma\n    <code>async</code>/<code>await</code> si lo has usado en C#, Javascript, o si has usado\n    las corutinas de Kotlin.</p>\n\n  <p>Por ejemplo, puedes ejecutar código de red sin hacer que la UI se cuelgue\n    usando <code>async</code>/<code>await</code> y dejando que Dart haga el trabajo pesado:</p>\n\n  <div>  <div><pre>loadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}</pre></div></div>\n\n  <p>Una vez que la llamada de red <code>await</code> se haya realizado, actualiza la interfaz de usuario llamando a\n    <code>setState()</code>, que desencadena una reconstrucción del subárbol del widget y actualiza los datos.</p>\n\n  <p>El siguiente ejemplo carga datos asincrónicamente y los muestra en una <code>ListView</code>:</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n\n    loadData();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n          itemCount: widgets.length,\n          itemBuilder: (BuildContext context, int position) {\n            return getRow(position);\n          }));\n  }\n\n  Widget getRow(int i) {\n    return Padding(\n      padding: EdgeInsets.all(10.0),\n      child: Text(\"Row ${widgets[i][\"title\"]}\")\n    );\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}</pre></div></div>\n\n  <p>Consulta la siguiente sección para obtener más información sobre cómo trabajar en segundo plano\n    y en qué se diferencia Flutter de Android.</p>\n\n  <h2>\n    ¿Cómo se mueve el trabajo a un background thread?</h2>\n\n  <p>En Android, cuando deseas acceder a un recurso de red, normalmente te mueves a un background\n    thread y haces el trabajo, para no bloquear el hilo principal y evitar los ANR\n    (“Application Not Responding”). Por ejemplo, puedes estar usando un <code>AsyncTask</code>,\n    un <code>LiveData</code>, un <code>IntentService</code>, un <code>JobScheduler</code> o un pipeline RxJava con\n    un programador que trabaja sobre background threads.</p>\n\n  <p>Dado que Flutter es un hilo único y ejecuta un bucle de eventos (como Node.js),\n    no tienes que preocuparte por la gestión de hilos o por la generación de background threads.\n    Si estás realizando un trabajo de E/S, como acceso a disco o una llamada de red, puedes usar\n    <code>async</code>/<code>wait</code> con seguridad y ya está todo configurado. Si, por otro lado, necesitas hacer\n    un trabajo intensivo de computación que mantenga la CPU ocupada, quieres moverla a un\n    <code>Isolate</code> para evitar bloquear el bucle de eventos, como si mantuvieras <em>cualquier</em> tipo\n    de trabajo fuera del hilo principal en Android.</p>\n\n  <p>Para trabajos de E/S, declara la función como una función de “async”, y\n    en tareas de larga duración “await” dentro de la función:</p>\n\n  <div>  <div><pre>loadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}</pre></div></div>\n\n  <p>Así es como normalmente se hacen las llamadas de red o de base de datos, que son\n    operaciones de E/S.</p>\n\n  <p>En Android, cuando heredas de <code>AsyncTask</code>, normalmente sobrescribes 3 métodos,\n    <code>onPreExecute()</code>, <code>doInBackground()</code> y <code>onPostExecute()</code>. No hay equivalente en Flutter,\n    ya que debes <code>await</code> (esperar) en una función de larga duración, y el bucle de\n    eventos de Dart se encarga del resto.</p>\n\n  <p>Sin embargo, hay ocasiones en las que podrías estar procesando una gran cantidad de datos y tu\n    UI se bloquea. En Flutter, utiliza <code>Isolate</code> para aprovechar los múltiples núcleos de la\n    CPU para realizar tareas de larga duración o intensivas en el cálculo.</p>\n\n  <p>Los isolates son hilos de ejecución separados que no comparten ninguna memoria con la\n    memoria de ejecución principal. Esto significa que no puede acceder a las variables desde el\n    hilo principal, o actualizar su UI llamando a <code>setState()</code>. A diferencia de los hilos de\n    Android, los Isolates son fieles a su nombre y no pueden compartir memoria (en forma de\n    campos estáticos, por ejemplo).</p>\n\n  <p>El siguiente ejemplo muestra, en un isolate simple, cómo compartir datos de vuelta al hilo\n    principal para actualizar la UI.</p>\n\n  <div>  <div><pre>loadData() async {\n  ReceivePort receivePort = ReceivePort();\n  await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n  // El isolate 'echo' envía su SendPort como primer mensaje\n  SendPort sendPort = await receivePort.first;\n\n  List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n  setState(() {\n    widgets = msg;\n  });\n}\n\n// El punto de entrada para el isolate\nstatic dataLoader(SendPort sendPort) async {\n  // Open the ReceivePort for incoming messages.\n  ReceivePort port = ReceivePort();\n\n  // Notificar a otros isolates qué puerto escucha este isolate.\n  sendPort.send(port.sendPort);\n\n  await for (var msg in port) {\n    String data = msg[0];\n    SendPort replyTo = msg[1];\n\n    String dataURL = data;\n    http.Response response = await http.get(dataURL);\n    // Un montón de JSON para analizar\n    replyTo.send(json.decode(response.body));\n  }\n}\n\nFuture sendReceive(SendPort port, msg) {\n  ReceivePort response = ReceivePort();\n  port.send([msg, response.sendPort]);\n  return response.first;\n}</pre></div></div>\n\n  <p>Aquí, <code>dataLoader()</code> es el <code>Isolate</code> que se ejecuta en su propio hilo de ejecución separado.\n    En el isolate se puede realizar un procesamiento más intensivo de la CPU (por ejemplo, analizando un\n    JSON grande), o realizar cálculos matemáticos intensivos de computación, como encriptación o procesamiento de señales.</p>\n\n  <p>Puedes ejecutar el ejemplo completo a continuación:</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    if (widgets.length == 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() =&gt; ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    ReceivePort receivePort = ReceivePort();\n    await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n    // El isolate 'echo' envía su SendPort como primer mensaje\n    SendPort sendPort = await receivePort.first;\n\n    List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n    setState(() {\n      widgets = msg;\n    });\n  }\n\n  // el punto de entrada para el isolate\n  static dataLoader(SendPort sendPort) async {\n    // Abre el ReceivePort para los mensajes entrantes.\n    ReceivePort port = ReceivePort();\n\n    // Notifica a cualquier otro isolate qué puerto escucha este isolate.\n    sendPort.send(port.sendPort);\n\n    await for (var msg in port) {\n      String data = msg[0];\n      SendPort replyTo = msg[1];\n\n      String dataURL = data;\n      http.Response response = await http.get(dataURL);\n      // Mucho JSON para analizar\n      replyTo.send(json.decode(response.body));\n    }\n  }\n\n  Future sendReceive(SendPort port, msg) {\n    ReceivePort response = ReceivePort();\n    port.send([msg, response.sendPort]);\n    return response.first;\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cuál es el equivalente de OkHttp en Flutter?</h2>\n\n  <p>Realizar una llamada de red en Flutter es fácil cuando se utiliza la popular función\n    <code>http</code> package.</p>\n\n  <p>Aunque el paquete http no tiene todas las funciones que se encuentran en OkHttp, abstrae gran\n    parte de la red que normalmente se implementa por sí misma, lo que hace que sea una forma\n    sencilla de realizar llamadas de red.</p>\n\n  <p>Para usar el paquete <code>http</code>, agrégalo a tus dependencias en <code>pubspec.yaml</code>:</p>\n\n  <div>  <div><pre>dependencies:\n  ...\n  http: ^0.11.3+16</pre></div></div>\n\n  <p>Para hacer una llamada de red, llama a <code>await</code> en la función <code>async</code> (asíncrona) <code>http.get()</code>:</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n[...]\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo mostrar el progreso de una tarea de larga duración?</h2>\n\n  <p>En Android normalmente mostrarías una vista de <code>ProgressBar</code> en tu UI mientras ejecutas\n    una tarea de larga duración en un background thread.</p>\n\n  <p>En Flutter, usa un widget <code>ProgressIndicator</code>.\n    Muestra el progreso programáticamente controlando cuándo se renderiza a través de una etiqueta\n    booleana. Dile a Flutter que actualice su estado antes de que comience la tarea de larga\n    duración y que la oculte después de que termine.</p>\n\n  <p>En el siguiente ejemplo, la función de construcción se divide en tres funciones diferentes.\n    Si <code>showLoadingDialog()</code> es <code>true</code> (cuando <code>widgets.length == 0</code>), entonces\n    renderiza el <code>ProgressIndicator</code>. De lo contrario, renderiza el “ListView” con los\n    datos devueltos de una llamada de red.</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    return widgets.length == 0;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() =&gt; ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}</pre></div></div>\n\n  <h1>Estructura y recursos del proyecto</h1>\n\n  <h2>\n    ¿Dónde guardo mis archivos de imagen dependientes de la resolución?</h2>\n\n  <p>Mientras que Android trata los recursos y los assets como elementos distintos, las aplicaciones\n    Flutter sólo tienen assets. Todos los recursos que vivirían en las carpetas <code>res/drawable-*</code> de\n    Android, se colocan en una carpeta de assets para Flutter.</p>\n\n  <p>Flutter sigue un formato simple basado en la densidad como iOS. Los activos pueden ser <code>1.0x</code>,\n    <code>2.0x</code>, <code>3.0x</code>, o cualquier otro multiplicador. Flutter no tiene <code>dp</code> pero hay píxeles lógicos,\n    que son básicamente los mismos que los píxeles independientes del dispositivo.\n    El llamado\n    <code>devicePixelRatio</code>\n    expresa la proporción de píxeles físicos en un solo píxel lógico.</p>\n\n  <p>Los equivalentes a los density buckets de Android son:</p>\n\n  <table>\n    <thead>\n    <tr>\n      <th>Calificador de densidad Android</th>\n      <th>Relación de píxeles de Flutter</th>\n    </tr>\n    </thead>\n    <tbody>\n    <tr>\n      <td><code>ldpi</code></td>\n      <td><code>0.75x</code></td>\n    </tr>\n    <tr>\n      <td><code>mdpi</code></td>\n      <td><code>1.0x</code></td>\n    </tr>\n    <tr>\n      <td><code>hdpi</code></td>\n      <td><code>1.5x</code></td>\n    </tr>\n    <tr>\n      <td><code>xhdpi</code></td>\n      <td><code>2.0x</code></td>\n    </tr>\n    <tr>\n      <td><code>xxhdpi</code></td>\n      <td><code>3.0x</code></td>\n    </tr>\n    <tr>\n      <td><code>xxxhdpi</code></td>\n      <td><code>4.0x</code></td>\n    </tr>\n    </tbody>\n  </table>\n\n  <p>Los assets están localizados en cualquier carpeta arbitraria. Flutter no tiene una estructura\n    de carpetas predefinida. Usted declara los assets (con ubicación) en el archivo <code>pubspec.yaml</code>,\n    y Flutter los recoge.</p>\n\n  <p>Tenga en cuenta que antes de Flutter 1.0 beta 2, los assets definidos en Flutter no eran\n    accesibles desde el lado nativo, y viceversa, los assets y los recursos nativos no\n    estaban disponibles para Flutter, ya que vivían en carpetas separadas.</p>\n\n  <p>A partir de Flutter beta 2, los assets se almacenan en la carpeta nativa de asset, y\n    se accede a ellos desde el lado nativo usando el <code>AssetManager</code> de Android:</p>\n\n  <div>  <div><pre>val flutterAssetStream = assetManager.open(\"flutter_assets/assets/my_flutter_asset.png\")</pre></div></div>\n\n  <p>A partir de Flutter beta 2, Flutter sigue sin poder acceder a los recursos nativos,\n    ni a los assets nativos.</p>\n\n  <p>Para añadir un nuevo asset de imagen llamado <code>my_icon.png</code> a nuestro proyecto Flutter,\n    por ejemplo, y decidir qué debería vivir en una carpeta que arbitrariamente llamamos <code>images</code>,\n    pondrías la imagen base (1.0x) en la carpeta <code>images</code>, y todas las demás variantes en\n    subcarpetas llamadas con el multiplicador de proporción apropiado:</p>\n\n  <div><div><div>  <div><pre><code>images/my_icon.png       // Base: 1.0x image\nimages/2.0x/my_icon.png  // 2.0x image\nimages/3.0x/my_icon.png  // 3.0x image\n</code></pre></div></div></div></div>\n\n  <p>A continuación, deberás declarar estas imágenes en tu archivo <code>pubspec.yaml</code>:</p>\n\n  <div>  <div><pre>assets:\n - images/my_icon.jpeg</pre></div></div>\n\n  <p>A continuación, puedes acceder a tus imágenes utilizando <code>AssetImage</code>:</p>\n\n  <div>  <div><pre>return AssetImage(\"images/a_dot_burr.jpeg\");</pre></div></div>\n\n  <p>o directamente en un widget <code>Image</code>:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Image.asset(\"images/my_image.png\");\n}</pre></div></div>\n\n  <h2>\n    ¿Dónde guardo los strings? ¿Cómo gestiono la localización?</h2>\n\n  <p>Flutter actualmente no tiene un sistema de recursos dedicado para los strings. Por el momento,\n    la mejor práctica es mantener tu texto de copia en una clase como campos estáticos y acceder\n    a ellos desde allí. Por ejemplo:</p>\n\n  <div>  <div><pre>class Strings {\n  static String welcomeMessage = \"Welcome To Flutter\";\n}</pre></div></div>\n\n  <p>Luego, en tu código, puedes acceder a tus strings como tal:</p>\n\n  <div>  <div><pre>Text(Strings.welcomeMessage)</pre></div></div>\n\n  <p>Flutter tiene soporte básico para la accesibilidad en Android, aunque esta característica\n    es un trabajo en progreso.</p>\n\n  <p>Se recomienda a los desarrolladores de Flutter que utilicen el\n    paquete intl para la internacionalización y\n    localización.</p>\n\n  <h2>\n    ¿Cuál es el equivalente a un archivo Gradle? ¿Cómo puedo añadir dependencias?</h2>\n\n  <p>En Android, puedes añadir dependencias añadiéndolas a tu script de construcción de Gradle.\n    Flutter utiliza el sistema de construcción propio de Dart y el gestor de paquetes de Pub.\n    Las herramientas delegan la creación de las aplicaciones envolventes nativas de Android\n    e iOS a los respectivos sistemas de creación.</p>\n\n  <p>Aunque hay archivos Gradle bajo la carpeta <code>android</code> en tu proyecto Flutter, sólo puedes\n    usarlos si estás añadiendo dependencias nativas necesarias para\n    integración por plataforma. En general, usa <code>pubspec.yaml</code> para declarar\n    dependencias externas para usar en Flutter. Un buen lugar para encontrar paquetes de Flutter es\n    Pub.</p>\n\n  <h1>Actividades y fragmentos</h1>\n\n  <h2>\n    ¿Cuál es el equivalente de actividades y fragmentos en Flutter?</h2>\n\n  <p>En Android, un “ Activity “ representa una sola cosa enfocada que el usuario puede hacer. Un\n    “Fragment” representa un comportamiento o una parte de la interfaz de usuario. Los fragmentos son\n    una forma de modularizar el código, componer interfaces de usuario sofisticadas para pantallas más\n    grandes y ayudar a escalar la UI de la aplicación. En Flutter, ambos conceptos caen\n    bajo el paraguas de <code>Widget</code>.</p>\n\n  <p>Para aprender más sobre el sistema de construcción de UI con Activities y Fragments, mira\n    el árticulo contribuido por la comunidad en medium,\n    Flutter For Android Developers : How to design an Activity UI in\n      Flutter.</p>\n\n  <p>Como se mencionó en la sección Intents,\n    las pantallas en Flutter están representadas por <code>Widgets</code> ya que todo es un widget\n    en Flutter. Usas un <code>Navigator</code> para moverte entre diferentes <code>Routes</code>\n    que representan diferentes pantallas o páginas, o tal vez sólo diferentes estados o\n    representaciones de los mismos datos.</p>\n\n  <h2>\n    ¿Cómo escucho los eventos del ciclo de vida de las actividades Android?</h2>\n\n  <p>En Android, puedes sobreescribir los métodos de <code>Activity</code> para capturar métodos del\n    ciclo de vida para la actividad en sí, o registrar <code>ActivityLifecycleCallbacks</code>\n    en <code>Application</code>. En Flutter, no tienes este concepto, pero puedes escuchar\n    los eventos del ciclo de vida enganchándote al observador <code>WidgetsBinding</code>\n    y escuchando el evento de cambio <code>didChangeAppLifecycleState()</code>.</p>\n\n  <p>Los eventos observables del ciclo de vida son:</p>\n\n  <ul>\n    <li>\n      <code>inactive</code> — La aplicación se encuentra en un estado inactivo y no está recibiendo entradas del\n      usuario. Este evento sólo funciona en iOS, ya que no hay ningún evento equivalente asimilable en\n      Android.</li>\n    <li>\n      <code>paused</code> — La aplicación no está actualmente visible para el usuario, no responde a las entradas\n      del usuario y se ejecuta en background. Esto equivale a <code>onPause()</code>\n      en Android</li>\n    <li>\n      <code>resumed</code> — La aplicación es visible y responde a las entradas del usuario. Esto equivale a\n      <code>onPostResume()</code> en Android</li>\n    <li>\n      <code>suspending</code> — La aplicación se suspende momentáneamente. Esto es equivalente a “onStop”\n      en Android; no se activa en iOS ya que no hay ningún evento\n      equivalente asimilable en iOS.</li>\n  </ul>\n\n  <p>Para más detalles sobre el significado de estos estados, consulta la sección\n    Documentation de <code>AppLifecycleStatus</code> .</p>\n\n  <p>Como habrás notado, sólo una pequeña minoría de los eventos del ciclo de vida de Activity están\n    disponibles; mientras que <code>FlutterActivity</code> captura casi todo el ciclo de vida de la actividad\n    internamente y los envía al motor Flutter, la mayoría están protegidos lejos de ti. Flutter se\n    encarga de arrancar y parar el motor por ti, y hay pocas razones para observar el ciclo de vida\n    de la actividad en Flutter en la mayoría de los casos. Si necesita observar el ciclo de vida\n    para adquirir o liberar cualquier recurso nativo, es probable que lo haga desde el\n    lado nativo, en cualquier caso.</p>\n\n  <p>He aquí un ejemplo de cómo observar el estado del ciclo de vida del activity contenedor:</p>\n\n  <div>  <div><pre>import 'package:flutter/widgets.dart';\n\nclass LifecycleWatcher extends StatefulWidget {\n  @override\n  _LifecycleWatcherState createState() =&gt; _LifecycleWatcherState();\n}\n\nclass _LifecycleWatcherState extends State&lt;LifecycleWatcher&gt; with WidgetsBindingObserver {\n  AppLifecycleState _lastLifecycleState;\n\n  @override\n  void initState() {\n    super.initState();\n    WidgetsBinding.instance.addObserver(this);\n  }\n\n  @override\n  void dispose() {\n    WidgetsBinding.instance.removeObserver(this);\n    super.dispose();\n  }\n\n  @override\n  void didChangeAppLifecycleState(AppLifecycleState state) {\n    setState(() {\n      _lastLifecycleState = state;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    if (_lastLifecycleState == null)\n      return Text('This widget has not observed any lifecycle changes.', textDirection: TextDirection.ltr);\n\n    return Text('The most recent lifecycle state this widget observed was: $_lastLifecycleState.',\n        textDirection: TextDirection.ltr);\n  }\n}\n\nvoid main() {\n  runApp(Center(child: LifecycleWatcher()));\n}</pre></div></div>\n\n  <h1>Layouts</h1>\n\n  <h2>\n    ¿Cuál es el equivalente de un LinearLayout?</h2>\n\n  <p>En Android, se utiliza un layout lineal para distribuir los widgets\n    de forma lineal, ya sea horizontal o vertical.\n    En Flutter, utiliza el widget Row o Column para\n    conseguir el mismo resultado.</p>\n\n  <p>Si lo notas, los dos ejemplos de código son idénticos con la\n    excepción del widget “Row” y “Column”. Los hijos son los mismos\n    y esta característica puede ser explotada para desarrollar\n    layouts detallados que pueden cambiar con los mismos hijos.</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Row(\n    mainAxisAlignment: MainAxisAlignment.center,\n    children: &lt;Widget&gt;[\n      Text('Row One'),\n      Text('Row Two'),\n      Text('Row Three'),\n      Text('Row Four'),\n    ],\n  );\n}</pre></div></div>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Column(\n    mainAxisAlignment: MainAxisAlignment.center,\n    children: &lt;Widget&gt;[\n      Text('Column One'),\n      Text('Column Two'),\n      Text('Column Three'),\n      Text('Column Four'),\n    ],\n  );\n}</pre></div></div>\n\n  <p>Para obtener más información sobre la creación de linear layouts, consulta el artículo de medium\n    Flutter para Android Developers: ¿Cómo diseñar LinearLayout\n      en Flutter?.</p>\n\n  <h2>\n    ¿Cuál es el equivalente de un RelativeLayout?</h2>\n\n  <p>Un RelativeLayout dispone sus widgets en relación con los demás. En\n    Flutter, hay algunas maneras de lograr el mismo resultado.</p>\n\n  <p>Puedes obtener el resultado de un RelativeLayout utilizando una combinación de\n    Widgets Column, Row y Stack. Puedes especificar reglas para los widgets\n    constructores sobre cómo están dispuestos los hijos en relación con el padre.</p>\n\n  <p>Para un buen ejemplo de cómo construir un RelativeLayout en Flutter,\n    consulta la respuesta de Collin en\n    StackOverflow.</p>\n\n  <h2>\n    ¿Cuál es el equivalente de un ScrollView?</h2>\n\n  <p>En Android, usas un ScrollView para diseñar tus widgets, si el dispositivo del usuario\n    tiene una pantalla más pequeña que tu contenido, hará scroll.</p>\n\n  <p>En Flutter, la forma más fácil de hacerlo es utilizando el widget ListView.\n    Esto puede parecer exagerado viniendo de Android, pero en Flutter un widget\n    ListView es tanto un ScrollView como un Android ListView.</p>\n\n  <!-- skip -->\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return ListView(\n    children: &lt;Widget&gt;[\n      Text('Row One'),\n      Text('Row Two'),\n      Text('Row Three'),\n      Text('Row Four'),\n    ],\n  );\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo manejo la transición a landscape en Flutter?</h2>\n\n  <p>FlutterView maneja el cambio de configuración si AndroidManifest.xml contiene:</p>\n\n  <div>  <div><pre>android:configChanges=\"orientation|screenSize\"</pre></div></div>\n\n  <h1>Detección de gestos y manejo de eventos táctiles</h1>\n\n  <h2>\n    ¿Cómo puedo añadir un listener onClick a un widget en Flutter?</h2>\n\n  <p>En Android, puedes vincular onClick a vistas como el botón llamando al\n    método ‘setOnClickListener’.</p>\n\n  <p>En Flutter hay dos maneras de añadir listeners táctiles:</p>\n\n  <ol>\n    <li>\n      <p>Si el Widget soporta la detección de eventos, pásale una función y adminístrala en la función.\n        Por ejemplo, el RaisedButton tiene un parámetro <code>onPressed</code>:</p>\n\n      <!-- skip -->\n      <div>\n        <div><div>  <div><pre><code>@override\nWidget build(BuildContext context) {\n  return RaisedButton(\n      onPressed: () {\n        print(\"click\");\n      },\n      child: Text(\"Button\"));\n}\n</code></pre></div></div></div>    </div>\n    </li>\n    <li>\n      <p>Si el Widget no soporta la detección de eventos, envuelve el widget en un GestureDetector y\n        pásale una función al parámetro <code>onTap</code>.</p>\n\n      <!-- skip -->\n      <div>\n        <div><div>  <div><pre><code>class SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        body: Center(\n      child: GestureDetector(\n        child: FlutterLogo(\n          size: 200.0,\n        ),\n        onTap: () {\n          print(\"tap\");\n        },\n      ),\n    ));\n  }\n}\n</code></pre></div></div></div>    </div>\n    </li>\n  </ol>\n\n  <h2>\n    ¿Cómo puedo manejar otros gestos en los widgets?</h2>\n\n  <p>Usando el GestureDetector, puedes escuchar una amplia gama de Gestos como:</p>\n\n  <ul>\n    <li>\n      <p>Tap</p>\n\n      <ul>\n        <li>\n          <code>onTapDown</code> - Un puntero que podría provocar un toque ha entrado en contacto con la pantalla en\n          una ubicación determinada.</li>\n        <li>\n          <code>onTapUp</code> - Un puntero que activa un toque ha dejado de entrar en contacto con la pantalla en\n          una ubicación determinada.</li>\n        <li>\n          <code>onTap</code> - Se ha producido un toque.</li>\n        <li>\n          <code>onTapCancel</code> - El puntero que desencadenó previamente el onTapDown\n          no causará un toque.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Double tap</p>\n\n      <ul>\n        <li>\n          <code>onDoubleTap</code> - El usuario tocó la pantalla en la misma ubicación dos veces en una\n          sucesión rápida.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Long press</p>\n\n      <ul>\n        <li>\n          <code>onLongPress</code> - Un puntero ha permanecido en contacto con la pantalla en el mismo lugar\n          durante un largo período de tiempo.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Vertical drag</p>\n\n      <ul>\n        <li>\n          <code>onVerticalDragStart</code> - Un puntero ha entrado en contacto con la pantalla y puede comenzar a\n          moverse verticalmente.</li>\n        <li>\n          <code>onVerticalDragUpdate</code> - Un puntero en contacto con la pantalla se ha movido más\n          en la dirección vertical.</li>\n        <li>\n          <code>onVerticalDragEnd</code> - Un puntero que anteriormente estaba en contacto con la pantalla y\n          se movía verticalmente ya no está en contacto con la pantalla y se movía a una velocidad\n          específica cuando dejó de entrar en contacto con la pantalla.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Horizontal drag</p>\n\n      <ul>\n        <li>\n          <code>onHorizontalDragStart</code> - Un puntero ha entrado en contacto con la pantalla y puede comenzar a\n          moverse horizontalmente.</li>\n        <li>\n          <code>onHorizontalDragUpdate</code> - Un puntero en contacto con la pantalla se ha movido más en la\n          dirección horizontal.\n          <ul>\n            <li>\n              <code>onHorizontalDragEnd</code> - Un punter que estuvo previamente en contacto con la pantalla y que\n              se movía horizontalmente ya no está en contacto con la pantalla y se movía a una velocidad\n              específica cuando dejo de estar en contacto con la pantalla.</li>\n          </ul>\n        </li>\n      </ul>\n    </li>\n  </ul>\n\n  <p>El siguiente ejemplo muestra un GestureDetector que rota el logotipo de Flutter con\n    un doble toque:</p>\n\n  <div>  <div><pre>AnimationController controller;\nCurvedAnimation curve;\n\n@override\nvoid initState() {\n  controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n  curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        body: Center(\n          child: GestureDetector(\n            child: RotationTransition(\n                turns: curve,\n                child: FlutterLogo(\n                  size: 200.0,\n                )),\n            onDoubleTap: () {\n              if (controller.isCompleted) {\n                controller.reverse();\n              } else {\n                controller.forward();\n              }\n            },\n        ),\n    ));\n  }\n}</pre></div></div>\n\n  <h1>Listviews &amp; adapters</h1>\n\n  <h2>\n    ¿Cuál es la alternativa a un ListView en Flutter?</h2>\n\n  <p>El equivalente a un ListView en Flutter es… ¡un ListView!</p>\n\n  <p>En una ListView de Android, creas un adaptador y lo pasas a ListView,\n    que muestra cada fila con lo que devuelve tu adaptador. Sin embargo,\n    tienes que asegurarte de reciclar tus filas,\n    de lo contrario, tendrás todo tipo de problemas visuales y de memoria.</p>\n\n  <p>Debido al patrón inmutable de widgets de Flutter, pasas una\n    lista de widgets a tu ListView, y Flutter se encarga de asegurarse\n    de que el desplazamiento sea rápido y fluido.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List&lt;Widget&gt; widgets = [];\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row $i\")));\n    }\n    return widgets;\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo sé en cuál elemento de la lista se hace clic?</h2>\n\n  <p>En Android, ListView tiene el método ‘onItemClickListener’ para averiguar en cuál de los\n    elementos se ha hecho clic.\n    En Flutter, utiliza el manejo táctil proporcionado por los widgets pasados.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List&lt;Widget&gt; widgets = [];\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(GestureDetector(\n        child: Padding(\n            padding: EdgeInsets.all(10.0),\n            child: Text(\"Row $i\")),\n        onTap: () {\n          print('row tapped');\n        },\n      ));\n    }\n    return widgets;\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo actualizo ListView dinámicamente?</h2>\n\n  <p>En Android, actualizas el adaptador y llamas a <code>notifyDataSetChanged</code>.</p>\n\n  <p>En Flutter, si actualizaras la lista de widgets dentro de un <code>setState()</code>,\n    rápidamente te darás cuenta de que tus datos no han cambiado visualmente.\n    Esto se debe a que cuando se llama <code>setState()</code>, el motor de renderizado de Flutter\n    mira el árbol de widgets para ver si algo ha cambiado. Cuando llegue a tu\n    <code>ListView</code>, realiza una comprobación <code>===</code>, y determina que los dos <code>ListView</code> son los\n    mismos. No ha cambiado nada, por lo que no se requiere ninguna actualización.</p>\n\n  <p>Una forma sencilla de actualizar tu <code>ListView</code>, es creando una nueva <code>List</code>\n    dentro de la sección <code>setState()</code>, y copias los datos de la lista anterior a la nueva lista.\n    Aunque este enfoque es simple, no se recomienda para conjuntos de datos grandes,\n    como se muestra en el siguiente ejemplo.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = &lt;Widget&gt;[];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: widgets),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n          padding: EdgeInsets.all(10.0),\n          child: Text(\"Row $i\")),\n      onTap: () {\n        setState(() {\n          widgets = List.from(widgets);\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}</pre></div></div>\n\n  <p>La manera recomendada, eficiente y efectiva de construir una lista, es utilizando un\n    ListView.Builder. Este método es excelente cuando se tiene una lista dinámica o una\n    lista con grandes cantidades de datos. Esto es esencialmente\n    el equivalente de RecyclerView en Android, que automáticamente\n    recicla los elementos de la lista por ti.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = &lt;Widget&gt;[];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: ListView.builder(\n            itemCount: widgets.length,\n            itemBuilder: (BuildContext context, int position) {\n              return getRow(position);\n            }));\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n          padding: EdgeInsets.all(10.0),\n          child: Text(\"Row $i\")),\n      onTap: () {\n        setState(() {\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}</pre></div></div>\n\n  <p>En lugar de crear un “ListView”, crea un ListView.builder que\n    toma dos parámetros clave: la longitud inicial de la lista\n    y una funcion ItemBuilder.</p>\n\n  <p>La función ItemBuilder es similar a la función <code>getView</code> en un\n    adaptador Android; toma una posición y devuelve la fila que quieres\n    que se muestre en esa posición.</p>\n\n  <p>Finalmente, pero lo más importante, nota que la función <code>onTap()</code>\n    ya no recrea la lista, sino la adiciona a ella mediante <code>.add</code>.</p>\n\n  <h1>Trabajar con texto</h1>\n\n  <h2>\n    ¿Cómo configuro fuentes personalizadas en mis widgets Text?</h2>\n\n  <p>En el SDK de Android (a partir de Android O), creas un archivo Font resource y lo\n    pasas al parámetro FontFamily para su TextView.</p>\n\n  <p>En Flutter, coloca el archivo de fuente en una carpeta y haz referencia a\n    él en el archivo <code>pubspec.yaml</code>, de forma similar a como importas imágenes.</p>\n\n  <div>  <div><pre>fonts:\n   - family: MyCustomFont\n     fonts:\n       - asset: fonts/MyCustomFont.ttf\n       - style: italic</pre></div></div>\n\n  <p>A continuación, asigna la fuente a tu widget <code>Text</code>:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: Text(\n        'This is a custom font text',\n        style: TextStyle(fontFamily: 'MyCustomFont'),\n      ),\n    ),\n  );\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo cambiar el estilo de mis widgets Text?</h2>\n\n  <p>Junto con las fuentes, puedes personalizar otros elementos de estilo en un widget <code>Text</code>.\n    El parámetro de estilo de un widget <code>Text</code> toma un objeto <code>TextStyle</code>, donde puedes\n    personalizar muchos parámetros, como, por ejemplo:</p>\n\n  <ul>\n    <li>color</li>\n    <li>decoration</li>\n    <li>decorationColor</li>\n    <li>decorationStyle</li>\n    <li>fontFamily</li>\n    <li>fontSize</li>\n    <li>fontStyle</li>\n    <li>fontWeight</li>\n    <li>hashCode</li>\n    <li>height</li>\n    <li>inherit</li>\n    <li>letterSpacing</li>\n    <li>textBaseline</li>\n    <li>wordSpacing</li>\n  </ul>\n\n  <h1>Entrada de formulario</h1>\n\n  <p>Para obtener más información sobre la utilización de formularios, consulta\n    Recuperar el valor de un campo de texto,\n    en el Cookbook de Flutter.</p>\n\n  <h2>\n    ¿Cuál es el equivalente a un “hint” sobre un Input?</h2>\n\n  <p>En Flutter, puedes mostrar fácilmente un “hint” o un texto placeholder para tu\n    entrada añadiendo un objeto InputDecoration al parámetro constructor de decoración para\n    el Widget Text.</p>\n\n  <div>  <div><pre>body: Center(\n  child: TextField(\n    decoration: InputDecoration(hintText: \"This is a hint\"),\n  )\n)</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo mostrar los errores de validación?</h2>\n\n  <p>Al igual que lo harías con un “ hint “, pasa un objeto InputDecoration\n    al constructor de decoración para el widget Text.</p>\n\n  <p>Sin embargo, no querrás empezar mostrando un error. En su lugar, cuando el\n    usuario haya introducido datos no válidos, actualiza el estado y\n    pasa un nuevo objeto <code>InputDecoration</code>.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  String _errorText;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: TextField(\n          onSubmitted: (String text) {\n            setState(() {\n              if (!isEmail(text)) {\n                _errorText = 'Error: This is not an email';\n              } else {\n                _errorText = null;\n              }\n            });\n          },\n          decoration: InputDecoration(hintText: \"This is a hint\", errorText: _getErrorText()),\n        ),\n      ),\n    );\n  }\n\n  _getErrorText() {\n    return _errorText;\n  }\n\n  bool isEmail(String em) {\n    String emailRegexp =\n        r'^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$';\n\n    RegExp regExp = RegExp(emailRegexp);\n\n    return regExp.hasMatch(em);\n  }\n}</pre></div></div>\n\n  <h1>Flutter plugins</h1>\n\n  <h2>\n    ¿Cómo accedo al sensor de GPS?</h2>\n\n  <p>Usa el plugin de la comunidad <code>geolocator</code>.</p>\n\n  <h2>\n    ¿Cómo accedo a la cámara?</h2>\n\n  <p>El plugin <code>image_picker</code> es popular\n    para acceder a la cámara.</p>\n\n  <h2>\n    ¿Cómo me autentico con Facebook?</h2>\n\n  <p>Para iniciar sesión con Facebook, utiliza el plugin de la comunidad\n    <code>flutter_facebook_login</code>.</p>\n\n  <h2>\n    ¿Cómo uso las características de Firebase?</h2>\n\n  <p>La mayoría de las funciones de Firebase están cubiertas por\n    plugins de primera parte.\n    Estos plugins de primera mano son integraciones mantenidas por el equipo de Flutter:</p>\n\n  <ul>\n    <li>\n      <code>firebase_admob</code> para Firebase AdMob</li>\n    <li>\n      <code>firebase_analytics</code> para Firebase Analytics</li>\n    <li>\n      <code>firebase_auth</code> para Firebase Auth</li>\n    <li>\n      <code>firebase_database</code> para Firebase RTDB</li>\n    <li>\n      <code>firebase_storage</code> para Firebase Cloud Storage</li>\n    <li>\n      <code>firebase_messaging</code> para Firebase Messaging (FCM)</li>\n    <li>\n      <code>flutter_firebase_ui</code> para integraciones rápidas con Firebase Auth (Facebook, Google, Twitter y email)</li>\n    <li>\n      <code>cloud_firestore</code> para Firebase Cloud Firestore</li>\n  </ul>\n\n  <p>También puedes encontrar algunos plugins Firebase de terceros en Pub que cubren\n    áreas que no están directamente cubiertas por los plugins de primera mano.</p>\n\n  <h2>\n    ¿Cómo puedo crear mis propias integraciones nativas personalizadas?</h2>\n\n  <p>Si hay funcionalidades específicas de la plataforma que en Flutter o en sus plugins de la\n    comunidad no estén disponibles, puedes construir los tuyos propios siguiendo\n    la página desarrollo de paquetes y plugins.</p>\n\n  <p>La arquitectura de los plugins de Flutter, en pocas palabras, es muy parecida a la de un\n    bus Event en Android: tú disparas un mensaje y dejas que el receptor lo procese y\n    te devuelva el resultado. En este caso, el receptor es código que se ejecuta en el\n    lado nativo de Android o iOS.</p>\n\n  <h2>\n    ¿Cómo utilizo el NDK en mi aplicación Flutter?</h2>\n\n  <p>Si utilizas el NDK en tu aplicación Android actual y quieres que tu aplicación\n    Flutter aproveche las bibliotecas nativas, es posible crear un\n    plugin personalizado.</p>\n\n  <p>Tu plugin personalizado primero habla con tu aplicación Android, donde llamas\n    a tus funciones <code>nativas</code> sobre JNI. Una vez que la respuesta esté lista,\n    envía un mensaje a Flutter y muestra el resultado.</p>\n\n  <p><em>Actualmente no se admite la llamada a código nativo directamente desde Flutter.</em></p>\n\n  <h1>Themes</h1>\n\n  <h2>\n    ¿Cómo puedo ponerle un theme a mi aplicación?</h2>\n\n  <p>De fábrica, Flutter viene con una hermosa implementación de Material Design,\n    que se encarga de un montón de necesidades de estilo y tematización que típicamente harías.\n    A diferencia de Android, donde se declaran los themes en XML y luego se asignan\n    a tu aplicación usando AndroidManifest.xml, en Flutter declaras themes\n    en el widget de nivel superior.</p>\n\n  <p>Para aprovechar al máximo los componentes de Material en tu aplicación,\n    puedes declarar un widget de nivel superior <code>MaterialApp</code> como punto de entrada\n    a tu aplicación. MaterialApp es un widget de conveniencia que incluye una\n    serie de widgets que son comúnmente requeridos para las aplicaciones que\n    implementan Material Design. Se basa en un WidgetsApp añadiendo funcionalidad específica de Material.</p>\n\n  <p>También puedes usar un <code>WidgetApp</code> como su widget de aplicación, que\n    proporciona algunas de las mismas funcionalidades, pero no es tan completa como <code>MaterialApp</code>.</p>\n\n  <p>Para personalizar los colores y estilos de cualquier componente hijo, pasa un objeto\n    <code>ThemeData</code> al widget <code>MaterialApp</code>. Por ejemplo, en el siguiente código,\n    la muestra primaria se establece en azul y el color de selección de texto es rojo.</p>\n\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textSelectionColor: Colors.red\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}</pre></div></div>\n\n  <h1>Bases de datos y almacenamiento local</h1>\n\n  <h2>\n    ¿Cómo puedo acceder a las Preferencias Compartidas?</h2>\n\n  <p>En Android, puedes almacenar una pequeña colección de parejas clave-valor utilizando la API\n    de preferencias compartidas.</p>\n\n  <p>En Flutter, accedemos a esta funcionalidad mediante el\n    Plugin Shared_Preferences.\n    Este plugin envuelve la funcionalidad de ambas Preferencias Compartidas y\n    NSUserDefaults (el equivalente en iOS).</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nvoid main() {\n  runApp(\n    MaterialApp(\n      home: Scaffold(\n        body: Center(\n          child: RaisedButton(\n            onPressed: _incrementCounter,\n            child: Text('Increment Counter'),\n          ),\n        ),\n      ),\n    ),\n  );\n}\n\n_incrementCounter() async {\n  SharedPreferences prefs = await SharedPreferences.getInstance();\n  int counter = (prefs.getInt('counter') ?? 0) + 1;\n  print('Pressed $counter times.');\n  prefs.setInt('counter', counter);\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo accedo a SQLite en Flutter?</h2>\n\n  <p>En Android, se utiliza SQLite para almacenar datos estructurados que se pueden\n    consultar usando SQL.</p>\n\n  <p>En Flutter, puedes acceder a esta función mediante el plugin\n    SQFlite.</p>\n\n  <h1>Notificaciones</h1>\n\n  <h2>\n    ¿Cómo configuro las notificaciones push?</h2>\n\n  <p>En Android, se utiliza Firebase Cloud Messaging para configurar\n    notificaciones push para tu aplicación.</p>\n\n  <p>En Flutter, puedes acceder a esta función mediante\n    el plugin\n    Firebase_Messaging.\n    Para obtener más información sobre el uso de la API Firebase Cloud Messaging, consulta la\n    documentation del plugin\n    <code>firebase_messaging</code>.</p>\n</div>"
    },
    {
        "title": "5.2 Flutter para iOS devs",
        "subtitle": "Introduccion",
        "content":  "<div>\n  <h1>Flutter para desarrolladores iOS</h1>\n  <div>    \n      Contenidos    \n    <ul>\n      <li>¿Cuál es el equivalente a un UIView en Flutter?</li>\n      <li>¿Cómo actualizo Widgets?</li>\n      <li>¿Cómo diseño mis widgets? ¿Dónde está mi Storyboard?</li>\n      <li>¿Cómo agrego o elimino un componente de mi layout?</li>\n      <li>¿Cómo puedo animar un Widget?</li>\n      <li>¿Cómo puedo dibujar en la pantalla?</li>\n      <li>¿Dónde está la opacidad del widget?</li>\n      <li>¿Cómo construyo widgets personalizados?</li>\n      <li>¿Cómo desplazarse entre páginas?</li>\n      <li>¿Cómo puedo navegar a otra aplicación?</li>\n      <li>¿Cómo puedo volver al al viewcontroller nativo de iOS?</li>\n      <li>¿Cómo se puede escribir código asíncrono?</li>\n      <li>¿Cómo se mueve el trabajo a un hilo en segundo plano?</li>\n      <li>Cómo puedo hacer peticiones de red?</li>\n      <li>¿Cómo puedo mostrar el progreso de una tarea de larga duración?</li>\n      <li>¿Cómo puedo incluir assets de imagen para Flutter? ¿Qué pasa con las resoluciones múltiples?</li>\n      <li>¿Dónde guardo las cadenas? ¿Cómo gestiono la localización?</li>\n      <li>¿Cuál es el equivalente de Cocoapods? ¿Cómo puedo añadir dependencias?</li>\n      <li>¿Cual es el equivalente a un ViewController en Flutter?</li>\n      <li>¿Cómo escuchar los eventos del ciclo de vida de iOS?</li>\n      <li>¿Cuál es el equivalente de un UITableView o UICollectionView en Flutter?</li>\n      <li>¿Cómo sé en qué elemento de la lista se ha hecho clic?</li>\n      <li>¿Cómo puedo actualizar dinámicamente un ListView?</li>\n      <li>¿Cuál es el equivalente de un ScrollView en Flutter?</li>\n      <li>¿Cómo puedo añadir un click listener a un widget en Flutter?</li>\n      <li>¿Cómo puedo gestionar otros gestos en los widgets?</li>\n      <li>¿Cómo se crea un theme para una aplicación?</li>\n      <li>¿Cómo configuro fuentes personalizadas en mis widgets Text?</li>\n      <li>¿Cómo doy estilos a mis widgets Text?</li>\n      <li>¿Cómo funcionan los formularios en Flutter? ¿Cómo puedo recuperar los datos introducidos por el usuario?</li>\n      <li>¿Cuál es el equivalente de un placeholder en un campo de texto?</li>\n      <li>¿Cómo puedo mostrar los errores de validación?</li>\n      <li>¿Cómo interactúo con la plataforma y con el código nativo de la plataforma?</li>\n      <li>¿Cómo accedo al sensor GPS?</li>\n      <li>¿Cómo accedo a la cámara?</li>\n      <li>¿Cómo me conecto con Facebook?</li>\n      <li>¿Cómo uso las funciones de Firebase?</li>\n      <li>¿Cómo puedo crear mis propias integraciones nativas personalizadas?</li>\n      <li>¿Cómo accedo a UserDefaults en Flutter?</li>\n      <li>¿Cuál es el equivalente a CoreData en Flutter?</li>\n      <li>¿Cómo configuro las notificaciones push?</li>\n    </ul>\n  </div>\n  <p>Este documento es para desarrolladores en iOS que buscan aplicar su conocimiento existente sobre iOS\n    para construir aplicaciones móviles con Flutter. Si entiendes los fundamentos del framework de\n    trabajo de iOS, entonces puedes usar este documento como una forma de empezar a aprender a\n    desarrollar con Flutter.</p>\n\n  <p>Antes de introducirte en este documento, quizás quieras ver este vídeo de 15 minutos del\n    canal de Youtube de Flutter sobre\n    el paquete Cupertino.</p>  \n\n  <p>Tus conocimientos y habilidades sobre iOS son muy valiosos cuando construyes con\n    Flutter, porque Flutter se apoya en el sistema operativo móvil para numerosas\n    capacidades y configuraciones. Flutter es una nueva forma de crear interfaces de usuario\n    para móviles, pero tiene un sistema de plugin para comunicarse con (iOS y Android) para tareas\n    que no sean de interfaz de usuario. Si eres un experto en desarrollo iOS, no tienes que\n    volver a aprenderlo todo para usar Flutter.</p>\n\n  <p>Flutter también hace un gran número de adaptaciones en el framework por ti\n    cuando se ejecuta en iOS. Para un listado, mira Adaptaciones de Plataforma.</p>\n\n  <p>Este documento puede ser utilizado como un cookbook, puedes saltar entre sus secciones y\n    encontrar las preguntas que son más relevantes a tus necesidades.</p>\n\n  <h1>Vistas</h1>\n\n  <h2>\n    ¿Cuál es el equivalente a un <code>UIView</code> en Flutter?</h2>\n\n  <aside class=\"alert alert-secondary\" role=\"alert\">\n    <p>¿Como de diferente son el estilo reactivo, o declarativo, que\n      el estilo tradicional imperativo?\n      Para una comparación, mira Introducción a UI\n        declarativo.</p>\n  </aside>\n\n  <p>En iOS, la mayor parte de lo que se crea en la interfaz de usuario se hace utilizando objetos\n    de vista, que son de la clase  <code>UIView</code>. Estos pueden actuar como contenedores para otras <code>UIView</code>,\n    que forman tu layout.</p>\n\n  <p>En Flutter, el equivalente aproximado a un <code>UIView</code> es un <code>Widget</code>. Los Widgets no se asimilan\n    exactamente a las vistas de iOS, pero mientras te familiarizas con el funcionamiento de Flutter\n    puedes pensar en ellos como “la forma en que declaras y construyes la interfaz de usuario”.</p>\n\n  <p>Sin embargo, estos tienen algunas diferencias con un <code>UIView</code>. Para empezar, los widgets tienen\n    diferentes vidas útiles: son inmutables y sólo existen hasta que necesitan ser cambiados.\n    Cada vez que los widgets o su estado cambian, el framework de Flutter crea\n    un nuevo árbol de instancias de widgets. En comparación, una vista iOS no se recrea cuando\n    cambia, sino que es una entidad mutable que se dibuja una vez y no lo hace\n    redibujar hasta que se invalide usando <code>setNeedsDisplay()</code>.</p>\n\n  <p>Además, a diferencia de <code>UIView</code>, los widgets de Flutter son ligeros, en parte debido\n    a su inmutabilidad. Porque no son puntos de vista en sí mismos, y no están dibujando nada\n    directamente, sino que son una descripción de la UI y su semántica que se “inflan” en objetos de\n    vistas reales.</p>\n\n  <p>Flutter incluye la librería Material Components.\n    Estos son los widgets que implementan las\n    Material Design guidelines. El diseño de Material Design es un\n    sistema de diseño flexible optimizado para todas\n      las plataformas,\n    incluyendo iOS.</p>\n\n  <p>Pero Flutter es lo suficientemente flexible y expresivo como para implementar cualquier lenguaje de diseño.\n    En iOS, puedes utilizar los Cupertino widgets\n    para producir una interfaz que se parezca al\n    Lenguaje de diseño iOS de Apple.</p>\n\n  <h2>\n    ¿Cómo actualizo <code>Widgets</code>?</h2>\n\n  <p>Para actualizar tus vistas en iOS, los transformas directamente. En Flutter, los widgets son\n    inmutables y no actualizables directamente. En su lugar, tienes que manipular el\n    estado del widget.</p>\n\n  <p>Aquí es donde el concepto de los widgets Stateful vs Stateless\n    entra en escena. Un <code>StatelessWidget</code> es justo lo que suena como un widget sin\n    estado adjunto.</p>\n\n  <p>Los <code>StatelessWidgets</code> son útiles cuando la parte de la interfaz de usuario que usted está\n    describiendo no depende de nada más que de la configuración inicial\n    información en el widget.</p>\n\n  <p>Por ejemplo, en iOS, esto es similar a colocar un <code>UIImageView</code> con\n    su logo como la <code>image</code>. Si el logotipo no cambia durante el tiempo de ejecución,\n    usa un <code>StatelessWidget</code> en Flutter.</p>\n\n  <p>Si deseas cambiar dinámicamente la interfaz de usuario basándose en los datos recibidos después de hacer una\n    llamada HTTP, utiliza un <code>StatefulWidget</code>. Después de que la llamada HTTP se haya\n    completado, avisa al framework de Flutter que el <code>State</code> del widget ha sido\n    actualizado, para que pueda actualizar la interfaz de usuario.</p>\n\n  <p>La diferencia importante entre stateless y stateful widgets es que <code>StatefulWidget</code>s tiene un\n    objeto <code>State</code> que almacena el estado de los datos y los transporta a través de los rebuilds del\n    árbol de widgets, para que no se pierdan.</p>\n\n  <p>Si tienes dudas, recuerda esta regla: si un widget cambia fuera de\n    el método <code>build</code> (debido a las interacciones de los usuarios en tiempo de ejecución, por ejemplo), es stateful. Si el widget nunca cambia, una vez construido, es stateless.\n    Sin embargo, y los transporta a través de los rebuilds del árbol de widgets,\n    para que no se pierdan puede ser stateless si no está reaccionando a\n    esos cambios (u otras entradas).</p>\n\n  <p>El siguiente ejemplo muestra cómo usar un <code>StatelessWidget</code>. Un\n    <code>StatelessWidget</code> común es el widget <code>Text</code>. Si nos fijamos en la implementación de\n    el widget <code>Text</code> encontrarás que es una subclase de <code>StatelessWidget</code>.</p>\n\n  <div>  <div><pre>Text(\n  'Me gusta Flutter!',\n  style: TextStyle(fontWeight: FontWeight.bold),\n);</pre></div></div>\n\n  <p>Si miras el código de arriba, puedes notar que el widget <code>Text</code>\n    no lleva ningún estado explícito. Hace lo que se pasa en su\n    constructores y nada más.</p>\n\n  <p>Pero, ¿qué pasa si quieres hacer que “Me gusta Flutter!“ cambie dinámicamente, por ejemplo\n    al hacer clic en un <code>FloatingActionButton</code> ?</p>\n\n  <p>Para lograr esto, coloca el <code>Text</code> widget en un <code>StatefulWidget</code> y actualizarlo cuando el\n    usuario haga clic en el botón.</p>\n\n  <p>Por ejemplo:</p>\n\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Aplicación de ejemplo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  // Texto por defecto\n  String textToShow = \"Me Gusta Flutter\";\n  void _updateText() {\n    setState(() {\n      // actualiza el texto\n      textToShow = \"Flutter es Impresionante!\";\n    });\n  }\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Aplicación de ejemplo\"),\n      ),\n      body: Center(child: Text(textToShow)),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _updateText,\n        tooltip: 'Actualizar texto',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo diseño mis widgets? ¿Dónde está mi Storyboard?</h2>\n\n  <p>En iOS, puede utilizar un archivo de Storyboard para organizar sus viewcontrollers y establecer\n    restricciones, o puede establecer sus restricciones programáticamente en su vista\n    controladores. En Flutter, declara tu layout en código componiendo\n    un árbol de widgets.</p>\n\n  <p>El siguiente ejemplo enseña como mostrar un widget simple con padding:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Aplicación de ejemplo\"),\n    ),\n    body: Center(\n      child: CupertinoButton(\n        onPressed: () {\n          setState(() { _pressedCount += 1; });\n        },\n        child: Text('Hola'),\n        padding: EdgeInsets.only(left: 10.0, right: 10.0),\n      ),\n    ),\n  );\n}</pre></div></div>\n\n  <p>Puedes añadir padding a cualquier widget, lo que imita la restricciones\n    en iOS.</p>\n\n  <p>Puedes ver los layouts que Flutter te ofrece en la sección catálogo de\n    widgets.</p>\n\n  <h2>\n    ¿Cómo agrego o elimino un componente de mi layout?</h2>\n\n  <p>En iOS, se llama <code>addSubview()</code> como los widgets son inmutables, no hay <code>removeFromSuperview()</code>\n    en una vista secundaria para añadir o eliminar dinámicamente vistas secundarias. En Flutter, porque\n    son inmutables no hay equivalente directo a <code>addSubview()</code>.\n    En su lugar, puede pasar una función al padre que devuelva un widget, y\n    controlar la creación de ese hijo con una etiqueta booleana.</p>\n\n  <p>El siguiente ejemplo muestra cómo alternar entre dos widgets cuando el usuario hace clic en\n    el <code>FloatingActionButton</code>:</p>\n\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Aplicación de ejemplo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  // Valor por defecto para toggle\n  bool toggle = true;\n  void _toggle() {\n    setState(() {\n      toggle = !toggle;\n    });\n  }\n\n  _getToggleChild() {\n    if (toggle) {\n      return Text('Toggle One');\n    } else {\n      return CupertinoButton(\n        onPressed: () {},\n        child: Text('Toggle Two'),\n      );\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Aplicación de ejemplo\"),\n      ),\n      body: Center(\n        child: _getToggleChild(),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _toggle,\n        tooltip: 'Texto actualizado',\n        child: Icon(Icons.update),\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <h2>¿Cómo puedo animar un Widget?</h2>\n\n  <p>En iOS, creas una animación llamando al método\n    <code>animate(withDuration:animations:)</code> en una vista. En Flutter,\n    usa la biblioteca de animación para incluir widgets dentro de un widget animado.</p>\n\n  <p>En Flutter, usa un <code>AnimationController</code> y <code>Animation&lt;double&gt;</code>\n    que puede pausar, buscar, detener e invertir la animación. Requiere un <code>Ticker</code>\n    que señala cuando ocurre la sincronización y produce una interpolación lineal entre\n    0 y 1 en cada fotograma mientras está en marcha. A continuación, crea una o más\n    <code>Animations</code> y adjúntalas al controlador.</p>\n\n  <p>Por ejemplo, puede usar <code>CurvedAnimation</code> para implementar una animación\n    a lo largo de una curva interpolada. En este sentido, el controlador\n    es la fuente “maestra” del progreso de la animación y la  <code>CurvedAnimation</code>\n    calcula la curva que reemplaza el movimiento lineal predeterminado del controlador.\n    Al igual que los widgets, las animaciones en Flutter trabajan con la composición.</p>\n\n  <p>Cuando construyas el árbol de widgets, asigna la <code>Animation</code> a una propiedad animada\n    de un widget, como la opacidad de una <code>FadeTransition</code>, y\n    dile al controlador que inicie la animación</p>\n\n  <p>El siguiente ejemplo muestra cómo escribir un <code>FadeTransition</code> que desvanece el widget\n    en un logotipo al pulsar el botón <code>FloatingActionButton</code>:</p>\n\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Fade Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyFadeTest(title: 'Fade Demo'),\n    );\n  }\n}\n\nclass MyFadeTest extends StatefulWidget {\n  MyFadeTest({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyFadeTest createState() =&gt; _MyFadeTest();\n}\n\nclass _MyFadeTest extends State&lt;MyFadeTest&gt; with TickerProviderStateMixin {\n  AnimationController controller;\n  CurvedAnimation curve;\n\n  @override\n  void initState() {\n    controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n    curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Container(\n          child: FadeTransition(\n            opacity: curve,\n            child: FlutterLogo(\n              size: 100.0,\n            )\n          )\n        )\n      ),\n      floatingActionButton: FloatingActionButton(\n        tooltip: 'Fade',\n        child: Icon(Icons.brush),\n        onPressed: () {\n          controller.forward();\n        },\n      ),\n    );\n  }\n\n  @override\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}</pre></div></div>\n\n  <p>Para más información, mira\n    Widgets de animación y movimiento,\n    el Tutorial de animaciones,\n    y el Visión general.</p>\n\n  <h2>\n    ¿Cómo puedo dibujar en la pantalla?</h2>\n\n  <p>En iOS, utilizas  <code>CoreGraphics</code> para dibujar líneas y formas en la\n    pantalla. Flutter tiene una API diferente basada en la clase  <code>Canvas</code> con dos\n    otras clases que te ayudan a dibujar: <code>CustomPaint</code> y <code>CustomPainter</code>,\n    el último de estos implementa su algoritmo para dibujar al canvas.</p>\n\n  <p>Para aprender cómo implementar un pintor de firmas en Flutter, vea la respuesta de Collin\n    en StackOverflow.</p>\n\n  <div>  <div><pre>class SignaturePainter extends CustomPainter {\n  SignaturePainter(this.points);\n\n  final List&lt;Offset&gt; points;\n\n  void paint(Canvas canvas, Size size) {\n    var paint = Paint()\n      ..color = Colors.black\n      ..strokeCap = StrokeCap.round\n      ..strokeWidth = 5.0;\n    for (int i = 0; i &lt; points.length - 1; i++) {\n      if (points[i] != null &amp;&amp; points[i + 1] != null)\n        canvas.drawLine(points[i], points[i + 1], paint);\n    }\n  }\n\n  bool shouldRepaint(SignaturePainter other) =&gt; other.points != points;\n}\n\nclass Signature extends StatefulWidget {\n  SignatureState createState() =&gt; SignatureState();\n}\n\nclass SignatureState extends State&lt;Signature&gt; {\n\n  List&lt;Offset&gt; _points = &lt;Offset&gt;[];\n\n  Widget build(BuildContext context) {\n    return GestureDetector(\n      onPanUpdate: (DragUpdateDetails details) {\n        setState(() {\n          RenderBox referenceBox = context.findRenderObject();\n          Offset localPosition =\n          referenceBox.globalToLocal(details.globalPosition);\n          _points = List.from(_points)..add(localPosition);\n        });\n      },\n      onPanEnd: (DragEndDetails details) =&gt; _points.add(null),\n      child: CustomPaint(painter: SignaturePainter(_points), size: Size.infinite),\n    );\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Dónde está la opacidad del widget?</h2>\n\n  <p>En iOS, todo tiene .opacidad o .alpha. En Flutter, la mayor parte del tiempo necesitas\n    envolver un widget en un widget de Opacidad para lograr esto.</p>\n\n  <h2>\n    ¿Cómo construyo widgets personalizados?</h2>\n\n  <p>En iOS, normalmente se crea una subclase de <code>UIView</code>, o se utiliza una vista preexistente, para\n    sobrescribir e implementar métodos que logren el comportamiento deseado. En\n    En Flutter, construye un widget personalizado mediante\n    composición widgets más pequeños\n    (en lugar de extenderlos).</p>\n\n  <p>Por ejemplo, ¿cómo se construye un <code>CustomButton</code> que tome una etiqueta en\n    el constructor? Cree un botón personalizado que componga un <code>RaisedButton</code> con una etiqueta,\n    en lugar de extender <code>RaisedButton</code>:</p>\n\n  <div>  <div><pre>class CustomButton extends StatelessWidget {\n  final String label;\n\n  CustomButton(this.label);\n\n  @override\n  Widget build(BuildContext context) {\n    return RaisedButton(onPressed: () {}, child: Text(label));\n  }\n}</pre></div></div>\n\n  <p>Entonces utiliza <code>CustomButton</code>, tal y como lo harías con cualquier otro widget de Flutter:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Center(\n    child: CustomButton(\"Hello\"),\n  );\n}</pre></div></div>\n\n  <h1>Navegación</h1>\n\n  <h2>\n    ¿Cómo desplazarse entre páginas?</h2>\n\n  <p>En iOS, para desplazarse entre la pila de viewcontrollers, puedes utilizar el botón\n    <code>UINavigationController</code> que gestiona la pila de controladores de vista para\n    mostrar en la pantalla.</p>\n\n  <p>Flutter tiene una implementación similar, usando <code>Navigator</code> y\n    “Routes”. Un <code>Route</code> es una abstracción para una “pantalla” o “página” de una aplicación, y\n    un <code>Navegador</code> es un widget\n    que gestiona las rutas. Una se asimila aproximadamente a un\n    <code>UIViewController</code>. El navigator funciona de forma similar al iOS\n    <code>UINavigationController</code>, puedes hacer push <code>push()</code> y <code>pop()</code> dependiendo de que quieras\n    navegar hacia, o volver desde, una vista.</p>\n\n  <p>Para navegar entre páginas, tiene un par de opciones:</p>\n\n  <ul>\n    <li>Especifique un <code>Map</code> de nombres de ruta. (MaterialApp)</li>\n    <li>Navegar directamente a una ruta. (WidgetApp)</li>\n  </ul>\n\n  <p>El siguiente ejemplo construye un Map.</p>\n\n  <div>  <div><pre>void main() {\n  runApp(MaterialApp(\n    home: MyAppHome(), // se convierte en la ruta nombrada '/'\n    routes: &lt;String, WidgetBuilder&gt; {\n      '/a': (BuildContext context) =&gt; MyPage(title: 'page A'),\n      '/b': (BuildContext context) =&gt; MyPage(title: 'page B'),\n      '/c': (BuildContext context) =&gt; MyPage(title: 'page C'),\n    },\n  ));\n}</pre></div></div>\n\n  <p>Navega hasta una route haciendo <code>push</code> por su nombre en el <code>Navigator</code>.</p>\n\n  <div>  <div><pre>Navigator.of(context).pushNamed('/b');</pre></div></div>\n\n  <p>La clase <code>Navigator</code> maneja enrutamiento en Flutter y se utiliza para obtener una respuesta de\n    vuelta desde una ruta que has añadido a la pila. Esto se hace usando\n    <code>await</code> en el <code>Future</code> devuelto por <code>push()</code>.</p>\n\n  <p>Por ejemplo, para iniciar una ruta ‘location’ que permita al usuario seleccionar su\n    localización, podrías hacer lo siguiente:</p>\n\n  <div>  <div><pre>Map coordinates = await Navigator.of(context).pushNamed('/location');</pre></div></div>\n\n  <p>Y luego, dentro de tu ruta de ‘location’, una vez que el usuario haya seleccionado su\n    localización, haces <code>pop()</code> en pila con la respuesta:</p>\n\n  <div>  <div><pre>Navigator.of(context).pop({\"lat\":43.821757,\"long\":-79.226392});</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo navegar a otra aplicación?</h2>\n\n  <p>En iOS, para enviar al usuario a otra aplicación, utilizas un esquema de URL específico.\n    Para las aplicaciones a nivel de sistema, el esquema\n    depende de la aplicación. Para implementar esta funcionalidad en Flutter,\n    crear una integración de plataforma nativa, o usa un\n    plugin existente, como\n    <code>url_launcher</code>.</p>\n\n  <h2>\n    ¿Cómo puedo volver al al viewcontroller nativo de iOS?</h2>\n\n  <p>LLamando a <code>SystemNavigator.pop()</code> desde su código Dart invoca la opción\n    siguiendo el código iOS:</p>\n\n  <div><div><div>  <div><pre><code>UIViewController* viewController = [UIApplication sharedApplication].keyWindow.rootViewController;\n  if ([viewController isKindOfClass:[UINavigationController class]]) {\n    [((UINavigationController*)viewController) popViewControllerAnimated:NO];\n  }\n</code></pre></div></div></div></div>\n\n  <p>Si eso no hace lo que quieres, puedes crear tu propio<br>\n    plarform channel para invocar código iOS arbitrario.</p>\n\n  <h1>¿Hilos o Asincronicidad?</h1>\n\n  <h2>\n    ¿Cómo se puede escribir código asíncrono?</h2>\n\n  <p>Dart tiene un modelo de ejecución de un solo hilo, con soporte para <code>Isolate</code>s (una forma de\n    para ejecutar código Dart en otro hilo), un event loop y programación asíncrona.\n    A menos que generes un <code>Isolate</code>, su código Dart se ejecuta en el hilo principal de la interfaz\n    de usuario y es conducido por un un event loop. El un event loop del flutter es equivalente al iOS\n    main loop, es decir, the <code>Looper</code> que está conectado al hilo principal.</p>\n\n  <p>El modelo de un solo hilo de Dart no significa que requieras ejecutar todo como una operación\n    bloqueante que cause que la UI se congele. En vez de eso,\n    usa las facilidades asincrónicas que proporciona el lenguaje Dart, tales como\n    <code>async</code>/<code>await</code>, para realizar trabajos asincrónicos.</p>\n\n  <p>Por ejemplo, puedes ejecutar código de red sin que la interfaz de usuario se bloquee utilizando\n    <code>async</code>/<code>await</code> y dejar que Dart haga el trabajo pesado:</p>\n\n  <div>  <div><pre>loadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}</pre></div></div>\n\n  <p>Una vez que la llamada de red que estamos esperando con <code>await</code>, se completa, actualiza el UI\n    llamando a <code>setState()</code>, que desencadena un rebuild del widget y actualiza los datos.</p>\n\n  <p>El siguiente ejemplo carga datos de forma asincrónica y los visualiza en un <code>ListView</code>:</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n\n    loadData();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n          itemCount: widgets.length,\n          itemBuilder: (BuildContext context, int position) {\n            return getRow(position);\n          }));\n  }\n\n  Widget getRow(int i) {\n    return Padding(\n      padding: EdgeInsets.all(10.0),\n      child: Text(\"Row ${widgets[i][\"title\"]}\")\n    );\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}</pre></div></div>\n\n  <p>Consulte la siguiente sección para obtener más información sobre cómo realizar el trabajo en en\n    segundo plano y como Flutter difiere de iOS.</p>\n\n  <h2>\n    ¿Cómo se mueve el trabajo a un hilo en segundo plano?</h2>\n\n  <p>Ya que Flutter tiene un solo hilo y ejecuta un event loop (como Node.js), no tienes que preocuparte\n    del manejo de hilos o por generar hilos en segundo plano. Si estás realizando un trabajo de E/S,\n    como acceso al disco o una llamada de red, entonces puedes usar con seguridad <code>async</code>/<code>await</code> y\n    estás listo. Si, por otro lado\n    necesita hacer un trabajo intensivo de computación que mantenga ocupada a la CPU,\n    quieres moverlo a un <code>Isolate</code> para evitar bloquear el event loop.</p>\n\n  <p>Para el trabajo de E/S, declare la función como <code>async</code>,\n    y usa <code>await</code> en tareas de larga duración dentro de la función:</p>\n\n  <div>  <div><pre>loadData() async {\n  String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n  http.Response response = await http.get(dataURL);\n  setState(() {\n    widgets = json.decode(response.body);\n  });\n}</pre></div></div>\n\n  <p>Así es como normalmente se realizan las llamadas a la red o a la base de datos, que son ambas\n    Operaciones de E/S.</p>\n\n  <p>Sin embargo, hay ocasiones en las que puede estar procesando una gran cantidad de datos y\n    tu UI se cuelga. En Flutter, utiliza <code>Isolates</code> Isolates para aprovechar CPUs de múltiples núcleos\n    para realizar tareas de larga duración o que requieren un gran trabajo de computación.</p>\n\n  <p>Los Isolates son hilos de ejecución separados que no comparten ninguna memoria\n    con el main execution memory heap. Esto significa que no se puede acceder a las varables del hilo\n    principal, o actualizar tu UI llamando a <code>setState()</code>. Los Isolates son fieles a\n    su nombre y no pueden compartir memoria (en forma de campos estáticos, por ejemplo).</p>\n\n  <p>El siguiente ejemplo muestra, en un Isolate simple, cómo compartir datos de nuevo a\n    el hilo principal para actualizar la interfaz de usuario.</p>\n\n  <div>  <div><pre>loadData() async {\n  ReceivePort receivePort = ReceivePort();\n  await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n  // El 'echo' isolate envía su SendPort como primer mensaje\n  SendPort sendPort = await receivePort.first;\n\n  List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n  setState(() {\n    widgets = msg;\n  });\n}\n\n// El punto de entrada para el aislamiento\nstatic dataLoader(SendPort sendPort) async {\n  // Para los mensajes entrantes, abra el ReceivePort.\n  ReceivePort port = ReceivePort();\n\n  // Notifique a cualquier otro aislamiento a qué puerto escucha este aislamiento.\n  sendPort.send(port.sendPort);\n\n  await for (var msg in port) {\n    String data = msg[0];\n    SendPort replyTo = msg[1];\n\n    String dataURL = data;\n    http.Response response = await http.get(dataURL);\n    // Muchisimos JSON para analizar\n    replyTo.send(json.decode(response.body));\n  }\n}\n\nFuture sendReceive(SendPort port, msg) {\n  ReceivePort response = ReceivePort();\n  port.send([msg, response.sendPort]);\n  return response.first;\n}</pre></div></div>\n\n  <p>Aquí, <code>dataLoader()</code> es el <code>Isolate</code> que corre en su propio hilo de ejecución separado.\n    En el aislamiento se puede realizar procesamientos más intensivos de CPU (analizando un archivo\n    grande formato JSON, por ejemplo), o realizar cálculos matemáticos intensivos en computación, como encriptación o procesamiento de señales.</p>\n\n  <p>Puede ejecutar el ejemplo completo a continuación:</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\nimport 'dart:async';\nimport 'dart:isolate';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    if (widgets.length == 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() =&gt; ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    ReceivePort receivePort = ReceivePort();\n    await Isolate.spawn(dataLoader, receivePort.sendPort);\n\n    // El 'echo' isolate envía su SendPort como primer mensaje\n    SendPort sendPort = await receivePort.first;\n\n    List msg = await sendReceive(sendPort, \"https://jsonplaceholder.typicode.com/posts\");\n\n    setState(() {\n      widgets = msg;\n    });\n  }\n\n// El punto de entrada para el isolate\n  static dataLoader(SendPort sendPort) async {\n    // Para los mensajes entrantes, abra el ReceivePort.\n    ReceivePort port = ReceivePort();\n\n    // Notifique a cualquier otro isolate a qué puerto escucha este isolate.\n    sendPort.send(port.sendPort);\n\n    await for (var msg in port) {\n      String data = msg[0];\n      SendPort replyTo = msg[1];\n\n      String dataURL = data;\n      http.Response response = await http.get(dataURL);\n      // Lotes de JSON para analizar\n      replyTo.send(json.decode(response.body));\n    }\n  }\n\n  Future sendReceive(SendPort port, msg) {\n    ReceivePort response = ReceivePort();\n    port.send([msg, response.sendPort]);\n    return response.first;\n  }\n}</pre></div></div>\n\n  <h2>\n    Cómo puedo hacer peticiones de red?</h2>\n\n  <p>Realizar una petición de red en Flutter es fácil cuando se utiliza el popular\n    <code>paquete</code> http. Este abstrae una gran parte del trabajo\n    de red que normalmente podría implementar tu mismo,\n    lo que simplifica la realización de peticiones de red.</p>\n\n  <p>Para utilizar el paquete <code>http</code>, añádelo a tus depedendencias en <code>pubspec.yaml</code>:</p>\n\n  <div>  <div><pre>dependencies:\n  ...\n  http: ^0.11.3+16</pre></div></div>\n\n  <p>Para realizar una llamada de red, llame <code>await</code> en la función <code>async</code>  <code>http.get()</code>:</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n[...]\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo mostrar el progreso de una tarea de larga duración?</h2>\n\n  <p>En iOS, normalmente utilizas un <code>UIProgressView</code> durante la ejecución de\n    una larga tarea en segundo plano.</p>\n\n  <p>En Flutter, usa un <code>ProgressIndicator</code> widget.\n    Muestra el progreso programáticamente controlando cuándo se renderiza\n    a través de una señal booleana. Dile a Flutter que actualice este estado antes de comenzar\n    la tarea de larga duración, y ocúltalo después de que acabe.</p>\n\n  <p>En el siguiente ejemplo, la función de build se divide en tres funciones\n    diferentes. Si <code>showLoadingDialog()</code> es <code>true</code> (cuándo <code>widgets.length == 0</code>),\n    entonces renderizamos el <code>ProgressIndicator</code>. De lo contrario, renderizar el\n    <code>ListView</code> con los datos devueltos de una llamada de red.</p>\n\n  <div>  <div><pre>import 'dart:convert';\n\nimport 'package:flutter/material.dart';\nimport 'package:http/http.dart' as http;\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    loadData();\n  }\n\n  showLoadingDialog() {\n    return widgets.length == 0;\n  }\n\n  getBody() {\n    if (showLoadingDialog()) {\n      return getProgressDialog();\n    } else {\n      return getListView();\n    }\n  }\n\n  getProgressDialog() {\n    return Center(child: CircularProgressIndicator());\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text(\"Sample App\"),\n        ),\n        body: getBody());\n  }\n\n  ListView getListView() =&gt; ListView.builder(\n      itemCount: widgets.length,\n      itemBuilder: (BuildContext context, int position) {\n        return getRow(position);\n      });\n\n  Widget getRow(int i) {\n    return Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row ${widgets[i][\"title\"]}\"));\n  }\n\n  loadData() async {\n    String dataURL = \"https://jsonplaceholder.typicode.com/posts\";\n    http.Response response = await http.get(dataURL);\n    setState(() {\n      widgets = json.decode(response.body);\n    });\n  }\n}</pre></div></div>\n\n  <h1>Estructura del proyecto, localización, dependencias y assets del proyecto</h1>\n\n  <h2>\n    ¿Cómo puedo incluir assets de imagen para Flutter? ¿Qué pasa con las resoluciones múltiples?</h2>\n\n  <p>Mientras que iOS trata las imágenes y los assets como elementos distintos,\n    las aplicaciones Flutter sólo tienen assets. Los recursos que se colocan\n    en el <code>Images.xcasset</code> en la carpeta iOS, se colocan en una carpeta de assets para Flutter.\n    Al igual que con iOS, los assets son cualquier tipo de archivo, no sólo imágenes.\n    Por ejemplo, puede tener un archivo JSON ubicado en el directorio <code>my-assets</code>:</p>\n\n  <div><div><div>  <div><pre><code>my-assets/data.json\n</code></pre></div></div></div></div>\n\n  <p>Declare el asset en el archivo <code>pubspec.yaml</code>:</p>\n\n  <div>  <div><pre>assets:\n - my-assets/data.json</pre></div></div>\n\n  <p>Y luego acceder a él desde el código usando un\n    <code>AssetBundle</code>:</p>\n\n  <!-- skip -->\n  <div>  <div><pre>import 'dart:async' show Future;\nimport 'package:flutter/services.dart' show rootBundle;\n\nFuture&lt;String&gt; loadAsset() async {\n  return await rootBundle.loadString('my-assets/data.json');\n}</pre></div></div>\n\n  <p>Para las imágenes, Flutter sigue un formato simple basado en la densidad como iOS.  Assets de imagen\n    podrían ser <code>1.0x</code>, <code>2.0x</code>, <code>3.0x</code>, o cualquier otro multiplicador. El denominado\n    <code>devicePixelRatio</code>\n    expresa la proporción de píxeles físicos en un solo píxel lógico.</p>\n\n  <p>Los assets se encuentran en cualquier carpeta arbitraria; Flutter no tiene\n    estructura de carpetas predefinida. Declara los assets (con localización) en el archivo,\n    <code>pubspec.yaml</code> y Flutter los detecta.</p>\n\n  <p>Por ejemplo, para añadir una imagen llamada <code>my_icon.png</code> a tu proyecto Flutter,\n    podrías decidir almacenarlo en una carpeta que se llama de forma arbitraria <code>images</code>.\n    Coloque la imagen base (1.0x) en la carpeta, <code>images</code> y las otras variantes en\n    subcarpetas nombradas según el multiplicador de proporción apropiado:</p>\n\n  <div><div><div>  <div><pre><code>images/my_icon.png       // Base: 1.0x image\nimages/2.0x/my_icon.png  // 2.0x image\nimages/3.0x/my_icon.png  // 3.0x image\n</code></pre></div></div></div></div>\n\n  <p>A continuación, declare estas imágenes en el archivo <code>pubspec.yaml</code> :</p>\n\n  <div>  <div><pre>assets:\n - images/my_icon.png</pre></div></div>\n\n  <p>Ya puede acceder a tus imágenes usando <code>AssetImage</code>:</p>\n\n  <div>  <div><pre>return AssetImage(\"images/a_dot_burr.jpeg\");</pre></div></div>\n\n  <p>o directamente en un <code>Image</code> widget:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Image.asset(\"images/my_image.png\");\n}</pre></div></div>\n\n  <p>Para más detalles, mira\n    Añadiendo Assets e Imágenes en Flutter.</p>\n\n  <h2>\n    ¿Dónde guardo las cadenas? ¿Cómo gestiono la localización?</h2>\n\n  <p>A diferencia de iOS, que tiene el archivo <code>Localizable.strings</code>, Flutter no tiene actualmente un\n    sistema dedicado para manejar cadenas. Por el momento, la mejor práctica es declarar una copia de\n    su texto en una clase como campos estáticos y\n    acceder a ellos desde allí. Por ejemplo:</p>\n\n  <div>  <div><pre>class Strings {\n  static String welcomeMessage = \"Welcome To Flutter\";\n}</pre></div></div>\n\n  <p>Puedes acceder a tus cadenas como tal:</p>\n\n  <div>  <div><pre>Text(Strings.welcomeMessage)</pre></div></div>\n\n  <p>Por defecto, Flutter sólo es compatible con el inglés de EE.UU. para sus cadenas.\n    Si necesita añadir soporte para otros idiomas, incluya el paquete <code>flutter_localizations</code>.\n    Puede que también necesites añadir el paquete Dart <code>intl</code>\n    para usar el mecanismo i10n, búsqueda como formateo de fecha y hora.</p>\n\n  <div>  <div><pre>dependencies:\n  # ...\n  flutter_localizations:\n    sdk: flutter\n  intl: \"^0.15.6\"</pre></div></div>\n\n  <p>Para usar el paquete <code>flutter_localizations</code> ,\n    especifica <code>localizationsDelegates</code> y <code>supportedLocales</code> en el widget de la aplicación:</p>\n\n  <div>  <div><pre>import 'package:flutter_localizations/flutter_localizations.dart';\n\nMaterialApp(\n localizationsDelegates: [\n   // Agregue aquí los delegados de localización específicos de la aplicación\n   GlobalMaterialLocalizations.delegate,\n   GlobalWidgetsLocalizations.delegate,\n ],\n supportedLocales: [\n    const Locale('en', 'US'), // English\n    const Locale('he', 'IL'), // Hebrew\n    // ... other locales the app supports\n  ],\n  // ...\n)</pre></div></div>\n\n  <p>Los delegados contienen los valores actuales localizados, mientras que la opción <code>supportedLocales</code>\n    define qué localizaciones soporta la aplicación. El ejemplo anterior utiliza un <code>MaterialApp</code>,\n    por lo que tiene tanto una <code>GlobalWidgetsLocalizations</code> para los valores localizados de los widgets\n    base, y una <code>MaterialWidgetsLocalizations</code> para las localizaciones de los widgets de Material. Si\n    utiliza <code>WidgetsApp</code> para tu aplicación, no necesitas lo último. Nota que estos dos delegados\n    contienen “valores predeterminados”, pero tendrá que proporcionar uno o más delegados para la\n    copia localizable de su propia aplicación,\n    si desea que también se localicen.</p>\n\n  <p>Cuando se inicializa, el <code>WidgetsApp</code> (o <code>MaterialApp</code>) crea un widget\n    <code>Localizations</code>\n    para ti, con los delegados que especifique.\n    La localización actual del dispositivo es siempre accesible desde el widget <code>Localizations</code>\n    del contexto actual (en forma de un objecto <code>Locale</code>), o utilizando el\n    <code>Window.locale</code>.</p>\n\n  <p>Para acceder a recursos localizados, utiliza el método <code>Localizations.of()</code> para acceder\n    a una clase de localización específica proporcionada por un delegado determinado.\n    Utiliza el paquete <code>intl_translation</code>\n    para\n    extraer una copia traducible a archivos\n    arb\n    para traducir, e importarlos de nuevo a la aplicación para usarlos con <code>intl</code>.</p>\n\n  <p>Para más detalles sobre la internacionalización y localización en Flutter, consulte la sección\n    guía de internacionalización,\n    que tiene código de muestra con y sin el paquete <code>intl</code>.</p>\n\n  <p>Fíjate que antes de Flutter 1.0 beta 2, los assets en Flutter no eran accesibles desde el lado\n    nativo, y viceversa, los assets y recursos nativos no estaban disponibles para Flutter, ya que\n    vivían en carpetas separadas.</p>\n\n  <h2>\n    ¿Cuál es el equivalente de Cocoapods? ¿Cómo puedo añadir dependencias?</h2>\n\n  <p>En iOS, añades dependencias añadiendo a tu <code>Podfile</code>. Flutter usa el sistema de compilado de Dart\n    y el administrador de paquetes de Pub para manejar dependencias. Las herramientas delegan la\n    compilación de las envolturas de apps nativas Android e iOS a su sistema de compilado\n    correspondiente.</p>\n\n  <p>Si bien hay un Podfile en la carpeta iOS en su proyecto Flutter,\n    úselo solo si estas añadiendo dependencias nativas que necesitas\n    para la integración por plataforma. En general, usa\n    <code>pubspec.yaml</code> para declarar dependencias externas en Flutter. Un buen lugar para encontrar\n    buenos paquetes para Flutter es\n    Pub.</p>\n\n  <h1>ViewControllers</h1>\n\n  <h2>\n    ¿Cual es el equivalente a un ViewController en Flutter?</h2>\n\n  <p>En iOS, un <code>ViewController</code> representa una porción de la interfaz de usuario,\n    usado mayormente para una pantalla o sección. Estos se componen juntos para construir\n    interfaces de usuario complejas y ayuda a escalar la interfaz de usuario de su aplicación.\n    En Flutter,este trabajo recae en los Widgets. Como se mencionó en la sección Navegación,\n    las pantallas de Flutter están representadas por Widgets ya que “todo es un widget!”\n    Utilice un <code>Navigator</code> para moverse entre diferentes <code>Route</code>s<br>\n    que representan diferentes pantallas o páginas, o tal vez diferentes estados\n    o representaciones de los mismos datos.</p>\n\n  <h2>\n    ¿Cómo escuchar los eventos del ciclo de vida de iOS?</h2>\n\n  <p>En iOS, puedes sobrescribir métodos del <code>ViewController</code> para capturar métodos\n    del ciclo de vida para la propia vista, o registrar lifecycle callbacks <code>AppDelegate</code>.\n    En Flutter no tienes ninguno de los dos conceptos, pero en cambio puedes escuchar\n    los eventos del ciclo de vida conectándote al observador <code>WidgetsBinding</code> y\n    escuchando el evento de cambio <code>didChangeAppLifecycleState()</code>.</p>\n\n  <p>Los eventos observables del ciclo de vida son:</p>\n\n  <ul>\n    <li>\n      <code>inactive</code> — La aplicación se encuentra en un estado inactivo y no está recibiendo\n      la entrada del usuario. Este evento sólo funciona en iOS, ya que no hay ningún\n      evento equivalente en Android.</li>\n    <li>\n      <code>paused</code> — La aplicación no es actualmente visible para\n      el usuario, no responde a las entradas del usuario, pero se ejecuta en segundo plano.</li>\n    <li>\n      <code>resumed</code> — La aplicación es visible y responde a las entradas del usuario.</li>\n    <li>\n      <code>suspending</code> — La aplicación se suspende momentáneamente. La plataforma iOS no\n      tiene un evento equivalente.</li>\n  </ul>\n\n  <p>Para más detalles sobre el significado de estos estados, véase\n    <code>AppLifecycleStatus</code> documentación.</p>\n\n  <h1>Layouts</h1>\n\n  <h2>\n    ¿Cuál es el equivalente de un <code>UITableView</code> o <code>UICollectionView</code> en Flutter?</h2>\n\n  <p>En iOS, puede mostrar una lista en una de las dos opciones siguientes <code>UITableView</code> o un\n    <code>UICollectionView</code>. En Flutter, tiene una implementación similar utilizando un\n    <code>ListView</code>.\n    En iOS, estas vistas tienen métodos delegados para decidir el número de filas,\n    la celda para cada ruta de índice y el tamaño de las celdas.</p>\n\n  <p>Debido al patrón inmutable de widgets de Flutter, pasas una lista de widgets a tu <code>ListView</code>, y\n    Flutter se encarga de asegurarse de que el desplazamiento sea\n    rápido y suave.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Aplicación de ejemplo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List&lt;Widget&gt; widgets = [];\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(Padding(padding: EdgeInsets.all(10.0), child: Text(\"Row $i\")));\n    }\n    return widgets;\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo sé en qué elemento de la lista se ha hecho clic?</h2>\n\n  <p>En iOS, se implementa el método de delegado, <code>tableView:didSelectRowAtIndexPath:</code>.\n    En Flutter, utiliza el manejo táctil proporcionado por los widgets pasados.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: _getListData()),\n    );\n  }\n\n  _getListData() {\n    List&lt;Widget&gt; widgets = [];\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(GestureDetector(\n        child: Padding(\n          padding: EdgeInsets.all(10.0),\n          child: Text(\"Row $i\"),\n        ),\n        onTap: () {\n          print('row tapped');\n        },\n      ));\n    }\n    return widgets;\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo actualizar dinámicamente un <code>ListView</code>?</h2>\n\n  <p>En iOS, se actualizan los datos para la vista de lista y se notifica a la vista de tabla o\n    de colección mediante la utilización del método <code>reloadData</code>.</p>\n\n  <p>En Flutter, si tu actualizas dentro <code>setState()</code>,\n    se puede ver rápidamente que sus datos no cambian visualmente.\n    Esto se debe a que cuando <code>setState()</code> se llama, el motor de renderizado de Flutter\n    mira el árbol de widgets para ver si algo ha cambiado. Cuando llegue a tu\n    <code>ListView</code>, realiza una comprobación <code>==</code>, y determina que los dos <code>ListViews</code>\n    son el mismo. Nada ha cambiado, por lo que no se requiere ninguna actualización.</p>\n\n  <p>Para una forma sencilla de actualizar tu <code>ListView</code>, crea una nueva <code>List</code> dentro de\n    <code>setState()</code>, y copia los datos de la lista antigua a la nueva lista.\n    Aunque este enfoque es simple, no se recomienda para conjuntos de datos grandes,\n    como se muestra en el siguiente ejemplo.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView(children: widgets),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n        padding: EdgeInsets.all(10.0),\n        child: Text(\"Row $i\"),\n      ),\n      onTap: () {\n        setState(() {\n          widgets = List.from(widgets);\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}</pre></div></div>\n\n  <p>La manera recomendada, eficiente y efectiva de construir una lista es usando un\n    <code>ListView.Builder</code>. Este método es excelente cuando se tiene una lista dinámica o\n    una lista con grandes cantidades de datos.</p>\n\n  <div>  <div><pre>import 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(SampleApp());\n}\n\nclass SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  List widgets = [];\n\n  @override\n  void initState() {\n    super.initState();\n    for (int i = 0; i &lt; 100; i++) {\n      widgets.add(getRow(i));\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: ListView.builder(\n        itemCount: widgets.length,\n        itemBuilder: (BuildContext context, int position) {\n          return getRow(position);\n        },\n      ),\n    );\n  }\n\n  Widget getRow(int i) {\n    return GestureDetector(\n      child: Padding(\n        padding: EdgeInsets.all(10.0),\n        child: Text(\"Row $i\"),\n      ),\n      onTap: () {\n        setState(() {\n          widgets.add(getRow(widgets.length + 1));\n          print('row $i');\n        });\n      },\n    );\n  }\n}</pre></div></div>\n\n  <p>En lugar de crear un “ListView”, crea un <code>ListView.builder</code> que toma dos p\n    arámetros clave: la longitud inicial de la lista y\n    una función. <code>ItemBuilder</code>.</p>\n\n  <p>La función <code>ItemBuilder</code> es similar al método delegado <code>cellForItemAt</code>\n    en una vista de tabla o colección de iOS, ya que toma una posición, y devuelve la celda\n    que quieres que se renderice en esa posición.</p>\n\n  <p>Finalmente, pero lo más importante, note que la función <code>onTap()</code>\n    ya no recrea la lista, sino que en vez de eso la agrega <code>.add</code>.</p>\n\n  <h2>\n    ¿Cuál es el equivalente de un <code>ScrollView</code> en Flutter?</h2>\n\n  <p>En iOS, las vistas se envuelven en un <code>ScrollView</code> que permite al usuario desplazarse por el\n    contenido si es necesario.</p>\n\n  <p>En Flutter la forma más fácil de hacerlo es usando el widget <code>ListView</code>. Esto actúa como un\n    <code>ScrollView</code> como un <code>TableView</code> de iOS, y puedes hacer un layout de widgets\n    en formato vertical.</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return ListView(\n    children: &lt;Widget&gt;[\n      Text('Row One'),\n      Text('Row Two'),\n      Text('Row Three'),\n      Text('Row Four'),\n    ],\n  );\n}</pre></div></div>\n\n  <p>Para documentos más detallados sobre cómo diseñar widgets en Flutter,\n    ver el layout tutorial.</p>\n\n  <h1>Detección de gestos y manejo de eventos táctiles</h1>\n\n  <h2>\n    ¿Cómo puedo añadir un click listener a un widget en Flutter?</h2>\n\n  <p>En iOS, se adjunta un <code>GestureRecognizer</code> a una vista para gestionar eventos de clic.\n    En Flutter, hay dos maneras de añadir touch listeners.:</p>\n\n  <ol>\n    <li>\n      <p>Si el widget soporta la detección de eventos, pásale una función y\n        gestiona el evento en la función. Por ejemplo, el widget `\n        RaisedButton<code> tiene un parámetro </code>onPressed`:</p>\n\n      <!-- skip -->\n      <div>\n        <div><div>  <div><pre><code>@override\nWidget build(BuildContext context) {\n  return RaisedButton(\n    onPressed: () {\n      print(\"click\");\n    },\n    child: Text(\"Button\"),\n  );\n}\n</code></pre></div></div></div>    </div>\n    </li>\n    <li>\n      <p>Si el Widget no soporta la detección de eventos, envuélvelo en un\n        GestureDetector y pase una función al parámetro <code>onTap</code>.</p>\n\n      <!-- skip -->\n      <div>\n        <div><div>  <div><pre><code>class SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: GestureDetector(\n          child: FlutterLogo(\n            size: 200.0,\n          ),\n          onTap: () {\n            print(\"tap\");\n          },\n        ),\n      ),\n    );\n  }\n}\n</code></pre></div></div></div>    </div>\n    </li>\n  </ol>\n\n  <h2>\n    ¿Cómo puedo gestionar otros gestos en los widgets?</h2>\n\n  <p>Utilizando <code>GestureDetector</code> puedes escuchar una amplia gama de gestos como:</p>\n\n  <ul>\n    <li>\n      <p>Tapping</p>\n\n      <ul>\n        <li>\n          <code>onTapDown</code> — Un puntero que podría provocar un toque ha entrado en contacto con la\n          pantalla en una ubicación determinada.</li>\n        <li>\n          <code>onTapUp</code> — Un puntero que activa un toque ha dejado de entrar en contacto con\n          la pantalla en una ubicación determinada.</li>\n        <li>\n          <code>onTap</code> — Se ha producido un toque.</li>\n        <li>\n          <code>onTapCancel</code> — El puntero que desencadenó previamente el <code>onTapDown</code>\n          no causará un toque.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Double tapping</p>\n\n      <ul>\n        <li>\n          <code>onDoubleTap</code> — El usuario tocó la pantalla en la misma ubicación dos\n          veces en una sucesión rápida.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Long pressing</p>\n\n      <ul>\n        <li>\n          <code>onLongPress</code> — Un puntero ha permanecido en contacto con la pantalla en el\n          mismo lugar durante un largo período de tiempo.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Vertical dragging</p>\n\n      <ul>\n        <li>\n          <code>onVerticalDragStart</code> — Un puntero ha entrado en contacto con la pantalla y\n          puede comenzar a moverse verticalmente.</li>\n        <li>\n          <code>onVerticalDragUpdate</code> — Un puntero en contacto con la pantalla se ha movido más\n          en la dirección vertical.</li>\n        <li>\n          <code>onVerticalDragEnd</code> — Un puntero que anteriormente estaba en contacto con la\n          pantalla y se movía verticalmente ya no está en contacto con la pantalla y\n          se movía a una velocidad específica cuando dejó de entrar en contacto con la pantalla.</li>\n      </ul>\n    </li>\n    <li>\n      <p>Horizontal dragging</p>\n\n      <ul>\n        <li>\n          <code>onHorizontalDragStart</code> — Un puntero ha entrado en contacto con la pantalla y\n          puede comenzar a moverse horizontalmente.</li>\n        <li>\n          <code>onHorizontalDragUpdate</code> — Un puntero en contacto con la pantalla se ha\n          movido más en la dirección horizontal.</li>\n        <li>\n          <code>onHorizontalDragEnd</code> — Un puntero que antes estaba en contacto con la\n          pantalla y que se movía horizontalmente ya no está en contacto con la pantalla.</li>\n      </ul>\n    </li>\n  </ul>\n\n  <p>El siguiente ejemplo muestra un <code>GestureDetector</code> que rota el logotipo de Flutter\n    con un doble toque:</p>\n\n  <div>  <div><pre>AnimationController controller;\nCurvedAnimation curve;\n\n@override\nvoid initState() {\n  controller = AnimationController(duration: const Duration(milliseconds: 2000), vsync: this);\n  curve = CurvedAnimation(parent: controller, curve: Curves.easeIn);\n}\n\nclass SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: GestureDetector(\n          child: RotationTransition(\n            turns: curve,\n            child: FlutterLogo(\n              size: 200.0,\n            )),\n          onDoubleTap: () {\n            if (controller.isCompleted) {\n              controller.reverse();\n            } else {\n              controller.forward();\n            }\n          },\n        ),\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <h1>Creación de themes y texto</h1>\n\n  <h2>\n    ¿Cómo se crea un theme para una aplicación?</h2>\n\n  <p>De inicio, Flutter viene con una atractiva implementación de Material Design,\n    que se encarga de un montón de necesidades de estilos y creación de themes que normalmente harías.</p>\n\n  <p>Para aprovechar al máximo los Material Components en tu app, declare un widget de primer nivel,\n    MaterialApp, como punto de entrada a su aplicación. MaterialApp es un widget de conveniencia que\n    incluye una serie de widgets que son comúnmente requeridos para aplicaciones que implementan\n    Material Design. Se basa en una WidgetsApp añadiendo funcionalidad\n    específica de Material.</p>\n\n  <p>Pero Flutter es lo suficientemente flexible y expresivo como para implementar cualquier lenguaje de diseño.\n    En iOS, puede utilizar la\n    biblioteca Cupertino\n    para producir una interfaz que se adhiera a las Human Interface\n      Guidelines.\n    Para ver el listado completo de estos widgets, consulte la sección\n    Cupertino (widgets estilo iOS).</p>\n\n  <p>También puede utilizar un <code>WidgetApp</code> como tu widget de aplicación, que proporciona parte de la\n    misma funcionalidad, pero no es tan rica como <code>MaterialApp</code>.</p>\n\n  <p>Para personalizar los colores y estilos de cualquier componente hijo, utilice\n    <code>ThemeData</code> objeto del widget <code>MaterialApp</code>. Por ejemplo, en el código de abajo,\n    la muestra principal está configurada en azul y el color de la selección de texto es rojo.</p>\n\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textSelectionColor: Colors.red\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo configuro fuentes personalizadas en mis widgets Text?</h2>\n\n  <p>En iOS, puede importar cualquier fuente de tipo <code>ttf</code> en tu proyecto y crear una\n    referencia en el archivo <code>info.plist</code>. En Flutter, coloca el archivo de fuente en\n    una carpeta y has referencia a él en el archivo <code>pubspec.yaml</code>, de forma similar a\n    como se importan las imágenes.</p>\n\n  <div>  <div><pre>fonts:\n   - family: MyCustomFont\n     fonts:\n       - asset: fonts/MyCustomFont.ttf\n       - style: italic</pre></div></div>\n\n  <p>A continuación, asigna la fuente a su widget <code>Text</code>:</p>\n\n  <div>  <div><pre>@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    appBar: AppBar(\n      title: Text(\"Sample App\"),\n    ),\n    body: Center(\n      child: Text(\n        'Este es un fuente de texto personalizado',\n        style: TextStyle(fontFamily: 'MyCustomFont'),\n      ),\n    ),\n  );\n}</pre></div></div>\n\n  <h2>\n    ¿Cómo doy estilos a mis widgets Text?</h2>\n\n  <p>Junto con las fuentes, puede personalizar otros elementos de estilo en un widget <code>Text</code>.\n    El parámetro de style de un widget <code>Text</code> toma un objeto <code>TextStyle</code>, donde puede\n    personalizar muchos parámetros, como por ejemplo:</p>\n\n  <ul>\n    <li><code>color</code></li>\n    <li><code>decoration</code></li>\n    <li><code>decorationColor</code></li>\n    <li><code>decorationStyle</code></li>\n    <li><code>fontFamily</code></li>\n    <li><code>fontSize</code></li>\n    <li><code>fontStyle</code></li>\n    <li><code>fontWeight</code></li>\n    <li><code>hashCode</code></li>\n    <li><code>height</code></li>\n    <li><code>inherit</code></li>\n    <li><code>letterSpacing</code></li>\n    <li><code>textBaseline</code></li>\n    <li><code>wordSpacing</code></li>\n  </ul>\n\n  <h1>Entrada de formularios</h1>\n\n  <h2>\n    ¿Cómo funcionan los formularios en Flutter? ¿Cómo puedo recuperar los datos introducidos por el usuario?</h2>\n\n  <p>Dada la forma en que Flutter utiliza widgets inmutables con un estado separado, puede que te\n    preguntes cómo encaja la entrada del usuario en la imagen. En iOS, normalmente consultas los widgets\n    por sus valores actuales cuando llega el momento de enviar la entrada del usuario, o una acción\n    sobre ella. ¿Cómo funciona eso en Flutter?</p>\n\n  <p>En la práctica, los formularios son manejados, como todo en Flutter, por widgets especializados.\n    Si tu tiene un <code>TextField</code> o un <code>TextFormField</code>, puede asignar un\n    <code>TextEditingController</code>\n    para recuperar las entradas del usuario:</p>\n\n  <div>  <div><pre>class _MyFormState extends State&lt;MyForm&gt; {\n  // Crea un controlador de texto y utilícelo para recuperar el valor actual.\n  // del campo de texto!\n  final myController = TextEditingController();\n\n  @override\n  void dispose() {\n    // Limpia el controlador cuando elimine el Widget.\n    myController.dispose();\n    super.dispose();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Recuperar entrada de texto'),\n      ),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: TextField(\n          controller: myController,\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        // Cuando el usuario pulsa el botón, muestra un diálogo de alerta con el\n        // texto que el usuario ha escrito en    nuestro campo de texto.\n        onPressed: () {\n          return showDialog(\n            context: context,\n            builder: (context) {\n              return AlertDialog(\n                // Recupera el texto que el usuario ha tecleado con nuestro\n                // TextEditingController\n                content: Text(myController.text),\n              );\n            },\n          );\n        },\n        tooltip: 'Show me the value!',\n        child: Icon(Icons.text_fields),\n      ),\n    );\n  }\n}</pre></div></div>\n\n  <p>Puede encontrar más información y la lista completa de códigos en\n    Obtener el valor de un campo de texto,\n    desde el Flutter Cookbook.</p>\n\n  <h2>\n    ¿Cuál es el equivalente de un placeholder en un campo de texto?</h2>\n\n  <p>En Flutter puede mostrar fácilmente un “hint” o un texto de referencia para su campo\n    añadiendo un objeto <code>InputDecoration</code> al parámetro decoration del constructor de\n    decoración para el widget <code>Text</code> :</p>\n\n  <div>  <div><pre>body: Center(\n  child: TextField(\n    decoration: InputDecoration(hintText: \"This is a hint\"),\n  ),\n)</pre></div></div>\n\n  <h2>\n    ¿Cómo puedo mostrar los errores de validación?</h2>\n\n  <p>Al igual que lo harías con un “hint”, pasa un objeto <code>InputDecoration</code>\n    al constructor de decoración para el widget <code>Text</code>.</p>\n\n  <p>Sin embargo, no desea comenzar mostrando un error.\n    En su lugar, cuando el usuario haya introducido datos no válidos, actualice el estado\n    y pase un nuevo objeto <code>InputDecoration</code>.</p>\n\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  // Este widget es la raíz de su aplicación.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}\n\nclass SampleAppPage extends StatefulWidget {\n  SampleAppPage({Key key}) : super(key: key);\n\n  @override\n  _SampleAppPageState createState() =&gt; _SampleAppPageState();\n}\n\nclass _SampleAppPageState extends State&lt;SampleAppPage&gt; {\n  String _errorText;\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\"Sample App\"),\n      ),\n      body: Center(\n        child: TextField(\n          onSubmitted: (String text) {\n            setState(() {\n              if (!isEmail(text)) {\n                _errorText = 'Error: Esto no es un correo electrónico';\n              } else {\n                _errorText = null;\n              }\n            });\n          },\n          decoration: InputDecoration(hintText: \"Esto es una pista\", errorText: _getErrorText()),\n        ),\n      ),\n    );\n  }\n\n  _getErrorText() {\n    return _errorText;\n  }\n\n  bool isEmail(String emailString) {\n    String emailRegexp =\n        r'^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$';\n\n    RegExp regExp = RegExp(emailRegexp);\n\n    return regExp.hasMatch(emailString);\n  }\n}</pre></div></div>\n\n  <h1>Interactuar con el hardware, servicios de terceros y con la plataforma</h1>\n\n  <h2>\n    ¿Cómo interactúo con la plataforma y con el código nativo de la plataforma?</h2>\n\n  <p>Flutter no ejecuta código directamente en la plataforma subyacente; más bien, el código Dart que\n    constituye una aplicación Flutter se ejecuta de forma nativa en el dispositivo, “evitando” el SDK\n    proporcionado por la plataforma. Esto significa, por ejemplo, que cuando realizas una solicitud de\n    red en Dart, se ejecuta directamente en el contexto de Dart. No se utilizan las API de Android o iOS\n    que normalmente se aprovechan al escribir aplicaciones nativas. Tu app Flutter sigue alojada en el\n    <code>ViewController</code> de una app nativa, como una vista, pero no tienes acceso directo al\n    <code>ViewControlleren</code> si mismo, ni al framework nativo.</p>\n\n  <p>Esto no significa que las aplicaciones Flutter no puedan interactuar con esas API nativas, o con\n    cualquier código nativo que tengas. Flutter proporciona platfom channels,\n    que comunican e intercambian datos con el <code>ViewController</code> que contiene tu vista Flutter. Los\n    platfom channels son esencialmente un mecanismo de mensajería asíncrono que une el código Dart con\n    el anfitrión <code>ViewController</code> y el framework de trabajo de iOS en el que se ejecuta. Puede utilizar\n    platfom channels para ejecutar un método en el lado nativo o para recuperar algunos datos de los\n    sensores del dispositivo, por ejemplo.</p>\n\n  <p>Además de utilizar directamente los platfom channels, puede utilizar una gran variedad de plugins\n    prefabricaddos plugins que encapsula el código nativo y el código Dart para un\n    objetivo específico. Por ejemplo, puede utilizar un plugin para acceder al carrete de cámara y a la\n    cámara del dispositivo directamente desde Flutter, sin tener que escribir su propia integración. Los\n    plugins se encuentran en el reposiorio de paquetes de código abierto de Dart y Flutter, [Pub]\n    (https://pub.dev/).\n    Algunos paquetes pueden soportar integraciones nativas en iOS,\n    Android o ambos.</p>\n\n  <p>Si no puede encontrar un plugin en Pub que se adapte a sus necesidades, puede\n    escribir el tuyo propio\n    y publicarlo en Pub.</p>\n\n  <h2>\n    ¿Cómo accedo al sensor GPS?</h2>\n\n  <p>Utilice el plugin <code>geolocator</code> de la comunidad.</p>\n\n  <h2>\n    ¿Cómo accedo a la cámara?</h2>\n\n  <p>El plugin <code>image_picker</code> es popular\n    para acceder a la cámara.</p>\n\n  <h2>\n    ¿Cómo me conecto con Facebook?</h2>\n\n  <p>Para iniciar sesión con Facebook, utilice el plugin\n    <code>flutter_facebook_login</code> de la comunidad.</p>\n\n  <h2>\n    ¿Cómo uso las funciones de Firebase?</h2>\n\n  <p>La mayoría de las funciones de Firebase están cubiertas por\n    first party plugins.\n    Estos plugins son integraciones de primera mano, mantenidas por el equipo de Flutter:</p>\n\n  <ul>\n    <li>\n      <code>firebase_admob</code> para Firebase AdMob</li>\n    <li>\n      <code>firebase_analytics</code> para la analítica de Firebase</li>\n    <li>\n      <code>firebase_auth</code> para Firebase autenticación</li>\n    <li>\n      <code>firebase_core</code> para el package principal de Firebase</li>\n    <li>\n      <code>firebase_database</code> para RTDB Firebase</li>\n    <li>\n      <code>firebase_storage</code> para Firebase Cloud Storage</li>\n    <li>\n      <code>firebase_messaging</code> para Mensajería Firebase (FCM)</li>\n    <li>\n      <code>cloud_firestore</code> para Firebase Cloud Firestore</li>\n  </ul>\n\n  <p>También puedes encontrar algunos plugins Firebase de terceros en Pub que cubren áreas que\n    no están directamente cubiertas por los plugins de primer nivel.</p>\n\n  <h2>\n    ¿Cómo puedo crear mis propias integraciones nativas personalizadas?</h2>\n\n  <p>Si hay funcionalidades específicas de la plataforma que Flutter o los plugins de su\n    comunidad no están disponibles, puedes construir los tuyos propios siguiendo la página\n    developing packages and plugins.</p>\n\n  <p>La arquitectura de plugins de Flutter, en pocas palabras, es muy parecida a la de\n    un bus de eventos en Android: tú disparas un mensaje y dejas que el receptor\n    lo procese y te devuelve el resultado. En este caso, el receptor es código\n    que se ejecuta en el lado nativo de Android o iOS.</p>\n\n  <h1>Bases de datos y almacenamiento local</h1>\n\n  <h2>\n    ¿Cómo accedo a <code>UserDefaults</code> en Flutter?</h2>\n\n  <p>En iOS, puede almacenar una colección de pares clave/valor utilizando una lista de propiedades,\n    conocido como <code>UserDefaults</code>.</p>\n\n  <p>En Flutter, accede a la funcionalidad equivalente mediante\n    Shared Preferences plugin.\n    Este plugin envuelve la funcionalidad de ambos <code>UserDefaults</code> y el\n    equivalente en Android, <code>SharedPreferences</code>.</p>\n\n  <h2>\n    ¿Cuál es el equivalente a CoreData en Flutter?</h2>\n\n  <p>En iOS, puede utilizar CoreData para almacenar datos estructurados. Esto es simplemente una capa\n    encima de una base de datos SQL, lo que facilita la realización de consultas relacionadas con sus\n    modelos.</p>\n\n  <p>En Flutter, acceda a esta funcionalidad utilizando el plugin\n    SQFlite.</p>\n\n  <h1>Notificaciones</h1>\n\n  <h2>\n    ¿Cómo configuro las notificaciones push?</h2>\n\n  <p>En iOS, debe registrar la aplicación en el portal del desarrollador para permitir\n    las notificaciones push.</p>\n\n  <p>En Flutter, acceda a esta funcionalidad utilizando el plugin\n    <code>firebase_messaging</code>.</p>\n\n  <p>Para obtener más información sobre el uso de la API de mensajería en nube de Firebase,\n    consulte la documentación del plugin\n    <code>firebase_messaging</code>.</p>\n</div>"
    },
    {
        "title": "5.3 Flutter para React Native devs",
        "subtitle": "Introduccion",
        "content":  "<div>\n  <h1>Flutter para desarrolladores React Native</h1>\n  <div>    \n    Contenidos    \n    <ul>\n      <li>Introducción a Dart para desarrolladores de JavaScript\n        <ul>\n          <li>Punto de entrada</li>\n          <li>Imprimir en la consola</li>\n          <li>Variables\n            <ul>\n              <li>Creando y asignando variables</li>\n              <li>Valor por defecto</li>\n            </ul>\n          </li>\n          <li>Comprobando null o cero</li>\n          <li>Funciones</li>\n          <li>Programación asincrónica\n            <ul>\n              <li>Futures</li>\n              <li>async y await</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Los fundamentos\n        <ul>\n          <li>¿Cómo creo una app Flutter?</li>\n          <li>¿Cómo puedo ejecutar mi aplicación?</li>\n          <li>¿Cómo importo widgets?</li>\n          <li>¿Cuál es el equivalente de la app React Native “Hello world!” en Flutter?</li>\n          <li>¿Cómo uso los widgets y los encajo para formar un árbol de widgets?</li>\n          <li>¿Cómo creo componentes reutilizables?</li>\n        </ul>\n      </li>\n      <li>Estructura y recursos del proyecto\n        <ul>\n          <li>¿Dónde empiezo a escribir el código?</li>\n          <li>¿Cómo se estructuran los archivos en una aplicación Flutter?</li>\n          <li>¿Dónde pongo mis recursos y activos y cómo los uso?</li>\n          <li>¿Cómo puedo cargar imágenes en una red?</li>\n          <li>¿Cómo instalo paquetes y plugins de paquetes?</li>\n        </ul>\n      </li>\n      <li>Flutter widgets</li>\n      <li>Vistas\n        <ul>\n          <li>¿Cuál es el equivalente del contenedor View?</li>\n          <li>¿Cuál es el equivalente de FlatList o SectionList?</li>\n          <li>¿Cómo uso un Canvas para dibujar o pintar?</li>\n        </ul>\n      </li>\n      <li>Layouts\n        <ul>\n          <li>¿Cómo utilizo los widgets para definir las propiedades del layout?</li>\n          <li>¿Cómo puedo crear capas de widgets?</li>\n        </ul>\n      </li>\n      <li>Estilo\n        <ul>\n          <li>¿Cómo le doy estilo a mi componente?</li>\n          <li>¿Cómo uso Iconos y Colores?</li>\n          <li>¿Cómo añado themes de estilo?</li>\n        </ul>\n      </li>\n      <li>Gestión de Estado\n        <ul>\n          <li>El StatelessWidget</li>\n          <li>El StatefulWidget</li>\n          <li>¿Cuáles son las mejores prácticas de StatefulWidget y StatelessWidget?\n            <ul>\n              <li>1. Determinar si un widget debe ser un StatefulWidget o un StatelessWidget</li>\n              <li>2. Determinar qué objeto gestiona el estado del widget (para un StatefulWidget)</li>\n              <li>3. Subclase StatefulWidget y State</li>\n              <li>4. Agregar StatefulWidget al árbol de widgets</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Props</li>\n      <li>Almacenamiento local\n        <ul>\n          <li>¿Cómo puedo almacenar parejas persistentes de clave-valor que son globales para la aplicación?</li>\n        </ul>\n      </li>\n      <li>Enrutamiento\n        <ul>\n          <li>¿Cómo navego entre pantallas?</li>\n          <li>¿Cómo se utiliza la navegación por tab y drawer?\n            <ul>\n              <li>Navegación por Tab</li>\n              <li>Navegación por Drawer</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Detección de gestos y manejo de eventos táctiles\n        <ul>\n          <li>¿Cómo puedo añadir un clic o pulsar listeners a un widget?</li>\n        </ul>\n      </li>\n      <li>Hacer peticiones de red HTTP\n        <ul>\n          <li>¿Cómo obtengo datos de llamadas a la API?</li>\n        </ul>\n      </li>\n      <li>Form input\n        <ul>\n          <li>¿Cómo utilizo los widgets de los campos de texto?</li>\n          <li>¿Cómo utilizo los widgets Form?</li>\n        </ul>\n      </li>\n      <li>Código específico de la plataforma</li>\n      <li>Debugging\n        <ul>\n          <li>¿Cómo accedo al menú de desarrollador en la app?</li>\n          <li>¿Cómo realizo un hot reload?</li>\n          <li>¿Qué herramientas puedo usar para depurar mi aplicación en Flutter?</li>\n        </ul>\n      </li>\n      <li>Animación\n        <ul>\n          <li>¿Cómo puedo añadir una simple animación fade-in?</li>\n          <li>¿Cómo añado animación de deslizamiento a las tarjetas?</li>\n        </ul>\n      </li>\n      <li>Componentes equivalentes de React Native y Flutter Widget</li>\n    </ul>\n  </div>\n  <p>Este documento es para desarrolladores de React Native (RN) que buscan aplicar su conocimiento\n    existente de RN para construir aplicaciones móviles con Flutter. Si entiendes los fundamentos del\n    framework RN entonces puedes utilizar este documento como una manera de empezar a aprender el\n    desarrollo en Flutter.</p>\n\n  <p>Este documento puede usarse como un cookbook recorriéndolo aleatoriamente y encontrando las\n    preguntas que son más relevantes a tus necesidades.</p>\n\n  <h2>\n    Introducción a Dart para desarrolladores de JavaScript</h2>\n\n  <p>Al igual que React Native, Flutter utiliza vistas al estilo reactive. Sin embargo, mientras que RN\n    transpila a los widgets nativos, Flutter compila siempre a código nativo. Flutter controla cada píxel\n    de la pantalla, lo que evita problemas de rendimiento causados por la necesidad de un JavaScript\n    bridge.</p>\n\n  <p>Dart es un lenguaje fácil de aprender y ofrece las siguientes características:</p>\n\n  <ul>\n    <li>Proporciona un lenguaje de programación escalable y open source para crear aplicaciones web,\n      de servidor y de móvil.</li>\n    <li>Proporciona un lenguaje orientado a objetos de herencia simple que usa una sintaxis estilo C\n      que se compila AOT en nativo.</li>\n    <li>Transcompila opcionalmente en JavaScript.</li>\n    <li>Soporta interfaces y clases abstractas.</li>\n  </ul>\n\n  <p>Algunos ejemplos de las diferencias entre JavaScript y Dart se describen a\n    continuación.</p>\n\n  <h3>\n    Punto de entrada</h3>\n\n  <p>JavaScript no tiene una función de entrada predefinida: tú defines el punto de entrada.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nfunction startHere() {\n  // Puede ser utilizado como punto de entrada\n}\n</code></pre></div></div></div></div>\n  <p>En Dart, cada app debe tener una función main() principal que sirva como punto de\n    entrada a la app.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nmain() {\n}\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en DartPad.</p>\n\n  <h3>\n    Imprimir en la consola</h3>\n\n  <p>Para imprimir en la consola en Dart, usa <code>print</code>.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nconsole.log(\"Hello world!\");\n</code></pre></div></div></div></div>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nprint('Hello world!');\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en\n    DartPad.</p>\n\n  <h3>\n    Variables</h3>\n\n  <p>Dart es type safe —utiliza una combinación de static type comprobando y ejecutando\n    checks para garantizar que el valor de una variable siempre coincida con el static\n    type de la variable. Aunque los types son obligatorios, algunas anotaciones type son\n    opcionales porque Dart realiza la inferencia del type.</p>\n\n  <h4>Creando y asignando variables</h4>\n\n  <p>En JavaScript, las variables no se pueden escribir.</p>\n\n  <p>En Dart, las variables deben tener un type explícito o\n    el sistema deberá deducir el type apropiado automáticamente.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nvar name = \"JavaScript\";\n</code></pre></div></div></div></div>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nString name = 'dart'; // Explicitamente definido el type como un string.\nvar otherName = 'Dart'; // String inferido.\n// Ambos son aceptables en Dart.\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en\n    DartPad.</p>\n\n  <p>Para más información, consulta System Type\n    de Dart.</p>\n\n  <h4>Valor por defecto</h4>\n\n  <p>En JavaScript, las variables no inicializadas son “indefinidas”.</p>\n\n  <p>En Dart, las variables no inicializadas tienen un valor inicial <code>null</code>. Debido a que los números son\n    objetos en Dart, incluso las variables no inicializadas con tipos numéricos\n    tienen el valor <code>null</code>.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nvar name; // == undefined\n</code></pre></div></div></div></div>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nvar name; // == null\nint x; // == null\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en the\n    DartPad.</p>\n\n  <p>Para más información, consulta la documentación sobre\n    variables.</p>\n\n  <h3>\n    Comprobando null o cero</h3>\n\n  <p>En JavaScript, los valores de 1 o cualquier objeto no nulo se tratan como true.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nvar myNull = null;\nif (!myNull) {\n  console.log(\"null is treated as false\");\n}\nvar zero = 0;\nif (!zero) {\n  console.log(\"0 is treated as false\");\n}\n</code></pre></div></div></div></div>\n  <p>En Dart, solo el valor booleano <code>true</code> es tratado como verdadero.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nvar myNull = null;\nif (myNull == null) {\n  print('use \"== null\" to check null');\n}\nvar zero = 0;\nif (zero == 0) {\n  print('use \"== 0\" to check zero');\n}\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en\n    DartPad.</p>\n\n  <h3>\n    Funciones</h3>\n\n  <p>Las funciones de Dart y JavaScript son generalmente similares. La diferencia principal es\n    la declaración.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nfunction fn() {\n  return true;\n}\n</code></pre></div></div></div></div>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nfn() {\n  return true;\n}\n// también se puede escribir como\nbool fn() {\n  return true;\n}\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en\n    DartPad.</p>\n\n  <p>Para más información, consulta la documentación sobre\n    funciones.</p>\n\n  <h3>\n    Programación asincrónica</h3>\n\n  <h4>\n    Futures</h4>\n\n  <p>Al igual que JavaScript, Dart admite la ejecución de un solo hilo. En JavaScript,\n    el objeto Promise representa la finalización (o falla) eventual de una operación\n    asincrónica y su valor resultante.</p>\n\n  <p>Mientras que Dart usa objetos <code>Future</code> para manejar esto.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\n_getIPAddress = () =&gt; {\n  const url=\"https://httpbin.org/ip\";\n  return fetch(url)\n    .then(response =&gt; response.json())\n    .then(responseJson =&gt; {\n      console.log(responseJson.origin);\n    })\n    .catch(error =&gt; {\n      console.error(error);\n    });\n};\n</code></pre></div></div></div></div>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\n_getIPAddress() {\n  final url = 'https://httpbin.org/ip';\n  HttpRequest.request(url).then((value) {\n      print(json.decode(value.responseText)['origin']);\n  }).catchError((error) =&gt; print(error));\n}\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en\n    DartPad.</p>\n\n  <p>Para más información, consulta la documentación sobre\n    Futures.</p>\n\n  <h4><code>async</code> y <code>await</code>\n  </h4>\n\n  <p>La declaración de función <code>async</code> define una función asíncrona.</p>\n\n  <p>En JavaScript, la función <code>async</code> devuelve un <code>Promise</code>. El operador <code>await</code> se utiliza\n    para esperar un <code>Promise</code>.</p>\n\n  <div><div><div>  <div><pre><code>// JavaScript\nasync _getIPAddress() {\n  const url=\"https://httpbin.org/ip\";\n  const response = await fetch(url);\n  const json = await response.json();\n  const data = await json.origin;\n  console.log(data);\n}\n</code></pre></div></div></div></div>\n\n  <p>En Dart, una función <code>async</code> devuelve un <code>Future</code>, y el cuerpo de la función se programa\n    para su ejecución posterior. El operador <code>await</code> se utiliza para esperar por\n    un <code>Future</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\n_getIPAddress() async {\n  final url = 'https://httpbin.org/ip';\n  var request = await HttpRequest.request(url);\n  String ip = json.decode(request.responseText)['origin'];\n  print(ip);\n}\n</code></pre></div></div></div></div>\n\n  <p>Pruébalo en\n    DartPad.</p>\n\n  <p>Para más información, consulta la documentación <code>async</code> y\n    <code>await</code>.</p>\n\n  <h2>\n    Los fundamentos</h2>\n  <h3>\n    ¿Cómo creo una app Flutter?</h3>\n\n  <p>Para crear una app usando React Native, debes ejecutar <code>create-react-native-app</code>\n    desde la línea de comando.</p>\n\n  <div>  <div><pre>$ create-react-native-app &lt;projectname&gt;</pre></div></div>\n\n  <p>Para crear una aplicación en Flutter, haz una de las siguientes acciones:</p>\n\n  <ul>\n    <li>Usa el comando <code>flutter create</code> desde la línea de comando. Asegúrate de que el SDK de Flutter\n      esté definido en tu PATH.</li>\n    <li>Usa un IDE con los plugins de Flutter y Dart instalados.</li>\n  </ul>\n\n  <div>  <div><pre>$ flutter create &lt;projectname&gt;</pre></div></div>\n\n  <p>Para más información, consulta el tutorial Inicia: Panorama general que te\n    guiará en la creación de una app contador que se ejecuta dando clic a un botón. La creación de\n    un proyecto Flutter construye todos los archivos que se necesitan para ejecutar una app de\n    ejemplo tanto en dispositivos Android como en iOS.</p>\n\n  <h3>\n    ¿Cómo puedo ejecutar mi aplicación?</h3>\n\n  <p>En React Native, ejecutaría <code>npm run</code> o <code>yarn run</code> desde el directorio del\n    proyecto.</p>\n\n  <p>Puedes ejecutar aplicaciones Flutter de un par de maneras:</p>\n\n  <ul>\n    <li>Usa <code>flutter run</code> desde el directorio raíz del proyecto.</li>\n    <li>Usa la opción “run” en un IDE con los plugins de Flutter y Dart.</li>\n  </ul>\n\n  <p>Tu app se ejecuta sobre un dispositivo conectado, el simulador de iOS o el emulador de Android.</p>\n\n  <p>Para más información, consulta la documentación de Flutter Iniciando.</p>\n\n  <h3>\n    ¿Cómo importo widgets?</h3>\n\n  <p>En React Native, necesitas importar cada componente requerido.</p>\n\n  <div><div><div>  <div><pre><code>//React Native\nimport React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, para usar widgets de la biblioteca Material Design, importa el paquete <code>material.dart</code>. para usar widgets estilo iOS, importa la biblioteca Cupertino. Para utilizar un conjunto de widgets más básico, importa la biblioteca Widgets. O bien, puedes escribir tu propia biblioteca de widgets e importarla.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>import 'package:flutter/material.dart';\nimport 'package:flutter/cupertino.dart';\nimport 'package:flutter/widgets.dart';\nimport 'package:flutter/my_widgets.dart';\n</code></pre></div></div></div></div>\n  <p>Cualquiera sea el paquete de widgets que importes, Dart solo ingresa los widgets que se usan\n    en tu aplicación.</p>\n\n  <p>Para más información, consulta el Catálogo de Widgets deFlutter.</p>\n\n  <h3>\n    ¿Cuál es el equivalente de la app React Native “Hello world!” en Flutter?</h3>\n\n  <p>En React Native, la clase <code>HelloWorldApp</code> amplía <code>React.Component</code> e implementa\n    el método render devolviendo un componente de vista.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nimport React from \"react\";\nimport { StyleSheet, Text, View } from \"react-native\";\n\nexport default class App extends React.Component {\n  render() {\n    return (\n      &lt;View style={styles.container}&gt;\n        &lt;Text&gt;Hello world!&lt;/Text&gt;\n      &lt;/View&gt;\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  }\n});\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, puedes crear una aplicación “Hello world” idéntica utilizando los widgets <code>Center</code> y <code>Text</code> de la biblioteca principal de widgets. El widget <code>Center</code> se convierte en la raíz del árbol de widgets y tiene un hijo, el widget <code>Text</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    Center(\n      child: Text(\n        'Hello, world!',\n        textDirection: TextDirection.ltr,\n      ),\n    ),\n  );\n}\n\n</code></pre></div></div></div></div>\n\n  <p>Las siguientes imágenes muestran la interfaz de usuario de Android y iOS para la app\n    básica “Hello world!” de Flutter.</p>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_hello-world-basic-ed1ed2698fc492892552a8d719b0e124b7a50e2f8e0327f1548e2834b0aa515a.png\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_hello-world-basic-1ba3dfcb9fcbee11f5307cde947ab29dd4f52683f311b049242a28fefb37412b.png\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <p>Ahora que has visto la aplicación Flutter más básica, la siguiente sección muestra\n    cómo aprovechar las valiosas bibliotecas de widget de Flutter para crear una\n    aplicación moderna y pulida.</p>\n\n  <h3>¿Cómo uso los widgets y los encajo para formar un árbol de widgets?</h3>\n\n  <p>En Flutter, casi todo es un widget.</p>\n\n  <p>Los widgets son los componentes básicos de la interfaz de usuario de una aplicación. Compones\n    widgets en una jerarquía, llamada árbol de widgets. Cada widget se encaja dentro de un widget\n    adre y hereda propiedades de su padre. Incluso el objeto de la aplicación en sí es un widget.\n    No hay un objeto de “aplicación” separado. En cambio, el widget raíz cumple\n    esta función.</p>\n\n  <p>Un widget puede definir:</p>\n\n  <ul>\n    <li>Un elemento estructural como un botón o menú</li>\n    <li>Un elemento estilístico, como un font o un esquema de color</li>\n    <li>Un aspecto de layout como el padding o el alignment</li>\n  </ul>\n\n  <p>El siguiente ejemplo muestra la app “¡Hola, mundo!” utilizando widgets de la biblioteca\n    Material. En este ejemplo, el árbol de widgets está encajado dentro del widget raíz de\n    <code>MaterialApp</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nimport 'package:flutter/material.dart';\n\nvoid main() =&gt; runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Welcome to Flutter',\n      home: Scaffold(\n        appBar: AppBar(\n          title: Text('Welcome to Flutter'),\n        ),\n        body: Center(\n          child: Text('Hello world'),\n        ),\n      ),\n    );\n  }\n}\n\n</code></pre></div></div></div></div>\n\n  <p>Las siguientes imágenes muestran “¡Hola mundo!” construido a partir de widgets de Material Design. ¡Obtendrás más funcionalidad de forma gratuita que en la aplicación básica “Hello world!”.</p>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_hello-world-198f4b19ca6d3dd72f6a17dd858814cc42cf2bc696f61d7f273be95818110777.png\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_hello-world-ed7cf47213953bfca5eaa74fba63a78538d782f2c63a7c575068f3c2f7298bde.png\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <p>Al escribir una aplicación, usarás dos tipos de widgets: StatelessWidget o\n    StatefulWidget.\n    Un StatelessWidget es exactamente lo que parece: un widget sin estado. Un widget StatelessWidget\n    se crea una vez y nunca cambia su apariencia. Un elemento StatefulWidget cambia dinámicamente\n    de estado según los datos recibidos o la entrada del usuario.</p>\n\n  <p>La diferencia importante entre los widgets sin estado y con estado es que StatefulWidgets tiene un\n    objeto de estado que almacena datos de estado y los transporta a través de reconstrucciones de árbol,\n    para que no se pierda.</p>\n\n  <p>En aplicaciones simples o básicas, es fácil encajar widgets, pero a medida que la base de\n    códigos se hace más grande y la aplicación se vuelve más compleja, debe romper widgets\n    profundamente anidados en funciones que devuelven el widget o\n    clases más pequeñas.</p>\n\n  <h3>¿Cómo creo componentes reutilizables?</h3>\n\n  <p>En React Native, definirías una clase para crear un componente reutilizable y luego usarías\n    métodos props para establecer o devolver propiedades y valores de los elementos\n    seleccionados. En el siguiente ejemplo, la clase <code>CustomCard</code> se define y luego\n    se utiliza dentro de una clase padre.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nclass CustomCard extends React.Component {\n  render() {\n    return (\n      &lt;View&gt;\n        &lt;Text&gt; Card {this.props.index} &lt;/Text&gt;\n        &lt;Button\n          title=\"Press\"\n          onPress={() =&gt; this.props.onPress(this.props.index)}\n        /&gt;\n      &lt;/View&gt;\n    );\n  }\n}\n\n// Usage\n&lt;CustomCard onPress={this.onPress} index={item.key} /&gt;\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, define una clase para crear un widget personalizado y luego reutiliza el widget.\n    También puedes definir y llamar a una función que devuelve un widget reutilizable como se\n    muestra en la función <code>build</code> en el siguiente ejemplo.</p>\n\n  <div>  <div><pre>// Flutter\nclass CustomCard extends StatelessWidget {\n  CustomCard({@required this.index, @required \n     this.onPress});\n\n  final index;\n  final Function onPress;\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      child: Column(\n        children: &lt;Widget&gt;[\n          Text('Card $index'),\n          FlatButton(\n            child: const Text('Press'),\n            onPressed: this.onPress,\n          ),\n        ],\n      )\n    );\n  }\n}\n    ...\n// Usage\nCustomCard(\n  index: index,\n  onPress: () { \n    print('Card $index');\n  },\n)\n    ...</pre></div></div>\n\n  <p>En el ejemplo anterior, el constructor de la clase <code>CustomCard</code> usa la sintaxis de llaves <code>{ }</code> para indicar los\n    parámetros opcionales nombrados.</p>\n\n  <p>Para requerir estos campos, elimina las llaves del constructor o\n    agrega <code>@required</code> al constructor.</p>\n\n  <p>Las siguientes capturas de pantalla muestran un ejemplo de la clase reutilizable CustomCard.</p>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_custom-cards-6bdba4664044a9e5328c0304a51c45fc2812bb37b3d0d57b0c93b98d5bab1f42.png\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_custom-cards-47e3e1e3e73a0ce419eacbee11dc2f15b9acac9b5877c43cd1a783a792b519dc.png\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>Estructura y recursos del proyecto</h2>\n\n  <h3>\n    ¿Dónde empiezo a escribir el código?</h3>\n\n  <p>Comienza con el archivo <code>main.dart</code> Se autogenera cuando se crea una app\n    Flutter.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nvoid main(){\n print(\"Hello, this is the main function.\");\n}\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, el archivo de punto de entrada es <code>’projectname’/lib/main.dart</code>  y\n    la ejecución comienza desde la función <code>main</code>.</p>\n\n  <h3>\n    ¿Cómo se estructuran los archivos en una aplicación Flutter?</h3>\n\n  <p>Cuando creas un nuevo proyecto en Flutter, se construye la siguiente estructura de directorios. Puedes personalizarlo más tarde, pero aquí es donde empiezas.</p>\n\n  <div><div><div>  <div><pre><code>┬\n└ projectname\n  ┬\n  ├ android      - Contiene archivos específicos de Android.\n  ├ build        - Almacena archivos build de iOS y Android.\n  ├ ios          - Contiene archivos específicos de iOS.\n  ├ lib          - Contiene archivos de origen Dart accesibles externamente.\n    ┬\n    └ src        - Contiene archivos fuente adicionales.\n    └ main.dart  - El punto de entrada de Flutter y el inicio de una nueva app.\n                   Esto se genera automáticamente cuando creas un proyecto\n                   de Flutter.\n                   Es donde empiezas a escribir tu código de Dart.\n  ├ test         - Contiene archivos de prueba automatizados.\n  └ pubspec.yaml - Contiene los metadatos de la aplicación Flutter.\n                   Esto es equivalente al archivo package.json en React Native.\n</code></pre></div></div></div></div>\n\n  <h3>\n    ¿Dónde pongo mis recursos y activos y cómo los uso?</h3>\n\n  <p>Un recurso o activo de Flutter es un archivo que se incluye y se implementa con su aplicación\n    y es accesible en tiempo de ejecución. Las aplicaciones de Flutter pueden incluir los\n    siguientes tipos de activos:</p>\n  <ul>\n    <li>Datos estáticos como archivos JSON</li>\n    <li>Archivos de configuración</li>\n    <li>Iconos e imágenes (JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP,\n      and WBMP)</li>\n  </ul>\n\n  <p>Flutter utiliza el archivo <code>pubspec.yaml</code> ubicado en la raíz de tu proyecto, para identificar\n    los activos requeridos por una app.</p>\n\n  <div><div><div>  <div><pre><code>flutter:\n  assets:\n    - assets/my_icon.png\n    - assets/background.png\n</code></pre></div></div></div></div>\n\n  <p>La subsección de <code>assets</code>&nbsp;especifica los archivos que deberían incluirse con la app.\n    Cada asset se identifica mediante una ruta explícita relativa al archivo&nbsp;<code>pubspec.yaml</code>\n    donde se encuentra el archivo de assets. El orden en que se declaran los assets no importa.\n    El directorio actual utilizado (<code>assets</code>&nbsp;en este caso) no importa. Sin embargo,\n    mientras que los assets se pueden colocar en cualquier directorio de aplicaciones, es\n    una buena práctica colocarlos en el directorio de assets.</p>\n\n  <p>Durante un build, Flutter coloca los assets en un archivo especial llamado <em>asset bundle</em>,\n    del cual las apps leen en tiempo de ejecución.&nbsp;<em>asset bundle</em>, qué aplicaciones se leen en\n    tiempo de ejecución cuando se especifica la ruta de un asset en la sección de <code>pubspec.yaml</code>,\n    el proceso build busca cualquier archivo con el mismo nombre en subdirectorios adyacentes.\n    Estos archivos también se incluyen en el paquete asset bundle junto con el asset especificado.\n    Flutter utiliza variantes de assets al elegir imágenes apropiadas para su aplicación.</p>\n\n  <p>En React Native, debes agregar una imagen estática colocando el archivo de imagen en un\n    directorio de código fuente y haciendo referencia a él.</p>\n\n  <div><div><div>  <div><pre><code>&lt;Image source={require(\"./my-icon.png\")} /&gt;\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, agrega una imagen estática a tu aplicación utilizando la clase AssetImage en el\n    método de construcción de un widget.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>image: AssetImage('assets/background.png'),\n</code></pre></div></div></div></div>\n\n  <p>Para más información, consulta Recursos e\n    imágenes.</p>\n\n  <h3>\n    ¿Cómo puedo cargar imágenes en una red?</h3>\n\n  <p>En React Native, debes especificar el <code>uri</code> en la prop <code>source</code> del componente <code>Image</code>\n    y también proporcionar el tamaño si es necesario.</p>\n\n  <p>En Flutter, usa el constructor <code>Image.network</code> para incluir una imagen de una URL.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nbody: Image.network(\n          'https://flutter.io/images/owl.jpg',\n</code></pre></div></div></div></div>\n\n  <h3>\n    ¿Cómo instalo paquetes y plugins de paquetes?</h3>\n\n  <p>Flutter soporta el uso de paquetes compartidos aportados por otros desarrolladores a los ecosistemas\n    Flutter y Dart. Esto te permite construir rápidamente tu aplicación sin tener que desarrollar todo\n    desde cero. Los paquetes que contienen código específico de la plataforma se conocen como plugins\n    de paquetes.</p>\n\n  <p>En React Native, usarías <code>yarn add {package-name}</code> o <code>npm install --save\n    {package-name}</code> para instalar paquetes desde la línea de comando.</p>\n\n  <p>En Flutter, instala un paquete siguiendo las siguientes instrucciones:</p>\n\n  <ol>\n    <li>Agrega el nombre y la versión del paquete a la sección de dependencias <code>pubspec.yaml</code>.\n      El siguiente ejemplo muestra cómo añadir el paquete Dart <code>google_sign_in</code> al archivo\n      <code>pubspec.yaml</code>. Comprueba tus espacios cuando trabajes en el archivo YAML file\n      porque <strong>el espacio en blanco importa</strong>!</li>\n  </ol>\n\n  <div><div><div>  <div><pre><code>dependencies:\n  flutter:\n    sdk: flutter\n  google_sign_in: ^3.0.3\n</code></pre></div></div></div></div>\n\n  <ol>\n    <li>Instala el paquete desde la línea de comando usando <code>flutter pub get</code>.\n      Si usas un IDE, este a menudo ejecuta <code>flutter pub get</code> por ti, o puede que te pida\n      que lo hagas.</li>\n    <li>Importa el paquete en el código de tu app como se muestra a continuación:</li>\n  </ol>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>import 'package:flutter/cupertino.dart';\n</code></pre></div></div></div></div>\n\n  <p>Para más información, consulta Usando\n    Paquetes y\n    Desarrollando\n      Paquetes y Plugins.</p>\n\n  <p>Puedes encontrar muchos paquetes compartidos por los desarrolladores de Flutter en la sección\n    Paquetes Flutter de\n    pub.dartlang.org.</p>\n\n  <h2>Flutter widgets</h2>\n\n  <p>En Flutter, construyes tu interfaz de usuario a partir de widgets que describen cómo debería ser su\n    apariencia dada su configuración y estado actual.</p>\n\n  <p>Los widgets a menudo se componen de muchos widgets pequeños, de un solo propósito que\n    están anidados para producir efectos poderosos. Por ejemplo, el widget Container\n    consta de varios widgets responsables del layout, el pintado, el posicionamiento\n    y el dimensionado. Específicamente, el widget <code>Container</code> incluye los widgets\n    <code>LimitedBox</code>, <code>ConstrainedBox</code>, <code>Align</code>, <code>Padding</code>, <code>DecoratedBox</code>, y <code>Transform</code>.\n    En lugar de subclasificar <code>Container</code> para producir un efecto personalizado, puedes\n    componer estos y otros widgets simples de formas nuevas y únicas.</p>\n\n  <p>El widget <code>Center</code> es otro ejemplo de cómo puedes controlar el layout. Para centrar un\n    widget, envuélvelo en un widget <code>Center</code> y luego usa widgets de layout para alinear, filas,\n    columnas y cuadrículas. Estos widgets de layout no tienen una representación visual propia.\n    Al contrario, su único propósito es controlar algún aspecto del layout de otro widget.\n    Para entender por qué un widget se renderiza de cierta manera, a menudo es útil inspeccionar\n    los widgets vecinos.</p>\n\n  <p>Para más información, consulta la Descripción técnica general\n    de Flutter.</p>\n\n  <p>Para más información sobre los widgets principales del paquete Widgets, consulta\n    Widgets Básicos de Flutter,\n    el Catálogo de Widgets de Flutter, o\n    el Índice de Widgets de Flutter.</p>\n\n  <h2>Vistas</h2>\n\n  <h3>\n    ¿Cuál es el equivalente del contenedor <code>View</code>?</h3>\n\n  <p>En React Native, <code>View</code> es un contenedor que soporta el layout con <code>Flexbox</code>, estilo,\n    manejo táctil y controles de accesibilidad.</p>\n\n  <p>En Flutter, puedes utilizar los widgets de la biblioteca Widgets, tales como\n    Container,\n    Column,\n    Row, y\n    Center.</p>\n\n  <p>Para más información, consulta el catálogo de Widgets de Layout.</p>\n\n  <h3>\n    ¿Cuál es el equivalente de <code>FlatList</code> o <code>SectionList</code>?</h3>\n\n  <p>Una <code>List</code> es una lista desplegable de componentes dispuestos verticalmente.</p>\n\n  <p>En React Native, <code>FlatList</code> o <code>SectionList</code> se utilizan para renderizar listas\n    simples o seccionadas.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\n&lt;FlatList\n  data={[ ... ]}\n  renderItem={({ item }) =&gt; &lt;Text&gt;{item.key}&lt;/Text&gt;}\n/&gt;\n</code></pre></div></div></div></div>\n\n  <p><code>ListView</code> es\n    el widget de scrolling más utilizado de Flutter. El constructor por defecto\n    toma una lista explícita de hijos.\n    <code>ListView</code> es\n    más apropiado para un pequeño número de widgets. Para una lista grande o\n    infinita, usa <code>ListView.builder</code>, que construye sus hijos por demanda y sólo\n    construye aquellos que son visibles.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nvar data = [ ... ];\nListView.builder(\n  itemCount: data.length,\n  itemBuilder: (context, int index) {\n    return Text(\n      data[index],\n    );\n  },\n)\n</code></pre></div></div></div></div>\n  <img src=\"asset:assets/img/5_3_flatlist-91d7c8beaadff16f52d663e94aae7b4c9959d1d811dd7f12ea2005a10e166d34.gif\">\n  <figure class=\"site-figure\">\n    <div>\n\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_flatlist-2a18c0173248dd8bf250b29fab7e4cdbc917c27d90ac33c1c791ecb73463f3a5.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <p>Para obtener más información sobre cómo implementar una lista de desplazamiento\n    infinito, consulta la sección\n    Escribe tu primera app Flutter,\n      Part 1 en codelab.</p>\n\n  <h3>¿Cómo uso un Canvas para dibujar o pintar?</h3>\n\n  <p>En React Native, los componentes canvas no están presentes, por lo que se utilizan bibliotecas de terceros como <code>react-native-canvas</code>.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nhandleCanvas = canvas =&gt; {\n  const ctx = canvas.getContext(\"2d\");\n  ctx.fillStyle = \"skyblue\";\n  ctx.beginPath();\n  ctx.arc(75, 75, 50, 0, 2 * Math.PI);\n  ctx.fillRect(150, 100, 300, 300);\n  ctx.stroke();\n};\n\nrender() {\n  return (\n    &lt;View&gt;\n      &lt;Canvas ref={this.handleCanvas} /&gt;\n    &lt;/View&gt;\n  );\n}\n</code></pre></div></div></div></div>\n  <p>En Flutter, puedes usar\n    <code>CustomPaint</code> y\n    las clases <code>CustomPainter</code>\n    para dibujar en el canvas.</p>\n\n  <p>El siguiente ejemplo muestra cómo dibujar durante la fase de pintado usando el widget\n    <code>CustomPaint</code>. Implementa la clase abstracta, CustomPainter, y la pasa a la\n    propiedad del painter CustomPaint. Las subclases de CustomPaint deben implementar\n    los métodos <code>paint</code> y <code>shouldRepaint</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nclass MyCanvasPainter extends CustomPainter {\n\n  @override\n  void paint(Canvas canvas, Size size) {\n    Paint paint = Paint();\n    paint.color = Colors.amber;\n    canvas.drawCircle(Offset(100.0, 200.0), 40.0, paint);\n    Paint paintRect = Paint();\n    paintRect.color = Colors.lightBlue;\n    Rect rect = Rect.fromPoints(Offset(150.0, 300.0), Offset(300.0, 400.0));\n    canvas.drawRect(rect, paintRect);\n  }\n\n  bool shouldRepaint(MyCanvasPainter oldDelegate) =&gt; false;\n  bool shouldRebuildSemantics(MyCanvasPainter oldDelegate) =&gt; false;\n}\nclass _MyCanvasState extends State&lt;MyCanvas&gt; {\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: CustomPaint(\n        painter: MyCanvasPainter(),\n      ),\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_canvas-cf039fc10bae17fb60b21adb4228eb928b2bf284f95fee71c5a20033c217e333.png\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_canvas-2cc207759f6ab912bf73e1c3298dc2183618ef207ed989f4d83f6c08fd3a3279.png\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>Layouts</h2>\n\n  <h3>\n    ¿Cómo utilizo los widgets para definir las propiedades del layout?</h3>\n\n  <p>En React Native, la mayor parte del layout se puede hacer con las props\n    que se pasan a un componente específico. Por ejemplo, puede utilizar el\n    <code>style</code> en el componente <code>View</code> para especificar las propiedades\n    flexbox. Para ordenar los componentes en una columna, se deben especificar propiedades como:\n    <code>flexDirection: “column”</code>.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\n&lt;View\n  style={{\n    flex: 1,\n    flexDirection: \"column\",\n    justifyContent: \"space-between\",\n    alignItems: \"center\"\n  }}\n&gt;\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, el layout se define principalmente por widgets específicamente diseñados para\n    proporcionar layout, combinado con widgets de control y sus propiedades style.</p>\n\n  <p>Por ejemplo, los widgets\n    Column y\n    Row toman\n    un array de hijos y los alinean vertical y horizontalmente respectivamente. Un widget\n    Container toma una\n    combinación de propiedades de layout y estilo, y un widget\n    <code>Center</code>\n    que centra sus widgets hijos.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nCenter(\n  child: Column(\n    children: &lt;Widget&gt;[\n      Container(\n        color: Colors.red,\n        width: 100.0,\n        height: 100.0,\n      ),\n      Container(\n        color: Colors.blue,\n        width: 100.0,\n        height: 100.0,\n      ),\n      Container(\n        color: Colors.green,\n        width: 100.0,\n        height: 100.0,\n      ),\n    ],\n  ),\n)\n</code></pre></div></div></div></div>\n\n  <p>Flutter proporciona una variedad de widgets de layout en su biblioteca principal de widgets.\n    Por ejemplo, <code>Padding</code>,\n    <code>Align</code>, y\n    <code>Stack</code>.</p>\n\n  <p>Para obtener una lista completa, consulta Layout Widgets.</p>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_basic-layout-2490ba3bed87bbf579b422977dcaa34f51a5b77dab53abbd460028acda33a000.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_basic-layout-bb720a0054daf418b7bafb40619c490933b730f9e45bd9003254ea9d80d6c163.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h3>\n    ¿Cómo puedo crear capas de widgets?</h3>\n\n  <p>En React Native, los componentes se pueden poner en capas utilizando el posicionamiento “absoluto”.</p>\n\n  <p>Flutter usa el widget\n    <code>Stack</code>\n    para organizar los widgets hijos en capas. Los widgets pueden superponerse\n    total o parcialmente al widget base.</p>\n\n  <p>El widget <code>Stack</code> posiciona a sus hijos con relación a los bordes de la caja. Este\n    es útil si simplemente deseas superponer varios widgets hijo.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nStack(\n  alignment: const Alignment(0.6, 0.6),\n  children: &lt;Widget&gt;[\n    CircleAvatar(\n      backgroundImage: NetworkImage(\n        \"https://avatars3.githubusercontent.com/u/14101776?v=4\"),\n    ),\n    Container(\n      decoration: BoxDecoration(\n          color: Colors.black45,\n      ),\n      child: Text('Flutter'),\n    ),\n  ],\n)\n</code></pre></div></div></div></div>\n\n  <p>El ejemplo anterior utiliza <code>Stack</code> para superponer un Contenedor (que muestra su\n    <code>Text</code> sobre un fondo negro translúcido) encima de <code>CircleAvatar</code>.\n    El Stack desplaza el texto usando la propiedad de alineación y las coordenadas de Alineación.</p>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_stack-65e0c9e7fc3db73d80d3943f6e88fc788819b1ab4c1354c11e4711298e26ecd0.png\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_stack-04b7bf2727e1eb71f5dfea8430ee833f24be1ced1893ae86270795b2ab76c5b9.png\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <p>Para más información,\n    consulta la documentación de la clase\n    Stack.</p>\n\n  <h2>\n    Estilo</h2>\n\n  <h3>\n    ¿Cómo le doy estilo a mi componente?</h3>\n\n  <p>En React Native, el estilo en línea y <code>stylesheets.create</code> se utilizan\n    para modelar componentes.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\n&lt;View style={styles.container}&gt;\n  &lt;Text style={{ fontSize: 32, color: \"cyan\", fontWeight: \"600\" }}&gt;\n    This is a sample text\n  &lt;/Text&gt;\n&lt;/View&gt;\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: \"#fff\",\n    alignItems: \"center\",\n    justifyContent: \"center\"\n  }\n});\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, un widget <code>Text</code> puede tomar una clase <code>TextStyle</code> por su propiedad de estilo.\n    Si deseas utilizar el mismo estilo de texto en varios lugares, puedes crear una\n    clase <code>TextStyle</code> y\n    utilizarla para varios widgets <code>Text</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nvar textStyle = TextStyle(fontSize: 32.0, color: Colors.cyan, fontWeight:\n   FontWeight.w600);\n\t...\nCenter(\n  child: Column(\n    children: &lt;Widget&gt;[\n      Text(\n        'Sample text',\n        style: textStyle,\n      ),\n      Padding(\n        padding: EdgeInsets.all(20.0),\n        child: Icon(Icons.lightbulb_outline,\n          size: 48.0, color: Colors.redAccent)\n      ),\n    ],\n  ),\n)\n</code></pre></div></div></div></div>\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_flutterstyling-10cfb607a02859b2a1e9767237029b3cc47891fd017bd70d84536de26383b39c.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_flutterstyling-8b812e5226435b0db6f72b4f2f03a7c72b45bf0794965a0bee882fea909fc7b8.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h3>\n    ¿Cómo uso <code>Iconos</code> y <code>Colores</code>?</h3>\n\n  <p>React Native no incluye soporte para iconos, por lo que se utilizan bibliotecas de terceros.</p>\n\n  <p>En Flutter, la importación de la biblioteca Material también arrastra\n    el rico conjunto de iconos\n    y colores de Material.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>Icon(Icons.lightbulb_outline, color: Colors.redAccent)\n</code></pre></div></div></div></div>\n\n  <p>Cuando utilices la clase <code>Iconos</code>, asegúrate de establecer <code>uses-material-design: true</code>\n    en el archivo <code>pubspec.yaml</code> del proyecto. Esto asegura que la fuente <code>MaterialIcons</code>,\n    que muestra los iconos, está incluida en tu aplicación.</p>\n  <div>  <div><pre>name: my_awesome_application\nflutter: uses-material-design: true</pre></div></div>\n\n  <p>El paquete Cupertino (iOS-style) de Flutter proporciona\n    widgets de alta fidelidad para el lenguaje de diseño actual de iOS. Para utilizar la fuente\n    <code>CupertinoIcons</code>, añade una dependencia para <code>cupertino_icons</code> en tu archivo del proyecto&nbsp;<code>pubspec.yaml</code>.</p>\n\n  <div><div><div>  <div><pre><code>name: my_awesome_application\ndependencies:\n  cupertino_icons: ^0.1.0\n</code></pre></div></div></div></div>\n\n  <p>Para personalizar globalmente los colores y estilos de los componentes, usa <code>ThemeData</code>\n    para especificar los colores predeterminados para varios aspectos del theme.\n    Establece la propiedad del theme en <code>MaterialApp</code> en el objeto <code>ThemeData</code>. La clase\n    <code>Colors</code>\n    proporciona los colores de la paleta de\n      colores de Material Design.</p>\n\n  <p>El siguiente ejemplo establece la muestra primaria en <code>azul</code> y la selección de\n    texto en <code>rojo</code>.</p>\n\n  <!-- skip -->\n  <div>  <div><pre>class SampleApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Sample App',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        textSelectionColor: Colors.red\n      ),\n      home: SampleAppPage(),\n    );\n  }\n}</pre></div></div>\n\n  <h3>\n    ¿Cómo añado themes de estilo?</h3>\n\n  <p>En React Native, se definen themes comunes para componentes en hojas de estilo\n    y luego se utiliza en los componentes.</p>\n\n  <p>En Flutter, crea un estilo uniforme para casi todo definiendo el estilo en\n    la clase\n    <code>ThemeData</code>\n    y pasándolo a la propiedad theme en el\n    widget\n    <code>MaterialApp</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      theme: ThemeData(\n        primaryColor: Colors.cyan,\n        brightness: Brightness.dark,\n      ),\n      home: StylingPage(),\n    );\n  }\n</code></pre></div></div></div></div>\n\n  <p>Un <code>tema</code> puede aplicarse incluso sin usar el widget <code>MaterialApp</code>. El\n    <code>Theme</code>\n    toma un widget <code>ThemeData</code> en su parámetro <code>data</code> y aplica el\n    <code>ThemeData</code> a todos sus widgets hijos.</p>\n\n  <!-- skip -->\n  <div>  <div><pre><code> @override\n  Widget build(BuildContext context) {\n    return Theme(\n      data: ThemeData(\n        primaryColor: Colors.cyan,\n        brightness: brightness,\n      ),\n      child: Scaffold(\n         backgroundColor: Theme.of(context).primaryColor,\n              ...\n              ...\n      ),\n    );\n  }\n</code></pre></div></div>\n\n  <h2>\n    Gestión de Estado</h2>\n\n  <p>State es la información que se puede leer sincrónicamente cuando se construye un widget o\n    información que puede cambiar durante la vida útil de un widget. Para manejar el estado de\n    la app en Flutter, usa un\n    StatefulWidget acoplado\n    con un objeto State.</p>\n\n  <h3>\n    El StatelessWidget</h3>\n\n  <p>Un <code>StatelessWidget</code> en Flutter es un widget que no requiere un cambio de estado\n    no tiene estado interno a gestionar.</p>\n\n  <p>Los widgets sin estado son útiles cuando la parte de la interfaz de usuario que estás\n    describiendo no depende de nada más que de la información de configuración del\n    propio objeto y del\n    <code>BuildContext</code>\n    en el cual se eleva el widget.</p>\n\n  <p>AboutDialog,\n    CircleAvatar,\n    y Text\n    son ejemplos de widgets sin estado que subclasifican el\n    StatelessWidget.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nimport 'package:flutter/material.dart';\n\nvoid main() =&gt; runApp(MyStatelessWidget(text: \"StatelessWidget Example to show immutable data\"));\n\nclass MyStatelessWidget extends StatelessWidget {\n  final String text;\n  MyStatelessWidget({Key key, this.text}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Center(\n      child: Text(\n        text,\n        textDirection: TextDirection.ltr,\n      ),\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <p>En el ejemplo anterior, usaste el constructor de la clase <code>MyStatelessWidget</code>\n    para pasar el <code>text</code>, que está marcado como <code>final</code>. Esta clase extiende de\n    <code>StatelessWidget</code>—contiene datos inmutables.</p>\n\n  <p>El método <code>build</code> de un widget sin estado se llama típicamente en sólo tres\n    situaciones:</p>\n\n  <ul>\n    <li>Cuando el widget se inserta en un árbol</li>\n    <li>Cuando el padre del widget cambia su configuración</li>\n    <li>Cuando un\n      <code>InheritedWidget</code>\n      del que depende, cambia</li>\n  </ul>\n\n  <h3>\n    El StatefulWidget</h3>\n\n  <p>Un StatefulWidget\n    es un widget que cambia de estado. Utiliza el <code>setState</code>\n    para gestionar los cambios de estado de un <code>StatefulWidget</code>. Una llamada a <code>setState</code>\n    le dice al framework Flutter que algo ha cambiado en un estado, que\n    hace que una aplicación ejecute de nuevo el método <code>build</code> para que la aplicación pueda reflejar el cambio.</p>\n\n  <p>El estado es la información que se puede leer sincrónicamente cuando se construye un widget y puede\n    cambiar durante la vida útil del widget. Es responsabilidad del implementador del widget asegurarse\n    de que el estado sea notificado rápidamente cuando el estado cambie. Utiliza <code>StatefulWidget</code> cuando\n    un widget puede cambiar dinámicamente. Por ejemplo, el estado del widget cambia escribiendo en un\n    formulario o moviendo un deslizador. O bien, puede cambiar con el tiempo, tal vez una fuente de datos\n    actualice la interfaz de usuario.</p>\n\n  <p>Checkbox,\n    Radio,\n    Slider,\n    InkWell,\n    Form,\n    y TextField\n    son ejemplos de widgets stateful, aquella subclase\n    StatefulWidget.</p>\n\n  <p>El siguiente ejemplo declara un <code>StatefulWidget</code> que requiere un método <code>createState()</code>.\n    Este método crea el objeto state que gestiona el estado del widget,\n    <code>_MyStatefulWidgetState</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>class MyStatefulWidget extends StatefulWidget {\n  MyStatefulWidget({Key key, this.title}) : super(key: key);\n  final String title;\n\n  @override\n  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();\n}\n</code></pre></div></div></div></div>\n\n  <p>La siguiente clase de estado, <code>_MyStatefulWidgetState</code>, implementa el método <code>build()</code> para el\n    widget. Cuando el estado cambia, por ejemplo, si el usuario conmuta el botón, se llama a\n    <code>setState</code> con el nuevo valor de conmutación. Esto hace que el framework reconstruya este\n    widget en la interfaz de usuario.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>class _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; {\n  bool showtext=true;\n  bool toggleState=true;\n  Timer t2;\n\n  void toggleBlinkState(){\n    setState((){\n      toggleState=!toggleState;\n    });\n    var twenty = const Duration(milliseconds: 1000);\n    if(toggleState==false) {\n      t2 = Timer.periodic(twenty, (Timer t) {\n        toggleShowText();\n      });\n    } else {\n      t2.cancel();\n    }\n  }\n\n  void toggleShowText(){\n    setState((){\n      showtext=!showtext;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Column(\n          children: &lt;Widget&gt;[\n            (showtext\n              ?(Text('This execution will be done before you can blink.'))\n              :(Container())\n            ),\n            Padding(\n              padding: EdgeInsets.only(top: 70.0),\n              child: RaisedButton(\n                onPressed: toggleBlinkState,\n                child: (toggleState\n                  ?( Text('Blink'))\n                  :(Text('Stop Blinking'))\n                )\n              )\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <h3>\n    ¿Cuáles son las mejores prácticas de StatefulWidget y StatelessWidget?</h3>\n\n  <p>Aquí tienes algunas cosas que debes considerar al diseñar tu widget.</p>\n\n  <h4>1. Determinar si un widget debe ser un StatefulWidget o un StatelessWidget</h4>\n\n  <p>En Flutter, los widgets son Stateful o Stateless dependiendo de si\n    dependen de un cambio de estado.</p>\n\n  <ul>\n    <li>Si un widget cambia, el usuario interactúa con él o una fuente de datos interrumpe la\n      UI, entonces está es Stateful.</li>\n    <li>Si un widget es final o inmutable, entonces es Stateless.</li>\n  </ul>\n\n  <h4>2. Determinar qué objeto gestiona el estado del widget (para un StatefulWidget)</h4>\n\n  <p>En Flutter, hay tres maneras principales de gestionar el estado:</p>\n\n  <ul>\n    <li>El widget gestiona su propio estado</li>\n    <li>El widget padre gestiona el estado del widget</li>\n    <li>Un enfoque intermedio</li>\n  </ul>\n\n  <p>Al decidir qué enfoque utilizar, ten en cuenta los siguientes principios:</p>\n\n  <ul>\n    <li>Si el estado en cuestión son datos de usuario, por ejemplo, el modo marcado o no marcado\n      de una casilla de verificación, o la posición de un deslizador, entonces el estado se\n      gestiona mejor con el widget padre.</li>\n    <li>Si el estado en cuestión es estético, por ejemplo, una animación, entonces el propio\n      widget gestiona mejor el estado.</li>\n    <li>En caso de duda, deja que el widget padre gestione el estado del widget hijo.</li>\n  </ul>\n\n  <h4>3. Subclase StatefulWidget y State</h4>\n\n  <p>La clase <code>MyStatefulWidget</code> gestiona su propio estado, extiende <code>StatefulWidget</code>,\n    sobrescribe el método <code>createState()</code> para crear el objeto State, y el\n    framework llama <code>createState()</code> para construir el widget. En este ejemplo,\n    <code>createState()</code> crea una instancia de <code>_MyStatefulWidgetState</code>, que se implementa\n    en la siguiente mejor práctica.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>class MyStatefulWidget extends StatefulWidget {\n  MyStatefulWidget({Key key, this.title}) : super(key: key);\n  final String title;\n\n  @override\n  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();\n}\n\nclass _MyStatefulWidgetState extends State&lt;MyStatefulWidget&gt; {\n\n  @override\n  Widget build(BuildContext context) {\n    ...\n  }\n}\n</code></pre></div></div></div></div>\n\n  <h4>4. Agregar StatefulWidget al árbol de widgets</h4>\n\n  <p>Añade tu <code>StatefulWidget</code> personalizado al árbol de widgets en el método build de la aplicación.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>class MyStatelessWidget extends StatelessWidget {\n  // Este widget es la raíz de tu aplicación.\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: MyStatefulWidget(title: 'State Change Demo'),\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_state-change-f7c0c14b9e1e2685b25c9e42f42a8d35ea9be544bbae3849579283bc631d9e26.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_state-change-f25a8c982e6cddbb81b069c8e2acb9de5cb62c66bba2be2ff79e08269d4e6add.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Props</h2>\n\n  <p>En React Native, la mayoría de los componentes se pueden personalizar cuando se crean con\n    diferentes parámetros o propiedades, llamados <code>props</code>. Estos parámetros pueden ser usados\n    en un componente hijo usando <code>this.props</code>.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nclass CustomCard extends React.Component {\n  render() {\n    return (\n      &lt;View&gt;\n        &lt;Text&gt; Card {this.props.index} &lt;/Text&gt;\n        &lt;Button\n          title=\"Press\"\n          onPress={() =&gt; this.props.onPress(this.props.index)}\n        /&gt;\n      &lt;/View&gt;\n    );\n  }\n}\nclass App extends React.Component {\n\n  onPress = index =&gt; {\n    console.log(\"Card \", index);\n  };\n\n  render() {\n    return (\n      &lt;View&gt;\n        &lt;FlatList\n          data={[ ... ]}\n          renderItem={({ item }) =&gt; (\n            &lt;CustomCard onPress={this.onPress} index={item.key} /&gt;\n          )}\n        /&gt;\n      &lt;/View&gt;\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, se asigna una variable o función local marcada como <code>final</code> con la propiedad\n    recibida en el constructor parametrizado.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nclass CustomCard extends StatelessWidget {\n\n  CustomCard({@required this.index, @required this.onPress});\n  final index;\n  final Function onPress;\n\n  @override\n  Widget build(BuildContext context) {\n  return Card(\n    child: Column(\n      children: &lt;Widget&gt;[\n        Text('Card $index'),\n        FlatButton(\n          child: const Text('Press'),\n          onPressed: this.onPress,\n        ),\n      ],\n    ));\n  }\n}\n    ...\n//Usage\nCustomCard(\n  index: index,\n  onPress: () {\n    print('Card $index');\n  },\n)\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_modular-6bdba4664044a9e5328c0304a51c45fc2812bb37b3d0d57b0c93b98d5bab1f42.png\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_modular-47e3e1e3e73a0ce419eacbee11dc2f15b9acac9b5877c43cd1a783a792b519dc.png\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Almacenamiento local</h2>\n\n  <p>Si no necesitas almacenar muchos datos y no requieres estructura, puedes usar\n    <code>shared_preferences</code> que te permite leer y escribir parejas clave-valor\n    persistentes de tipos de datos primitivos: booleans, floats, ints, longs,\n    y strings.</p>\n\n  <h3>\n    ¿Cómo puedo almacenar parejas persistentes de clave-valor que son globales para la aplicación?</h3>\n\n  <p>En React Native, se utilizan las funciones <code>setItem</code> y <code>getItem</code> del\n    componente <code>AsyncStorage</code> para almacenar y recuperar datos que son\n    persistentes y globales para la aplicación.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// React Native\nawait AsyncStorage.setItem( \"counterkey\", json.stringify(++this.state.counter));\nAsyncStorage.getItem(\"counterkey\").then(value =&gt; {\n  if (value != null) {\n    this.setState({ counter: value });\n  }\n});\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, usa los plugins\n    <code>shared_preferences</code>\n    para almacenar y recuperar datos key-value que son persistentes y globales\n    para la app. El plugin <code>shared_preferences</code> envuelve <code>NSUserDefaults</code> en iOS\n    y <code>SharedPreferences</code> en Android, proporcionando un almacenamiento persistente\n    para datos simples. Para usar el plugin, agrega <code>shared_preferences</code> como una\n    dependencia en el archivo <code>pubspec.yaml</code> y luego importa el paquete en tu archivo Dart.</p>\n\n  <div><div><div>  <div><pre><code>dependencies:\n  flutter:\n    sdk: flutter\n  shared_preferences: ^0.4.3\n</code></pre></div></div></div></div>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Dart\nimport 'package:shared_preferences/shared_preferences.dart';\n</code></pre></div></div></div></div>\n\n  <p>Para implementar datos persistentes, utiliza los métodos setter proporcionados por la\n    clase <code>SharedPreferences</code>. Los métodos de setter están disponibles para varios\n    tipos primitivos, tales como <code>setInt</code>, <code>setBool</code>, y <code>setString</code>. Para leer los\n    datos, utiliza el método getter apropiado proporcionado por la clase\n    <code>SharedPreferences</code>. Para cada setter hay un método getter correspondiente,\n    por ejemplo, <code>getInt</code>, <code>getBool</code>, y <code>getString</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>SharedPreferences prefs = await SharedPreferences.getInstance();\n_counter = prefs.getInt('counter');\nprefs.setInt('counter', ++_counter);\nsetState(() {\n  _counter = _counter;\n});\n</code></pre></div></div></div></div>\n\n  <h2>\n    Enrutamiento</h2>\n\n  <p>La mayoría de las aplicaciones contienen varias pantallas para mostrar diferentes tipos de\n    información. Por ejemplo, puedes tener una pantalla de producto que muestre imágenes en la\n    que los usuarios puedan hacer clic sobre una imagen de producto para obtener más información\n    sobre el producto en una nueva pantalla.</p>\n\n  <p>En Android, las nuevas pantallas son new Activities. En iOS, las nuevas pantallas son new\n    ViewControllers. ¡En Flutter, las pantallas son sólo Widgets! Y para navegar a nuevas pantallas\n    en Flutter, usa el widget Navigator.</p>\n\n  <h3>\n    ¿Cómo navego entre pantallas?</h3>\n\n  <p>En React Native, hay tres navegadores principales: StackNavigator, TabNavigator,\n    y DrawerNavigator. Cada uno proporciona una manera de configurar y definir las pantallas.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// React Native\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\nconst SimpleApp = StackNavigator({\n  Home: { screen: MyApp },\n  stackScreen: { screen: StackScreen }\n});\nexport default (MyApp1 = DrawerNavigator({\n  Home: {\n    screen: SimpleApp\n  },\n  Screen2: {\n    screen: drawerScreen\n  }\n}));\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, hay dos widgets principales utilizados para navegar entre pantallas:</p>\n  <ul>\n    <li>Un Route es una abstracción\n      para una pantalla o página de una app.</li>\n    <li>Un Navigator es un\n      widget que gestiona rutas.</li>\n  </ul>\n\n  <p>Un “Navegador” se define como un widget que gestiona un conjunto de widgets hijo con\n    una disciplina stack. El navegador gestiona un stack de objetos <code>Route</code> y proporciona\n    métodos para gestionar el stack, como\n    <code>Navigator.push</code>\n    y <code>Navigator.pop</code>.\n    Se puede especificar una lista de rutas en el widget\n    <code>MaterialApp</code>,\n    o se pueden construir sobre la marcha, por ejemplo, en animaciones de héroes.\n    El siguiente ejemplo especifica rutas con nombre en el widget <code>MaterialApp</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nclass NavigationApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n            ...\n      routes: &lt;String, WidgetBuilder&gt;{\n        '/a': (BuildContext context) =&gt; usualNavscreen(),\n        '/b': (BuildContext context) =&gt; drawerNavscreen(),\n      }\n            ...\n  );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <p>Para navegar a una ruta con nombre, se utiliza el método\n    of\n    del widget <code>Navigator</code> para especificar el <code>BuildContext</code>\n    (un manejador para la ubicación de un widget en el directorio\n    árbol de widgets). El nombre de la ruta se pasa a la función <code>pushNamed</code> para\n    navegar hasta la ruta especificada.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>Navigator.of(context).pushNamed('/a');\n</code></pre></div></div></div></div>\n\n  <p>También puedes usar el método push de <code>Navigator</code> que agrega la\n    <code>route</code>\n    dada a la historia del navegador que delimita más estrechamente el\n    <code>context</code>\n    dado, y las transiciones hacia él. En el siguiente ejemplo, el widget\n    <code>MaterialPageRoute</code>\n    es una ruta modal que sustituye toda la pantalla por una transición adaptada a\n    la plataforma. Toma un\n    <code>WidgetBuilder</code>\n    como un parámetro requerido.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>Navigator.push(context, MaterialPageRoute(builder: (BuildContext context)\n =&gt; UsualNavscreen()));\n</code></pre></div></div></div></div>\n\n  <h3>\n    ¿Cómo se utiliza la navegación por tab y drawer?</h3>\n\n  <p>En las aplicaciones de Material Design, hay dos opciones principales para la navegación Flutter:\n    tabs y drawers. Cuando no hay espacio suficiente para sostener tabs, los drawers\n    son una buena alternativa.</p>\n\n  <h4>\n    Navegación por Tab</h4>\n\n  <p>En React Native, <code>createBottomTabNavigator</code> y <code>TabNavigation</code> se utilizan para\n    mostrar tabs  y para navegación por tab.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nimport { createBottomTabNavigator } from 'react-navigation';\n\nconst MyApp = TabNavigator(\n  { Home: { screen: HomeScreen }, Notifications: { screen: tabNavScreen } },\n  { tabBarOptions: { activeTintColor: \"#e91e63\" } }\n);\n</code></pre></div></div></div></div>\n\n  <p>Flutter proporciona varios widgets especializados para la navegación por drawer y tab:</p>\n  <ul>\n    <li>\n      TabController—Coordina\n      la selección de pestañas entre una TabBar y una TabBarView.</li>\n    <li>\n      TabBar—Muestra una fila\n      horizontal de pestañas.</li>\n    <li>\n      Tab—Crea una pestaña TabBar de\n      material design.</li>\n    <li>\n      TabBarView—Muestra el\n      widget que corresponde a la pestaña actualmente seleccionada.</li>\n  </ul>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nTabController controller=TabController(length: 2, vsync: this);\n\nTabBar(\n  tabs: &lt;Tab&gt;[\n    Tab(icon: Icon(Icons.person),),\n    Tab(icon: Icon(Icons.email),),\n  ],\n  controller: controller,\n),\n\n</code></pre></div></div></div></div>\n\n  <p>Se necesita un <code>TabController</code> para coordinar la selección de tabs entre un <code>TabBar</code> y un\n    <code>TabBarView</code>. El argumento length del constructor <code>TabController</code> es el número total de tabs.\n    Se requiere un <code>TickerProvider</code> para activar la notificación siempre que un\n    frame active un cambio de estado. El <code>TickerProvider</code> es <code>vsync</code>. Pasa el argumento\n    <code>vsync: this</code> al constructor <code>TabController</code> cada vez que crees\n    un nuevo <code>TabController</code>.</p>\n\n  <p>El TickerProvider\n    es una interfaz implementada por clases que pueden despachar objetos\n    <code>Ticker</code>.\n    Los Tickers pueden ser utilizados por cualquier objeto que deba ser notificado\n    siempre que se active un frame, pero se utilizan más comúnmente de forma indirecta a través de un\n    <code>AnimationController</code>.\n    Los <code>AnimationControllers</code> requieren de un <code>TickerProvider</code> para obtener su <code>Ticker</code>.\n    Si estás creando un AnimationController desde un estado, puedes usar la clase\n    <code>TickerProviderStateMixin</code>\n    o la clase <code>SingleTickerProviderStateMixin</code>\n    para obtener un <code>TickerProvider</code> adecuado.</p>\n\n  <p>El widget <code>Scaffold</code>\n    envuelve un nuevo widget <code>TabBar</code> y crea dos tabs.\n    El widget <code>TabBarView</code> se pasa como el parámetro <code>body</code> del widget <code>Scaffold</code>.\n    Todas las pantallas correspondientes al widget <code>TabBar</code> son hijas del widget <code>TabBarView</code>\n    junto con el mismo <code>TabController</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\n\nclass _NavigationHomePageState extends State&lt;NavigationHomePage&gt; with SingleTickerProviderStateMixin {\n  TabController controller=TabController(length: 2, vsync: this);\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      bottomNavigationBar: Material (\n        child: TabBar(\n          tabs: &lt;Tab&gt; [\n            Tab(icon: Icon(Icons.person),)\n            Tab(icon: Icon(Icons.email),),\n          ],\n          controller: controller,\n        ),\n        color: Colors.blue,\n      ),\n      body: TabBarView(\n        children: &lt;Widget&gt; [\n          home.homeScreen(),\n          tabScreen.tabScreen()\n        ],\n        controller: controller,\n      )\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <h4>\n    Navegación por Drawer</h4>\n\n  <p>En React Native, importa los paquetes de navegación react necesarios y luego utiliza\n    “createDrawerNavigator” y “DrawerNavigation”.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nexport default (MyApp1 = DrawerNavigator({\n  Home: {\n    screen: SimpleApp\n  },\n  Screen2: {\n    screen: drawerScreen\n  }\n}));\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, podemos usar el widget <code>Drawer</code> en combinación con un <code>Scaffold</code> para crear un layout\n    con un drawer de Material Design. Para añadir un <code>Drawer</code> a una aplicación, envuélvelo en un\n    widget <code>Scaffold</code>. El widget <code>Scaffold</code> proporciona una estructura visual consistente a las\n    aplicaciones que siguen las pautas de Material Design.\n    También soporta componentes especiales de Material Design, tales como <code>Drawers</code>,\n    <code>AppBars</code>, y <code>SnackBars</code>.</p>\n\n  <p>El widget <code>Drawer</code> es un panel de Material Design que se desliza horizontalmente desde\n    el borde de un <code>Scaffold</code> para mostrar enlaces de navegación en una aplicación. Puedes\n    proporcionar un widget\n    <code>Button</code>, un widget\n    <code>Text</code>, o una lista de elementos\n    que se mostrarán como el hijo del Widget <code>Drawer</code>. En el siguiente ejemplo, el widget\n    <code>ListTile</code>\n    proporciona la navegación con tap.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nDrawer(\n  child:ListTile(\n    leading: Icon(Icons.change_history),\n    title: Text('Screen2'),\n    onTap: () {\n      Navigator.of(context).pushNamed(\"/b\");\n    },\n  ),\n  elevation: 20.0,\n),\n</code></pre></div></div></div></div>\n\n  <p>El widget <code>Scaffold</code> también incluye un widget <code>AppBar</code> que muestra automáticamente un\n    IconButton apropiado para mostrar el <code>Drawer</code> cuando un Drawer está disponible en el\n    <code>Scaffold</code>. El <code>Scaffold</code> maneja automáticamente el gesto de edge-swipe\n    para mostrar el <code>Drawer</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\n@override\nWidget build(BuildContext context) {\n  return Scaffold(\n    drawer: Drawer(\n      child: ListTile(\n        leading: Icon(Icons.change_history),\n        title: Text('Screen2'),\n        onTap: () {\n          Navigator.of(context).pushNamed(\"/b\");\n        },\n      ),\n      elevation: 20.0,\n    ),\n    appBar: AppBar(\n      title: Text(\"Home\"),\n    ),\n    body: Container(),\n  );\n}\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img alt=\"Navigation on Android\" class=\"border\" src=\"asset:assets/img/5_3_navigation-98906732ed22d9aa8e0ce0eb846dbcc7d24c123ad026c359f9f7fcc44ba99230.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img alt=\"Navigation on iOS\" class=\"border\" src=\"asset:assets/img/5_3_navigation-1939f60628bec820bad0fe88d58c562984c1c00d8cfd755a4135f4321a37417e.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Detección de gestos y manejo de eventos táctiles</h2>\n\n  <p>Para escuchar y responder a los gestos, Flutter soporta taps, drags, and\n    scaling. El sistema de gestos en Flutter tiene dos capas separadas.\n    La primera capa incluye eventos de puntero en bruto, que describen la\n    ubicación y el movimiento de los punteros (como los movimientos touches, mice,\n    y styli) a través de la pantalla. La segunda capa incluye gestos, que describen acciones\n    semánticas que consisten en uno o más movimientos del puntero.</p>\n\n  <h3>\n    ¿Cómo puedo añadir un clic o pulsar listeners a un widget?</h3>\n\n  <p>En React Native, los listeners se añaden a los componentes usando <code>PanResponder</code>\n    o los componentes <code>Touchable</code>.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\n&lt;TouchableOpacity\n  onPress={() =&gt; {\n    console.log(\"Press\");\n  }}\n  onLongPress={() =&gt; {\n    console.log(\"Long Press\");\n  }}\n&gt;\n  &lt;Text&gt;Tap or Long Press&lt;/Text&gt;\n&lt;/TouchableOpacity&gt;\n</code></pre></div></div></div></div>\n\n  <p>Para gestos más complejos y combinar varios toques en un solo gesto,\n    se utiliza\n    <code>PanResponder</code>.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nclass App extends Component {\n\n  componentWillMount() {\n    this._panResponder = PanResponder.create({\n      onMoveShouldSetPanResponder: (event, gestureState) =&gt;\n        !!getDirection(gestureState),\n      onPanResponderMove: (event, gestureState) =&gt; true,\n      onPanResponderRelease: (event, gestureState) =&gt; {\n        const drag = getDirection(gestureState);\n      },\n      onPanResponderTerminationRequest: (event, gestureState) =&gt; true\n    });\n  }\n\n  render() {\n    return (\n      &lt;View style={styles.container} {...this._panResponder.panHandlers}&gt;\n        &lt;View style={styles.center}&gt;\n          &lt;Text&gt;Swipe Horizontally or Vertically&lt;/Text&gt;\n        &lt;/View&gt;\n      &lt;/View&gt;\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, para añadir un clic (o pulsar) en un listener a un widget, utiliza un\n    botón o un widget táctil que tenga un campo <code>onPress: field</code>. O bien, agrega\n    detección de gestos a cualquier widget envolviéndolo en un\n    <code>Detector de gestos</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nGestureDetector(\n  child: Scaffold(\n    appBar: AppBar(\n      title: Text(\"Gestures\"),\n    ),\n    body: Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: &lt;Widget&gt;[\n          Text('Tap, Long Press, Swipe Horizontally or Vertically '),\n        ],\n      )\n    ),\n  ),\n  onTap: () {\n    print('Tapped');\n  },\n  onLongPress: () {\n    print('Long Pressed');\n  },\n  onVerticalDragEnd: (DragEndDetails value) {\n    print('Swiped Vertically');\n  },\n  onHorizontalDragEnd: (DragEndDetails value) {\n    print('Swiped Horizontally');\n  },\n);\n</code></pre></div></div></div></div>\n  <p>Para obtener más información, incluida una lista de callbacks Flutter <code>GestureDetector</code>,\n    consulta la\n    Clase\n      GestureDetector.</p>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img alt=\"Gestures on Android\" class=\"border\" src=\"asset:assets/img/5_3_flutter-gestures-b13848f4fe7f96b49f3dc482c39a6404d0b55a1551552acbecce8f9f82f8f7d5.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img alt=\"Gestures on iOS\" class=\"border\" src=\"asset:assets/img/5_3_flutter-gestures-0e5609c5c5f7c14da61ac3167ff4ad613fa2dd478a5dd34caa86e6ce400995b2.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Hacer peticiones de red HTTP</h2>\n\n  <p>Obtener datos de Internet es común para la mayoría de las aplicaciones. Y en Flutter,\n    el paquete <code>http</code> proporciona la forma más sencilla de obtener datos de Internet.</p>\n\n  <h3>\n    ¿Cómo obtengo datos de llamadas a la API?</h3>\n\n  <p>React Native proporciona la API de obtención de datos para la conexión en red: tú haces\n    una petición de búsqueda de datos y luego recibes la respuesta para obtener los datos.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\n_getIPAddress = () =&gt; {\n  fetch(\"https://httpbin.org/ip\")\n    .then(response =&gt; response.json())\n    .then(responseJson =&gt; {\n      this.setState({ _ipAddress: responseJson.origin });\n    })\n    .catch(error =&gt; {\n      console.error(error);\n    });\n};\n</code></pre></div></div></div></div>\n\n  <p>Flutter usa el paquete <code>http</code>. Para instalar el paquete <code>http</code>, añádelo a la sección\n    de dependencias de nuestro pubspec.yaml.</p>\n\n  <div><div><div>  <div><pre><code>dependencies:\n  flutter:\n    sdk: flutter\n  http: &lt;latest_version&gt;\n</code></pre></div></div></div></div>\n\n  <p>Flutter utiliza el cliente de soporte del core de HTTP\n    <code>dart:io</code>.\n    Para crear un Cliente HTTP, importa <code>dart:io</code>..</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>import 'dart:io';\n</code></pre></div></div></div></div>\n\n  <p>El cliente soporta las siguientes operaciones HTTP: GET, POST, PUT y DELETE.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nfinal url = Uri.https('httpbin.org', 'ip');\nfinal httpClient = HttpClient();\n_getIPAddress() async {\n  var request = await httpClient.getUrl(url);\n  var response = await request.close();\n  var responseBody = await response.transform(utf8.decoder).join();\n  String ip = json.decode(responseBody)['origin'];\n  setState(() {\n    _ipAddress = ip;\n  });\n}\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img alt=\"API calls on Android\" class=\"border\" src=\"asset:assets/img/5_3_api-calls-cc7facae45f34d20c206b107f53ff8469fbe73f8fc336d354c17a27a5af961ac.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img alt=\"API calls on iOS\" class=\"border\" src=\"asset:assets/img/5_3_api-calls-692bd55429656c9adc8b93074c35f88e5a550d7ca97485616108951baa7244dc.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Form input</h2>\n\n  <p>Los campos de texto permiten a los usuarios escribir texto en su aplicación para que puedan ser\n    utilizados para cuando se guarda el formulario, aplicaciones de mensajería, experiencias de\n    búsqueda y mucho más. Flutter proporciona dos widgets principales de campos de texto:&nbsp;\n    TextField y\n    TextFormField.</p>\n\n  <h3>\n    ¿Cómo utilizo los widgets de los campos de texto?</h3>\n\n  <p>En React Native, para ingresar texto se usa un componente <code>TextInput</code> para mostrar un\n    cuadro de entrada de texto y luego se usa callback para almacenar el valor en una variable.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\n&lt;TextInput\n  placeholder=\"Enter your Password\"\n  onChangeText={password =&gt; this.setState({ password })}\n /&gt;\n&lt;Button title=\"Submit\" onPress={this.validate} /&gt;\n</code></pre></div></div></div></div>\n\n  <p>En Flutter, utiliza la clase\n    <code>TextEditingController</code>\n    para administrar un widget <code>TextField</code>. Cada vez que se modifica el campo de texto, el\n    controlador notifica a sus listeners.</p>\n\n  <p>Los listeners leen el texto y las propiedades de selección para saber lo que el usuario\n    escribió en el campo. Puedes acceder al texto en <code>TextField</code> por la propiedad <code>text</code>\n    del controlador.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>// Flutter\nfinal TextEditingController _controller = TextEditingController();\n      ...\nTextField(\n  controller: _controller,\n  decoration: InputDecoration(\n    hintText: 'Type something', labelText: \"Text Field \"\n  ),\n),\nRaisedButton(\n  child: Text('Submit'),\n  onPressed: () {\n    showDialog(\n      context: context,\n        child: AlertDialog(\n          title: Text('Alert'),\n          content: Text('You typed ${_controller.text}'),\n        ),\n     );\n   },\n ),\n)\n</code></pre></div></div></div></div>\n\n  <p>En este ejemplo, cuando un usuario pulsa el botón de enviar, aparece un cuadro de diálogo\n    de alerta con el texto actual introducido en el campo de texto. Esto se consigue mediante un widget\n    <code>alertDialog</code>\n    que muestra el mensaje de alerta, y el texto del <code>TextField</code> que es accedido\n    por la propiedad <code>text</code> de\n    TextEditingController.</p>\n\n  <h3>\n    ¿Cómo utilizo los widgets Form?</h3>\n\n  <p>En Flutter, utiliza el widget\n    <code>Form</code>\n    donde los widgets\n    <code>TextFormField</code>\n    junto con el botón enviar se pasan como hijos. El widget <code>TextFormField</code>\n    tiene un parámetro llamado\n    <code>onSaved</code>\n    que toma un callback y se ejecuta cuando se guarda la forma. Un objeto <code>FormState</code>\n    se utiliza para guardar, restablecer o validar cada <code>FormField</code> que sea descendiente\n    de este <code>Form</code>. Para obtener el <code>FormState</code>, puedes usar <code>Form.of</code> con un contexto cuyo\n    antecesor es el Form, o pasar un GlobalKey al constructor de Form y\n    llamar a GlobalKey.currentState.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>final formKey = GlobalKey&lt;FormState&gt;();\n\n...\n\nForm(\n  key:formKey,\n  child: Column(\n    children: &lt;Widget&gt;[\n      TextFormField(\n        validator: (value) =&gt; !value.contains('@') ? 'Not a valid email.' : null,\n        onSaved: (val) =&gt; _email = val,\n        decoration: const InputDecoration(\n          hintText: 'Enter your email',\n          labelText: 'Email',\n        ),\n      ),\n      RaisedButton(\n        onPressed: _submit,\n        child: Text('Login'),\n      ),\n    ],\n  ),\n)\n</code></pre></div></div></div></div>\n\n  <p>El siguiente ejemplo muestra cómo <code>Form.save()</code> y <code>formKey</code> (que es un\n    <code>GlobalKey</code>) se utilizan para guardar la forma al enviarla.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>void _submit() {\n  final form = formKey.currentState;\n  if (form.validate()) {\n    form.save();\n    showDialog(\n      context: context,\n      child: AlertDialog(\n        title: Text('Alert'),\n        content: Text('Email: $_email, password: $_password'),\n      )\n    );\n  }\n}\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img alt=\"Input on Android\" class=\"border\" src=\"asset:assets/img/5_3_input-fields-0ebf3d566d9cd0e9ce79200ff08ec5dfcb3954c476e011e20c0bba7bcc33cf86.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img alt=\"Input on iOS\" class=\"border\" src=\"asset:assets/img/5_3_input-fields-67200333d1b28999ef956d0352962ea96f25a3c232f3aaa2fb90c735b244368a.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Código específico de la plataforma</h2>\n\n  <p>Cuando se crea una app multiplataforma,  deseas reutilizar la mayor cantidad de código\n    posible entre plataformas. Sin embargo, pueden surgir escenarios donde tenga sentido que\n    el código sea diferente dependiendo del sistema operativo. Esto requiere de una\n    implementación separada al declarar una plataforma específica.</p>\n\n  <p>En React Native, se utilizaría la siguiente implementación:</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nif (Platform.OS === \"ios\") {\n  return \"iOS\";\n} else if (Platform.OS === \"android\") {\n  return \"android\";\n} else {\n  return \"not recognised\";\n}\n</code></pre></div></div></div></div>\n  <p>En Flutter, utiliza la siguiente implementación:\n    <!-- skip --></p>\n  <div><div><div>  <div><pre><code>// Flutter\nif (Theme.of(context).platform == TargetPlatform.iOS) {\n  return \"iOS\";\n} else if (Theme.of(context).platform == TargetPlatform.android) {\n  return \"android\";\n} else if (Theme.of(context).platform == TargetPlatform.fuchsia) {\n  return \"fuchsia\";\n} else {\n  return \"not recognised \";\n}\n</code></pre></div></div></div></div>\n\n  <h2>\n    Debugging</h2>\n\n  <p>Antes de ejecutar tus aplicaciones, comprueba tu código con <code>flutter analyze</code>. El analizador\n    de flutter (que se envuelve alrededor de la herramienta “Dartanalyzer”) examina tu código\n    y te ayuda a identificar posibles problemas. Si estás usando un IDE que soporte Flutter,\n    esto sucede automáticamente.</p>\n\n  <h3>\n    ¿Cómo accedo al menú de desarrollador en la app?</h3>\n\n  <p>En React Native, se puede acceder al menú de desarrollador agitando el dispositivo: ⌘D\n    para el Simulador iOS o ⌘M para el emulador Android.</p>\n\n  <p>En Flutter, si estás utilizando un IDE, puedes utilizar las herramientas del IDE.\n    Si inicias tu aplicación usando <code>flutter run</code> también puedes acceder al menú pulsando\n    la <code>h</code> en la ventana del terminal, o escribiendo los siguientes shortcuts:</p>\n\n  <div>\n    <table class=\"table table-striped\">\n      <thead>\n      <tr>\n        <th style=\"text-align: left\">Acción</th>\n        <th style=\"text-align: center\">Terminal Shortcut</th>\n        <th style=\"text-align: left\">Funciones y propiedades de Debug</th>\n      </tr>\n      </thead>\n      <tbody>\n      <tr>\n        <td style=\"text-align: left\">Jerarquía de widgets de la aplicación</td>\n        <td style=\"text-align: center\"><code>w</code></td>\n        <td style=\"text-align: left\">debugDumpApp()</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Árbol de Renderizado de la app</td>\n        <td style=\"text-align: center\"><code>t</code></td>\n        <td style=\"text-align: left\">debugDumpRenderTree()</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Layers</td>\n        <td style=\"text-align: center\"><code>L</code></td>\n        <td style=\"text-align: left\">debugDumpLayerTree()</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Accesibilidad</td>\n        <td style=\"text-align: center\">\n          <code>S</code> (orden transitoria) or<br><code>U</code> (orden inverso de la prueba de éxito)</td>\n        <td style=\"text-align: left\">debugDumpSemantics()</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Para alternar el inspector de widgets</td>\n        <td style=\"text-align: center\"><code>i</code></td>\n        <td style=\"text-align: left\">WidgetsApp. showWidgetInspectorOverride</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Para alternar la visualización de las líneas de construcción</td>\n        <td style=\"text-align: center\"><code>p</code></td>\n        <td style=\"text-align: left\">debugPaintSizeEnabled</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Para simular diferentes sistemas operativos</td>\n        <td style=\"text-align: center\"><code>o</code></td>\n        <td style=\"text-align: left\">defaultTargetPlatform</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Para mostrar la ventana superpuesta de rendimiento</td>\n        <td style=\"text-align: center\"><code>P</code></td>\n        <td style=\"text-align: left\">WidgetsApp. showPerformanceOverlay</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Para guardar una captura de pantalla de flutter. png</td>\n        <td style=\"text-align: center\"><code>s</code></td>\n        <td style=\"text-align: left\">&nbsp;</td>\n      </tr>\n      <tr>\n        <td style=\"text-align: left\">Para salir</td>\n        <td style=\"text-align: center\"><code>q</code></td>\n        <td style=\"text-align: left\">&nbsp;</td>\n      </tr>\n      </tbody>\n    </table>\n  </div>\n\n  <h3>\n    ¿Cómo realizo un hot reload?</h3>\n\n  <p>La función de hot reload de Flutter te ayuda rápida y fácilmente a probar, crear UIs,\n    añadir características y corregir errores. En lugar de recompilar tu aplicación cada\n    vez que hagas un cambio, puedes recargar tu aplicación instantáneamente. La aplicación\n    se actualiza para reflejar tus cambios y se conserva el estado actual de la aplicación.</p>\n\n  <p>En React Native, el acceso directo es ⌘R para el iOS Simulator y en los emuladores\n    de Android debes pulsar R dos veces.</p>\n\n  <p>En Flutter, si utilizas el IDE IntelliJ o Android Studio, puedes seleccionar la opción\n    Guardar todo (⌘s/ctrl-s), o puedes pulsar el botón Hot Reload en la barra de herramientas.\n    Si estás ejecutando la app en la línea de comando usando <code>flutter run</code>, escribe <code>r</code>\n    en la Terminal de windows. También puedes realizar un reinicio total escribiendo <code>R</code>\n    en la Terminal de windows.</p>\n\n  <h3>\n    ¿Qué herramientas puedo usar para depurar mi aplicación en Flutter?</h3>\n\n  <p>Hay varias opciones y herramientas que puedes usar cuando necesites depurar tu\n    Flutter app.</p>\n\n  <p>Además del analizador de Flutter, el\n    <code>Dart Observatory</code> es una herramienta utilizada para\n    establecer el perfil y depurar tus aplicaciones de Dart. Si iniciaste tu aplicación usando\n    <code>flutter run</code> en el Terminal, puedes abrir la página web en la URL del Observatorio impresa en la\n    ventana de la terminal, por ejemplo: <code>http://127.0.0.1:8100/</code>.</p>\n\n  <p>El Observatorio incluye apoyo para la elaboración de perfiles, el examen del heap, la observación de\n    líneas de código ejecutadas, la depuración de memory leaks y la fragmentación de memoria. Para más\n    información, consulta la documentación del\n    Observatorio. El Observatorio es\n    incluido gratuitamente al descargar e instalar el SDK de Dart.</p>\n\n  <p>Si estás usando un IDE, puedes depurar tu aplicación usando el debugger del IDE.</p>\n\n  <p>Si utilizas IntelliJ y Android Studio, puedes utilizar el Flutter Inspector.\n    El Flutter Inspector hace que sea mucho más fácil entender por qué tu aplicación está\n    renderizando de la forma en que lo hace. Te permite:</p>\n  <ul>\n    <li>Ver la estructura de la UI de tu aplicación como un árbol de widgets</li>\n    <li>Selecciona un punto en tu dispositivo o simulador y encuentra el widget\n      correspondiente que renderizó dichos píxeles.</li>\n    <li>Ver las propiedades de widgets específicos</li>\n    <li>Identificar rápidamente los problemas de layout y determinar su causa</li>\n  </ul>\n\n  <p>La vista del Inspector de Flutter puede abrirse desde View &gt; Tool Windows &gt; Flutter\n    Inspector. El contenido se muestra únicamente cuando una aplicación está en ejecución.</p>\n\n  <p>Para inspeccionar un widget específico, selecciona la acción <strong>Toggle inspect mode</strong> en la barra\n    de herramientas y, a continuación, haz clic en el widget deseado desde el teléfono o el simulador\n    adjunto. El widget se resalta en la UI de la app. Verás el widget en la jerarquía de widgets en\n    IntelliJ y las propiedades individuales para ese widget.</p>\n\n  <p>Para más información, consulta\n    Depura tu app.</p>\n\n  <h2>\n    Animación</h2>\n\n  <p>Una animación bien diseñada hace que la UI sea intuitiva, contribuye al aspecto de una\n    aplicación pulida y mejora la experiencia del usuario. El soporte de animación de Flutter\n    facilita la implementación de animaciones simples y complejas. El SDK de Flutter incluye\n    muchos widgets de Material Design que incluyen efectos de movimiento estándar y puedes\n    personalizar fácilmente dichos efectos para personalizar tu\n    aplicación.</p>\n\n  <p>En React Native, las API Animated se utilizan para crear animaciones.</p>\n\n  <p>En Flutter, utiliza el comando\n    <code>Animation</code>\n    y la clase\n    <code>AnimationController</code>.<br>\n    La animación es una clase abstracta que entiende su valor actual y su estado (completado o\n    descartado). La clase <code>AnimationController</code> te permite reproducir una animación hacia adelante\n    o hacia atrás, o detener la animación y ajustarla a un valor específico para personalizar\n    el movimiento.</p>\n\n  <h3>\n    ¿Cómo puedo añadir una simple animación fade-in?</h3>\n\n  <p>En el siguiente ejemplo de React Native , se crea un componente animado, “FadeInView”,\n    utilizando la API Animated. Se definen el estado de opacidad inicial, el estado final y\n    la duración de la transición. El componente de animación se agrega dentro del componente\n    Animated, el estado de opacidad FadeAnim se asigna a la opacidad del componente Text que\n    deseamos animar, y luego se llama a <code>start()</code>\n    para iniciar la animación.</p>\n\n  <div><div><div>  <div><pre><code>// React Native\nclass FadeInView extends React.Component {\n  state = {\n    fadeAnim: new Animated.Value(0) // Valor inicial para la opacidad: 0\n  };\n  componentDidMount() {\n    Animated.timing(this.state.fadeAnim, {\n      toValue: 1,\n      duration: 10000\n    }).start();\n  }\n  render() {\n    return (\n      &lt;Animated.View style={{...this.props.style, opacity: this.state.fadeAnim }} &gt;\n        {this.props.children}\n      &lt;/Animated.View&gt;\n    );\n  }\n}\n    ...\n&lt;FadeInView&gt;\n  &lt;Text&gt; Fading in &lt;/Text&gt;\n&lt;/FadeInView&gt;\n    ...\n</code></pre></div></div></div></div>\n\n  <p>Para crear la misma animación en Flutter, crea un objeto\n    <code>AnimationController</code>\n    llamado <code>controller</code> y especifica la duración. Por defecto, un <code>AnimationController</code>\n    produce linealmente valores que van de 0.0 a 1.0, durante una duración determinada.\n    El controlador de animación genera un nuevo valor cuando el dispositivo que\n    ejecuta la aplicación está listo para mostrar un nuevo frame. Típicamente,\n    esta tasa es de alrededor de 60 valores por segundo.</p>\n\n  <p>Al definir un <code>AnimationController</code>, debes pasar un objeto <code>vsync</code>.\n    La presencia de <code>vsync</code> evita que las animaciones fuera de la pantalla\n    consuman recursos innecesarios. Puedes usar tu objeto stateful\n    como <code>vsync añadiendo </code>TickerProviderStateMixin’ a la definición de la clase.\n    Un <code>AnimationController</code> necesita un TickerProvider, que se configura\n    usando el argumento <code>vsync</code> en el constructor.</p>\n\n  <p>Un <code>Tween</code> describe\n    la interpolación entre un valor inicial y final o la asignación de un rango de\n    entrada a un rango de salida. Para usar un objeto <code>Tween</code> con una animación,\n    llama al método <code>animate</code> del objeto <code>Tween</code> y pásale el objeto <code>Animation</code>\n    que deseas modificar.</p>\n\n  <p>Para este ejemplo, se utiliza un widget\n    <code>FadeTransition</code>\n    y la propiedad <code>opacity</code> se asigna al objeto <code>animation</code>.</p>\n\n  <p>Para iniciar la animación, utiliza <code>controller.forward()</code>. También se pueden realizar otras\n    operaciones usando el controlador <code>fling()</code> o <code>repeat()</code>.\n    Para este ejemplo, el widget\n    <code>FlutterLogo</code> se utiliza\n    dentro del widget <code>FadeTransition</code>.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>\n// Flutter\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(Center(child: LogoFade()));\n}\n\nclass LogoFade extends StatefulWidget {\n  _LogoFadeState createState() =&gt; _LogoFadeState();\n}\n\nclass _LogoFadeState extends State&lt;LogoFade&gt; with TickerProviderStateMixin {\n  Animation animation;\n  AnimationController controller;\n\n  initState() {\n    super.initState();\n    controller = AnimationController(\n        duration: const Duration(milliseconds: 3000), vsync: this);\n    final CurvedAnimation curve =\n    CurvedAnimation(parent: controller, curve: Curves.easeIn);\n    animation = Tween(begin: 0.0, end: 1.0).animate(curve);\n    controller.forward();\n  }\n\n  Widget build(BuildContext context) {\n    return FadeTransition(\n      opacity: animation,\n      child: Container(\n        height: 300.0,\n        width: 300.0,\n        child: FlutterLogo(),\n      ),\n    );\n  }\n\n  dispose() {\n    controller.dispose();\n    super.dispose();\n  }\n}\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img alt=\"Flutter fade on Android\" class=\"border\" src=\"asset:assets/img/5_3_flutter-fade-241787290a9da1d7406516a96845a65c42c97b5a8219f4ff29f0c3412ab281ba.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img alt=\"Flutter fade on iOS\" class=\"border\" src=\"asset:assets/img/5_3_flutter-fade-2596d382757ecf7c4a2db020871d715da585db9fabed9956cbff6ef011b2786b.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h3>\n    ¿Cómo añado animación de deslizamiento a las tarjetas?</h3>\n\n  <p>En React Native, se utilizan las librerías <code>PanResponder</code> o de terceros para la animación de\n    deslizamiento.</p>\n\n  <p>En Flutter, para añadir una animación de deslizamiento, utiliza el widget\n    <code>Dismissible</code>\n    y encaja los widgets hijo.</p>\n\n  <!-- skip -->\n  <div><div><div>  <div><pre><code>child: Dismissible(\n  key: key,\n  onDismissed: (DismissDirection dir) {\n    cards.removeLast();\n  },\n  child: Container(\n    ...\n  ),\n),\n</code></pre></div></div></div></div>\n\n  <figure class=\"site-figure\">\n    <div>\n      <img src=\"asset:assets/img/5_3_card-swipe-20a57fe25c2e274bfbe0e9f3d4d1aebd5443fc9d2ce81bd6e9d2588e94e28b16.gif\">\n      <figcaption class=\"figure-caption\">Android</figcaption>\n    </div>\n    <div>\n      <img src=\"asset:assets/img/5_3_card-swipe-ed0bd70d7698b81793f2a44bea69ddf51be44ac486e8410961aabff16176e3ce.gif\">\n      <figcaption class=\"figure-caption\">iOS</figcaption>\n    </div>\n  </figure>\n\n  <h2>\n    Componentes equivalentes de React Native y Flutter Widget</h2>\n\n  <p>La siguiente tabla lista los componentes más comunmente utilizados de React Native\n    mapeados al widget Flutter correspondiente y a las propiedades comunes del widget.</p>\n\n  <div>\n    <table class=\"table table-striped\">\n      <thead>\n      <tr>\n        <th>Componente React Native</th>\n        <th>Flutter Widget</th>\n        <th>Descripción</th>\n      </tr>\n      </thead>\n      <tbody>\n      <tr>\n        <td>Button</td>\n        <td>Raised Button</td>\n        <td>Un botón básico mejorado.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onPressed [requerido]</td>\n        <td>El callback cuando el botón es pulsado o activado de otra manera.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>Child</td>\n        <td>La etiqueta del botón.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Button</td>\n        <td>Flat Button</td>\n        <td>Un botón plano básico.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onPressed [requerido]</td>\n        <td>El callback cuando el botón es pulsado o activado de otra manera.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>Child</td>\n        <td>La etiqueta del botón.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>ScrollView</td>\n        <td>ListView</td>\n        <td>Una lista desplazable de widgets dispuestos linealmente.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>children</td>\n        <td>( &lt;Widget&gt; [ ])  Lista de widgets hijos para mostrar.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>controller</td>\n        <td>[ Scroll Controller ] Un objeto que se puede usar para controlar un widget desplazable.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>itemExtent</td>\n        <td>[ double ] Si no es nulo, obliga a los hijos a tener la extensión dada en la dirección de desplazamiento.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>scroll Direction</td>\n        <td>[ Axis ] El eje en el que se desplaza la vista de desplazamiento.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>FlatList</td>\n        <td>ListView. builder()</td>\n        <td>El constructor de un array lineal de widgets que se crean bajo demanda.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>itemBuilder [requerido]</td>\n        <td>[ Indexed Widget Builder] ayuda en la construcción de los hijos a petición. Esta callback se llama sólo con índices mayores o iguales a cero y menores que itemCount.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>itemCount</td>\n        <td>[ int ] mejora la capacidad del ListView para estimar la extensión máxima de desplazamiento.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Image</td>\n        <td>Image</td>\n        <td>Un widget que muestra una imagen.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>image [requerido]</td>\n        <td>La imagen a mostrar.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>Image. asset</td>\n        <td>Se proporcionan varios constructores para las diversas formas en que se puede especificar una imagen.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>width, height, color, alignment</td>\n        <td>El estilo y diseño para la imagen.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>fit</td>\n        <td>Inscripción de la imagen en el espacio asignado durante el diseño</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Modal</td>\n        <td>ModalRoute</td>\n        <td>Una ruta que bloquea la interacción con rutas anteriores.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>animation</td>\n        <td>La animación que dirige la transición de la ruta y la transición hacia adelante de la ruta anterior.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Activity Indicator</td>\n        <td>Circular Progress Indicator</td>\n        <td>Un widget que muestra el progreso a lo largo de un círculo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>strokeWidth</td>\n        <td>El ancho de la línea utilizada para dibujar el círculo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>backgroundColor</td>\n        <td>El color de fondo del indicador de progreso. El tema actual es <code>ThemeData.backgroundColor</code> por defecto.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Activity Indicator</td>\n        <td>Linear Progress Indicator</td>\n        <td>Un widget que muestra el progreso a lo largo de un círculo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>value</td>\n        <td>El valor de este indicador de progreso.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Refresh Control</td>\n        <td>Refresh Indicator</td>\n        <td>Un widget que soporta el modismo de Material “deslizar para actualizar”.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>color</td>\n        <td>El color principal del indicador de progreso.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onRefresh</td>\n        <td>Una función que se llama cuando un usuario arrastra el indicador de actualización lo suficiente como para demostrar que desea que la app se actualice.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>View</td>\n        <td>Container</td>\n        <td>Un widget que rodea a un widget hijo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>View</td>\n        <td>Column</td>\n        <td>Un widget que muestra a sus hijos en una matriz vertical.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>View</td>\n        <td>Row</td>\n        <td>Un widget que muestra a sus hijos en una matriz horizontal.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>View</td>\n        <td>Center</td>\n        <td>Un widget que centra a su hijo dentro de sí mismo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>View</td>\n        <td>Padding</td>\n        <td>Un widget que inserta a su hijo utilizando el padding proporcionado.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>padding [requerido]</td>\n        <td>[ EdgeInsets ] La cantidad de espacio para insertar al hijo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Touchable Opacity</td>\n        <td>Gesture Detector</td>\n        <td>Un widget que detecta gestos.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onTap</td>\n        <td>Un callback cuando un toque ocurre.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onDoubleTap</td>\n        <td>Un callback cuando un toque ocurre en el mismo lugar dos veces seguidas.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Text Input</td>\n        <td>Text Input</td>\n        <td>La interfaz para el control de entrada de texto del sistema.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>controller</td>\n        <td>[ Text Editing Controller ] para acceder y modificar el texto.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Text</td>\n        <td>Text</td>\n        <td>El widget Texto que muestra una cadena de texto con un único estilo.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>data</td>\n        <td>[ String ] El texto a mostrar.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>textDirection</td>\n        <td>[ Text Align ] La dirección en la que fluye el texto.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Switch</td>\n        <td>Switch</td>\n        <td>Un switch de material design.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>value [requerido]</td>\n        <td>[ boolean ] Si este switch está encendido o apagado.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onChanged [requerido]</td>\n        <td>[ callback ] Se llama cuando el usuario activa o desactiva el switch.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n        <td>&nbsp;</td>\n      </tr>\n      <tr>\n        <td>Slider</td>\n        <td>Slider</td>\n        <td>Se utiliza para seleccionar entre un rango de valores.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>value [requerido]</td>\n        <td>[ double ] El valor actual del slider.</td>\n      </tr>\n      <tr>\n        <td>&nbsp;</td>\n        <td>onChanged [requerido]</td>\n        <td>Se llama cuando el usuario selecciona un nuevo valor para el slider.</td>\n      </tr>\n      </tbody>\n    </table>\n  </div>\n\n\n</div>"
    },
    {
        "title": "5.4 Flutter para web devs",
        "subtitle": "Introduccion",
        "content":  ""
    },
    {
        "title": "5.5 Flutter para Xamarin.Forms devs",
        "subtitle": "Introduccion",
        "content":  ""
    },
    {
        "title": "6 Introducción a los Widgets",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.1 Layouts en Flutter",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.2 Tutorial de layout",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.3 Box constraints",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.4 Añade Interactividad a Tu App Flutter",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.5 Assets e imagenes",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.6 Navegación & enrutado",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.7 animaciones - Introduccion",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.8 Visión general de animaciones",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.9 Slivers y Gestos - UI avanzado",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.8 Visión general de animaciones",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    },
    {
        "title": "6.8 Visión general de animaciones",
        "subtitle": "Interfaz de Usuario",
        "content":  ""
    }
]